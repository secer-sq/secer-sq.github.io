<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>故园遗剑</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-14T09:53:39.223Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mys3t</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客文章加密</title>
    <link href="http://yoursite.com/2020/10/14/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/"/>
    <id>http://yoursite.com/2020/10/14/博客文章加密/</id>
    <published>2020-10-14T09:36:38.000Z</published>
    <updated>2020-10-14T09:53:39.223Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">此处输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="c7834b167d6a0e44919c3decac9539d05a28066001a8732ad9b7e6e626d01162">753ca762744ce41a3b758f64d2c9e2cac54ebb0e04572651dd1a728a4c13c995014a638bc7ff4202e16b046432dc55c89089ca00d92d69b4b9b4e52cc776f9df47e1fc8ea00b6556017a75b0a77ba4e9ba0e45c034176100ba05cbd153c7b1391dfab6a698d8dbe553242c0758b0011d4c5d66f29f72ab93d7f2ab0b38a241ff830122b4dfac407896a45e0ce8a585140e0949a36f2b23fe062e032fe4cd25a5566b8b64cf28cc5baefc7cf50af124ef776f2ed1504f4849697a066e74905aac431e74a62ac033b0e6e4d6fef74bf89c181702f36b868d56798903330e6f05004505ff2223585b8e5ee5f802ea1be588d4c9577bfa7a9e8c141aad46d45d3875db0d2c310df006096a297e7d2550c62e60d5b335dcfec475c2c68d4017571bcd79a79e6f9973bdebdcb9e8b568d604ef71dc1730c957f19d4b2933e1a16c3cdea1e197f42aff4bd999c57b5b0f43ffe93e0ab9d8cded174cdb443435d7c173221abbbb332a63aa4f768b1894448531d0a55592f35810c0d33e33d64ef6ecd64d7909cd975908eaaf8007d64d6adbadd381656789bf04422f531cdc7b01936fa554c8b420fab18ddd3546bccfa98ed618c8d649eac9f5740d813eb05b1790308e14abc370f19630ecc8a01680af528120327afe26e053fe1d0da51a711019ce2c9cb997e9f7e568e95992ce9a974f49f028a802067383db0e90325d0c433d7785f93d66b0814bf7f971b369193052617267c6ba208a44dfa05ad1f20fd5d212dcd2d8ecfcdb28f689b1d0d9184d5994f2db888bf0c3b54e8de01b15bbd5b752e619eae26cedb8db95edc17449fa4fa8897612addfab05a03d35d578630c0976696c8787d1482cb9347d1619b7e64b712b5796fa4aee9ec068994f12267ff9bec48338c1fcc82b0907de506f2a5b62de91a59d112bb7e263037c9bf1397faff35b552e4c371bee805ba2c0559b4210cc3ca76b66ef54d1553b6b33b9a34e0c6504c97ecb43f5b7124cc7cc16ea992f5312a03f5e8cb3e04b64218df5006c4c4cdcf8e444ee05b3a05fa8efb3321148e30c7dcfc3d9e21129f8222b50b5bd6a18419850896619f9b77a8f14fe6a043913be6c5d6d625a13636fb31d459da969533d401da725fa5c1bdec4d8caf5ec4b20f3fb38482eec4d52d6158721ac0c401d5662ff88fd466ee42b8b45ac8e1d42784e311dca048d6aa6e86603efd3bce3af55dcfa1de747558c15040100479faa84cfaffc56e28f2f6e084c6d7c65cd2a5def446e2dafbfa442a40a24afaf9d35c8b559a0c972d9ab622a0dbb8264b63845e50e320862c0fd3e98fe300eb2977b713c34de068c72dba87f27c6027fca4b299877b272c134238ad4d29aaf95eed899520e09662625d43f6b93c24d706700f160fb14f5bed3ade311987b6430471bafd59958c3f88e09d662cc56d5a2ef14636250332fcf8ba8595635dd687b2230159d5b1eb0e140ccdde6ba5b45735ad468c3d594b93ee4b22aa52e9a50ae0809d2d49bdcab990379e23b4860cfe79d70411de9ebf00989ff1b5f4c1445684c8dbc481537676f3aec5e163433ec2bdeff00fbc34eb747eb8281fda4f620b914d3aa487a6646d72ac4cda9f6c7134bd3bdd7813661e7369ea74c642f63bbc07f8a9824e95c6ed2ebb88db83b405f8801cc6f9a8c817a020206893ec8f8480e51a4b0b356df7770b4087a4dafbb88586798bb6355ceeab2372b07246598a1efcd9059517d0fe692857cafffb1b6e4003854130a49ccc9a2b4801e64b8c052d5a1bcf3ff4480887d7f70a2134ae13fb2a2d1c98ea6b55552ca2ecb76da13206fdb80e53c9024b8d48c73587bdc15b918f6a94160c1bbabd5ce04a1dee20d1bd7e2d146ff4d72ceb656c8bd12fac3e074dd1bb627c4c4ff2fca8d51f1e670a12451efb2abe598137c95ca19208d081209aa70fa0797f6e3fbfbf0fa2203057d531e61414f1535ca9c42fba9d490956c866bf6c7d4cad98e4b203968e7448eb9d7c67a7dcabbcd441e7cff37e6bcecdfb82d6acc1ee56aef0a8e431c976bc19c403a73874bfe8e9d8d56a4f401ae503e0f70c36f1a1c8872d2525e8439b39445b7b6ce1b170674ad5f83340ffca7593e8f173a6d364a159569d03b7b66ac5c161e2c345b3401b3ce0a8b2bd0e4b04706ace6439f544c807dbaa36fe1711241231ffd6f1d34cf2541e142e4ddabfae0fa3b3c8f129104bc80c9d8c86fb7f156392e90afaf145c72fe21309f64356acb6c30061676378c0fdceb84b7d87f284fe0bdd3337d4c46a4792142526a5e4878c0733c4055cdb83f2907cf8f9c3c7247aa290ed42139c1c64eb393428ce2d06686922ca3f6c7a350cc4161fe80d1f5ab31966610474039cdac646e2034ccec41b385a06cb849f3d994f487fc8f8a2321e84e96a990b8c43970179144a61277d65194244222b3a1644158297ada73275970c77601035ed27ea15b5dfacc3eaed464c163b0ccc489655db153e9a5cd4d93667d438de0e4bbb57a7fcf6fe3d6573540ad9bf8db5236bfacdc09b81ad1b0fb7c2811c531aff80a6360fc8feb38db8fed93c2ecf4f63a6a770e5e29fc7628c1f956ce38b0c25e1e70814882e3640f49f9667788105e74a74fb54c3d482484a5afdaf2717ddbcd90b27e7a89307f1d492dbe901277cf03a7711a9ccdeec8f253ed026cbc9021d4c01d9795976dc4c67ccf5aabf72901dc685fab01ba7838d8837506f5f9173a059336d2810381114c4c5fa22ccc6f48bbe6bb725d23ad9bf8028512271e753bbd3c872152c990f881c73073d2bcb00f7c6c0a97d71c82f9aa3598babba5d158fcbf829ddb5c8ea1401be967ef5d640e526df860c258b92cc0937a1a0cce411bdd51f34cdea6a4dc6fe79823fca6720bb8ebd804af3d00ed35be1f3f705c82bab616788e80ba7c5404cbd65dbe4880a2ab6b4514fcfb47120fe9f6be2c2992bb3080f78f97a9ce79c00ce4d5425fd7d042a34f4355dc068244806ee77e51915afcba367cfd104716aea282e548d62970dcd238037399aadee4529d386e126082d3a7bf827ff6708b106c87a0f787d965d52084870e1f6f6fd7f25af68797c184b1c187e352919670723d04805229b712d0782575381cdedde299ff1836d6779f6946a818757ae52962d29135bdb0d46100899d33ed67dee18f9b43d114a621f223904076952d531e425316cd869ec9915f63bdb1227c4a8215d48a9c8f071636a6b123e0e8f1593b165821ee6c3774a6364304caf9e6eb40502cc5a29204c8d804aceecbcbddf815b6c920d6597a423f3bb028d4987340c681b4d7db7689b7b2b177da21d64a95a46041fca12c7202284b6916a836da4606964ef52f467f3fdd9160abf8c0079978b928d31ef132b0e9</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本文有密码保护
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客搭建" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="http://yoursite.com/2020/10/14/Linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/10/14/Linux基础/</id>
    <published>2020-10-14T08:58:41.000Z</published>
    <updated>2020-10-15T03:17:28.250Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015111629482.png" alt="image-20201015111629482" style="zoom:25%;"></p><h2 id="密码重置"><a href="#密码重置" class="headerlink" title="密码重置"></a>密码重置</h2><p>重置root管理员的密码：</p><p>先确定是否为RHEL 7系统。如果是，然后再进行下面的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;redhat-release</span><br></pre></td></tr></table></figure><p>重启Linux系统主机并出现引导界面时，按下键盘上的e键进入内核编辑界面，如图:</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014180103083.png" alt="image-20201014180103083"></p><p>在linux16参数这行的最后面追加“rd.break”参数，然后按下Ctrl+X组合键来运行修改过的内核程序</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014180224557.png" alt="image-20201014180224557"></p><p>大约30秒过后，进入到系统的紧急求援模式</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014180437309.png" alt="image-20201014180437309"></p><p>依次输入以下命令，等待系统重启操作完毕，然后就可以使用新密码来登录Linux系统了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount,rw  &#x2F;sysroot</span><br><span class="line">chroot  &#x2F;sysroot</span><br><span class="line">passwd</span><br><span class="line">touch  &#x2F;.autorelabel</span><br><span class="line">exit</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014180700619.png" alt="image-20201014180700619"></p><h2 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h2><p>RPM有点像Windows系统中的控制面板，会建立统一的数据库文件，详细记录软件信息并能够自动分析依赖关系。</p><p>常用的RPM软件包命令：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014180805106.png" alt="image-20201014180805106"></p><p>常见yum命令：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014180855181.png" alt="image-20201014180855181"></p><h2 id="系统工作命令"><a href="#系统工作命令" class="headerlink" title="系统工作命令"></a>系统工作命令</h2><h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><p>echo命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]”。</p><p>使用$变量的方式提取变量SHELL的值，并将其输出到屏幕上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h4 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h4><p>date命令用于显示及设置系统的时间或日期，格式为“date [选项] [+指定的格式]”。</p><p>date命令中的参数以及作用：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014181414166.png" alt="image-20201014181414166"></p><h4 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a>reboot命令</h4><p>reboot命令用于重启系统，其格式为reboot。</p><p>重启计算机这种操作会涉及硬件资源的管理权限，因此默认只能使用root管理员来重启，其命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h4 id="poweroff命令"><a href="#poweroff命令" class="headerlink" title="poweroff命令"></a>poweroff命令</h4><p>poweroff命令用于关闭系统，其格式为poweroff。</p><h4 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h4><p>wget命令用于在终端中下载网络文件，格式为“wget [参数]下载地址”。</p><p>wget命令的参数以及作用：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014181700177.png" alt="image-20201014181700177"></p><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令用于查看系统中的进程状态，格式为“ps [参数]”。</p><p>常用方式：<code>ps aux</code></p><p>当执行ps aux命令后通常会看到如图所示的进程状态</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014181936134.png" alt="image-20201014181936134"></p><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>top命令用于动态地监视进程活动与系统负载等信息，其格式为top。</p><p>top命令相当强大，能够动态地查看系统运维状态，完全将它看作Linux中的“强化版的Windows任务管理器”。</p><h4 id="pidof命令"><a href="#pidof命令" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof命令用于查询某个指定服务进程的PID值，格式为“pidof [参数] [服务名称]”。</p><p>每个进程的进程号码值（PID）是唯一的，因此可以通过PID来区分不同的进程。例如，可以使用如下命令来查询本机上sshd服务程序的PID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidof ssh</span><br></pre></td></tr></table></figure><h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令用于终止某个指定PID的服务进程，格式为“kill [参数] [进程PID]”。</p><p>这种操作的效果等同于强制停止服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 2516</span><br></pre></td></tr></table></figure><h4 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [进程名称]”。</p><p>复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这些进程会比较麻烦，此时可以使用killall命令来批量结束某个服务程序带有的全部进程。</p><h2 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h2><h4 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h4><p>ifconfig命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备]参数。</p><h4 id="uname命令"><a href="#uname命令" class="headerlink" title="uname命令"></a>uname命令</h4><p>uname命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。</p><p>在使用uname命令时，一般会固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。</p><p>如果要查看当前系统版本的详细信息，则需要查看redhat-release文件，其命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;redhat-release</span><br></pre></td></tr></table></figure><h4 id="uptime命令"><a href="#uptime命令" class="headerlink" title="uptime命令"></a>uptime命令</h4><p>uptime用于查看系统的负载信息，格式为uptime。</p><p>uptime命令可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况；负载值越低越好，尽量不要长期超过1，在生产环境中不要超过5。</p><h4 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h4><p>free用于显示当前系统中内存的使用量信息，格式为“free  -h”。</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014183203302.png" alt="image-20201014183203302"></p><h4 id="who命令"><a href="#who命令" class="headerlink" title="who命令"></a>who命令</h4><p>who用于查看当前登入主机的用户终端信息，格式为whoami。</p><h4 id="last命令"><a href="#last命令" class="headerlink" title="last命令"></a>last命令</h4><p>last命令用于查看所有系统的登录记录，格式为“last [参数]”。</p><h4 id="history命令"><a href="#history命令" class="headerlink" title="history命令"></a>history命令</h4><p>history命令用于显示历史执行过的命令，在使用history命令时，如果使用-c参数则会清空所有的命令历史记录。还可以使用“！编码数字”的方式来重复执行某一次的命令。</p><h4 id="sosreport命令"><a href="#sosreport命令" class="headerlink" title="sosreport命令"></a>sosreport命令</h4><p>sosreport命令用于收集系统配置及架构信息并输出诊断文档，格式为sosreport。</p><h2 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h2><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p>pwd命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。</p><h4 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h4><p>cd命令用于切换工作路径，格式为“cd [目录名称]”。可以通过cd命令迅速、灵活地切换到不同的工作目录。除了常见的切换目录方式，还可以使用“cd -”命令返回到上一次所处的目录，使用“cd..”命令进入上级目录，以及使用“cd ~”命令切换到当前用户的家目录，亦或使用“cd ~username”切换到其他用户的家目录。</p><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p>ls命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la    #查看当前目录中的所有文件并输出这些文件的属性信息</span><br></pre></td></tr></table></figure><h2 id="文本编辑命令"><a href="#文本编辑命令" class="headerlink" title="文本编辑命令"></a>文本编辑命令</h2><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><p>cat命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n  #显示行号</span><br></pre></td></tr></table></figure><h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><p>more命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。</p><p>more命令会在最下面使用百分比的形式来提示已经阅读了多少内容。可以使用空格键或回车键向下翻页。 </p><h4 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h4><p>head命令用于查看纯文本文档的前N行，格式为“head [选项] [文件]”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 20 文档  #查看文档的前20行</span><br></pre></td></tr></table></figure><h4 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h4><p>tail命令用于查看纯文本文档的后N行或持续刷新内容，格式为“tail [选项] [文件]”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f 文件名  #实时查看最新日志文件时</span><br></pre></td></tr></table></figure><h4 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h4><p>tr命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。</p><h4 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h4><p>wc命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数]文本”。</p><p>wc的参数以及作用:</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014195631027.png" alt="image-20201014195631027"></p><p>如要统计当前系统中有多少个用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -l  &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><h4 id="stat命令"><a href="#stat命令" class="headerlink" title="stat命令"></a>stat命令</h4><p>stat命令用于查看文件的具体存储信息和时间等信息，格式为“stat文件名称”。</p><h4 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h4><p>cut命令用于按“列”提取文本字符，格式为“cut [参数]文本”。</p><h4 id="diff命令"><a href="#diff命令" class="headerlink" title="diff命令"></a>diff命令</h4><p>diff命令用于比较多个文本文件的差异，格式为“diff [参数]文件”。</p><p>可以使用–brief参数来确认两个文件是否不同，还可以使用-c参数来详细比较出多个文件的差异之处</p><h2 id="目录管理命令"><a href="#目录管理命令" class="headerlink" title="目录管理命令"></a>目录管理命令</h2><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p>touch命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。</p><h4 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h4><p>mkdir命令用于创建空白的目录，格式为“mkdir [选项]目录”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p  递归创建目录</span><br></pre></td></tr></table></figure><h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><p>cp命令用于复制文件或目录，格式为“cp [选项]源文件 目标文件”。</p><p>cp命令参数以及作用：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014200319909.png" alt="image-20201014200319909"></p><h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p>mv命令用于剪切文件或将文件重命名，格式为“mv [选项]源文件 [目标路径|目标文件名]”。</p><h4 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h4><p>rm命令用于删除文件或目录，格式为“rm [选项]文件”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf 彻底删除</span><br></pre></td></tr></table></figure><h4 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h4><p>file命令用于查看文件的类型，格式为“file文件名”。</p><h2 id="打包压缩命令"><a href="#打包压缩命令" class="headerlink" title="打包压缩命令"></a>打包压缩命令</h2><h4 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h4><p>tar命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。</p><p>tar命令参数及作用：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014200921988.png" alt="image-20201014200921988"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-c 用于创建压缩文件</span><br><span class="line"></span><br><span class="line">-x 用于解压文件</span><br><span class="line"></span><br><span class="line">-C 用于指定要解压到哪个指定的目录</span><br><span class="line"></span><br><span class="line">-f 必须放到参数的最后一位，代表要压缩或解压的软件包名称</span><br><span class="line"></span><br><span class="line">-v 不断显示压缩或解压的过程</span><br><span class="line"></span><br><span class="line">tar zxvf  x.tar.gz 解压缩</span><br><span class="line">tar zcvf  etc.tar.gz  压缩</span><br></pre></td></tr></table></figure><h4 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h4><p>grep命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。grep命令的参数及其作用如下所示。</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014201401666.png" alt="image-20201014201401666"></p><h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>find命令用于按照指定条件来查找文件，格式为“find [查找路径]寻找条件 操作”。</p><p>find命令中的参数及作用：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014201458583.png" alt="image-20201014201458583"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec    用于把find命令搜索到的结果交由紧随其后的命令作进一步处理</span><br></pre></td></tr></table></figure><h2 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h2><p>在Linux系统中，目录、字符设备、块设备、套接字、打印机等都被抽象成了文件。</p><p>Linux系统中的一切文件都是从“根（/）”目录开始的，并按照文件系统层次化标准（FHS）采用树形结构来存放文件，以及定义了常见目录的用途。另外，Linux系统中的文件和目录名称是严格区分大小写的。例如，root、rOOt、Root、rooT均代表不同的目录，并且文件名称中不得包含斜杠（/）。Linux系统中的文件存储结构如图：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014201745499.png" alt="image-20201014201745499"></p><p>Linux系统中常见的目录名称以及相应内容：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014201822553.png" alt="image-20201014201822553"></p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>Linux最常见的文件系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ext3：是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。</span><br><span class="line"></span><br><span class="line">Ext4:Ext3的改进版本,支持的存储容量高达1EB。</span><br><span class="line"></span><br><span class="line">XFS：是一种高性能的日志文件系统，而且是RHEL 7中默认的文件管理系统，它的优势在可以快速地恢复可能被破坏的文件，最大可支持的存储容量为18EB。</span><br></pre></td></tr></table></figure><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><h4 id="mount命令"><a href="#mount命令" class="headerlink" title="mount命令"></a>mount命令</h4><p>mount命令用于挂载文件系统，格式为“mount文件系统 挂载目录”。mount命令中可用的参数及作用如下：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014202423980.png" alt="image-20201014202423980"></p><p>如果想让硬件设备和目录永久地进行自动关联，就必须把挂载信息按照指定的填写格式“设备文件   挂载目录  格式类型  权限选项   自检   优先级”写入到/etc/fstab文件中。</p><p>各字段代表含义：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014202609337.png" alt="image-20201014202609337"></p><p>想将文件系统为ext4的硬件设备/dev/sdb2在开机后自动挂载到/backup目录上，并保持默认权限且无需开机自检，就需要在/etc/fstab文件中写入下面的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;fstab</span><br><span class="line"></span><br><span class="line">&#x2F;dev&#x2F;sdb2   &#x2F;backup   ext4   defaults  0 0</span><br></pre></td></tr></table></figure><h4 id="umount命令"><a href="#umount命令" class="headerlink" title="umount命令"></a>umount命令</h4><p>umount命令用于撤销已经挂载的设备文件，格式为“umount [挂载点/设备文件]”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount  &#x2F;dev&#x2F;sdb2</span><br></pre></td></tr></table></figure><h2 id="新硬盘初始化"><a href="#新硬盘初始化" class="headerlink" title="新硬盘初始化"></a>新硬盘初始化</h2><h4 id="fdisk命令"><a href="#fdisk命令" class="headerlink" title="fdisk命令"></a>fdisk命令</h4><p>fdisk命令用于管理磁盘分区，格式为“fdisk [磁盘名称]”，它提供了集添加、删除、转换分区等功能于一身。</p><p>fdisk命令中的参数及作用：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203146079.png" alt="image-20201014203146079"></p><h4 id="管理新硬盘"><a href="#管理新硬盘" class="headerlink" title="管理新硬盘"></a>管理新硬盘</h4><p>如管理/dev/sdb硬盘设备</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203324621.png" alt="image-20201014203324621"></p><p>输入参数n添加新的分区。系统会要求选择继续输入参数p来创建主分区，还是输入参数e来创建扩展分区。这里输入参数p来创建一个主分区：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203412483.png" alt="image-20201014203412483"></p><p>在确认创建一个主分区后，系统要求先输入主分区的编号。主分区的编号范围是1～4，输入默认的1即可。接下来系统会提示定义起始的扇区位置，这不需要改动，敲击回车键保留默认设置即可。</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203540816.png" alt="image-20201014203540816"></p><p>再次使用参数p来查看硬盘设备中的分区信息。果然就能看到一个名称为/dev/sdb1、起始扇区位置为2048、结束扇区位置为4196351的主分区了。这时候千万不要直接关闭窗口，而应该敲击参数w后回车，这样分区信息才是真正的写入成功啦。</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203639568.png" alt="image-20201014203639568"></p><p>如果硬件存储设备没有进行格式化，则Linux系统无法写入数据。因此，在对存储设备进行分区后还需要进行格式化操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.xfs &#x2F;dev&#x2F;sdb1</span><br></pre></td></tr></table></figure><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203809697.png" alt="image-20201014203809697"></p><p>挂载并使用存储设备了。与之相关的步骤也非常简单：首先是创建一个用于挂载设备的挂载点目录；然后使用mount命令将存储设备与挂载点进行关联；最后使用df -h命令来查看挂载状态和硬盘使用量信息。</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014203904081.png" alt="image-20201014203904081"></p><p>最后将挂载目录写到fstab中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;fstab</span><br><span class="line"></span><br><span class="line">&#x2F;dev&#x2F;sdb2   &#x2F;backup   xfs   defaults  0 0</span><br></pre></td></tr></table></figure><h2 id="RAID-独立冗余磁盘阵列"><a href="#RAID-独立冗余磁盘阵列" class="headerlink" title="RAID(独立冗余磁盘阵列)"></a>RAID(独立冗余磁盘阵列)</h2><p>由于硬盘设备需要进行持续、频繁、大量的IO操作，相较于其他设备，其损坏几率也大幅增加，导致重要数据丢失的几率也随之增加。</p><p>RAID技术通过把多个硬盘设备组合成一个容量更大、安全性更好的磁盘阵列，并把数据切割成多个区段后分别存放在各个不同的物理硬盘设备上，然后利用分散读写技术来提升磁盘阵列整体的性能，同时把多个重要数据的副本同步到不同的物理硬盘设备上，从而起到了非常好的数据冗余备份效果。</p><h4 id="RAID0"><a href="#RAID0" class="headerlink" title="RAID0"></a>RAID0</h4><p>RAID 0技术把多块物理硬盘设备（至少两块）通过硬件或软件的方式串联在一起，组成一个大的卷组，并将数据依次写入到各个物理硬盘中。这样一来，在最理想的状态下，硬盘设备的读写性能会提升数倍，但是若任意一块硬盘发生故障将导致整个系统的数据都受到破坏。通俗来说，RAID 0技术能够有效地提升硬盘数据的吞吐速度，但是不具备数据备份和错误修复能力。</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014204634126.png" alt="image-20201014204634126"></p><h4 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h4><p>RAID 1是把两块以上的硬盘设备进行绑定，在写入数据时，是将数据同时写入到多块硬盘设备上（可以将其视为数据的镜像或备份）。当其中某一块硬盘发生故障后，一般会立即自动以热交换的方式来恢复数据的正常使用。</p><p>RAID 1技术虽然十分注重数据的安全性，但是因为是在多块硬盘设备中写入了相同的数据，因此硬盘设备的利用率得以下降，从理论上来说，两块硬盘空间的真实可用率只有50%，由三块硬盘设备组成的RAID 1磁盘阵列的可用率只有33%左右，以此类推。</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014204829583.png" alt="image-20201014204829583"></p><h4 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h4><p>RAID5技术是把硬盘设备的数据奇偶校验信息保存到其他硬盘设备中。RAID 5磁盘阵列组中数据的奇偶校验信息并不是单独保存到某一块硬盘设备中，而是存储到除自身以外的其他每一块硬盘设备上，这样的好处是其中任何一设备损坏后不至于出现致命缺陷；存放的为数据的奇偶校验信息，换句话说，就是RAID 5技术实际上没有备份硬盘中的真实数据信息，而是当硬盘设备出现问题后通过奇偶校验信息来尝试重建损坏的数据。RAID这样的技术特性“妥协”地兼顾了硬盘设备的读写速度、数据安全性与存储成本问题。</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014205012323.png" alt="image-20201014205012323"></p><h4 id="RAID10"><a href="#RAID10" class="headerlink" title="RAID10"></a>RAID10</h4><p> RAID 10技术是RAID 1+RAID 0技术的一个“组合体”。RAID 10技术需要至少4块硬盘来组建，其中先分别两两制作成RAID 1磁盘阵列，以保证数据的安全性；然后再对两个RAID 1磁盘阵列实施RAID 0技术，进一步提高硬盘设备的读写速度。这样从理论上来讲，只要坏的不是同一组中的所有硬盘，那么最多可以损坏50%的硬盘设备而不丢失数据。由于RAID 10技术继承了RAID 0的高读写速度和RAID 1的数据安全性，在不考虑成本的情况下RAID 10的性能都超过了RAID 5，因此当前成为广泛使用的一种存储技术。</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014205315935.png" alt="image-20201014205315935"></p><h2 id="LVM逻辑卷"><a href="#LVM逻辑卷" class="headerlink" title="LVM逻辑卷"></a>LVM逻辑卷</h2><h4 id="LVM技术"><a href="#LVM技术" class="headerlink" title="LVM技术"></a>LVM技术</h4><p>逻辑卷管理器是Linux系统用于对硬盘分区进行管理的一种机制，理论性较强，其创建初衷是为了解决硬盘设备在创建分区后不易修改分区大小的缺陷。尽管对传统的硬盘分区进行强制扩容或缩容从理论上来讲是可行的，但是却可能造成数据的丢失。而LVM技术是在硬盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行卷组合并。这样一来，用户不必关心物理硬盘设备的低层架构和布局，就可以实现对硬盘分区的动态调整。</p><p>LVM技术架构如图：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014205517502.png" alt="image-20201014205517502"></p><p>物理卷处于LVM中的最底层，可以将其理解为物理硬盘、硬盘分区或者RAID磁盘阵列，这都可以。卷组建立在物理卷之上，一个卷组可以包含多个物理卷，而且在卷组创建之后也可以继续向其中添加新的物理卷。逻辑卷是用卷组中空闲的资源建立的，并且逻辑卷在建立后可以动态地扩展或缩小空间。这就是LVM的核心理念。</p><h4 id="部署逻辑卷"><a href="#部署逻辑卷" class="headerlink" title="部署逻辑卷"></a>部署逻辑卷</h4><p>常用的LVM部署命令：</p><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201014205812792.png" alt="image-20201014205812792"></p><p>先对这两块新硬盘进行创建物理卷的操作，可以将该操作简单理解成让硬盘设备支持LVM技术，或者理解成是把硬盘设备加入到LVM技术可用的硬件资源池中，然后对这两块硬盘进行卷组合并，卷组的名称可以由用户来自定义。接下来，根据需求把合并后的卷组切割出一个约为150MB的逻辑卷设备，最后把这个逻辑卷设备格式化成EXT4文件系统后挂载使用。</p><p>第1步：让新添加的两块硬盘设备支持LVM技术。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pvcreate  &#x2F;dev&#x2F;sdb &#x2F;dev&#x2F;sdc</span><br></pre></td></tr></table></figure><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015095211198.png" alt="image-20201015095211198"></p><p>第2步：把两块硬盘设备加入到storage卷组中，然后查看卷组的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vgcreate storge  &#x2F;dev&#x2F;sdb  &#x2F;dev&#x2F;sdc</span><br><span class="line">vgdisplay  #查看vg卷组状态</span><br></pre></td></tr></table></figure><p>第3步：切割出一个约为150MB的逻辑卷设备。</p><p>这里需要注意切割单位的问题。在对逻辑卷进行切割时有两种计量单位。第一种是以容量为单位，所使用的参数为-L。例如，使用-L 150M生成一个大小为150MB的逻辑卷。另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -n  vo -l 37 storge  #创建了大小为37x4大小名为vo的逻辑卷</span><br><span class="line">lvdisplay   #查看lv逻辑卷状态</span><br></pre></td></tr></table></figure><p>第4步：把生成好的逻辑卷进行格式化，然后挂载使用。</p><p>Linux系统会把LVM中的逻辑卷设备存放在/dev设备目录中（实际上是做了一个符号链接），同时会以卷组的名称来建立一个目录，其中保存了逻辑卷的设备映射文件（即/dev/卷组名称/逻辑卷名称）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4  &#x2F;dev&#x2F;storge&#x2F;vo   #&#x2F;dev&#x2F;卷组名称&#x2F;逻辑卷名称</span><br><span class="line">mkdir &#x2F;data</span><br><span class="line">mount &#x2F;dev&#x2F;storge&#x2F;vo  &#x2F;data</span><br></pre></td></tr></table></figure><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015102706619.png" alt="image-20201015102706619"></p><p>第5步：查看挂载状态，并写入到配置文件，使其永久生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br><span class="line">echo &quot;dev&#x2F;storge&#x2F;vo  &#x2F;data  ext4  defaults 0 0&quot; &gt;&gt; &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure><h4 id="扩容逻辑卷"><a href="#扩容逻辑卷" class="headerlink" title="扩容逻辑卷"></a>扩容逻辑卷</h4><p>只要卷组中有足够的资源，就可以一直为逻辑卷扩容。扩展前一定要记得卸载设备和挂载点的关联。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount &#x2F;data</span><br></pre></td></tr></table></figure><p>第1步：把逻辑卷vo扩展至290MB。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvextend -L 290M &#x2F;dev&#x2F;storge&#x2F;vo</span><br></pre></td></tr></table></figure><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015103350087.png" alt="image-20201015103350087"></p><p>第2步：检查硬盘完整性，并重置硬盘容量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e2fsck -f  &#x2F;dev&#x2F;storge&#x2F;vo  #检查硬盘完整性</span><br><span class="line"></span><br><span class="line">resize2fs  &#x2F;dev&#x2F;storge&#x2F;vo  #重置硬盘容量</span><br></pre></td></tr></table></figure><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015103723401.png" alt="image-20201015103723401"></p><p>第3步：重新挂载硬盘设备并查看挂载状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -a</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure><h4 id="逻辑卷快照"><a href="#逻辑卷快照" class="headerlink" title="逻辑卷快照"></a>逻辑卷快照</h4><p>LVM还具备有“快照卷”功能，该功能类似于虚拟机软件的还原时间点功能。例如，可以对某一个逻辑卷设备做一次快照，如果日后发现数据被改错了，就可以利用之前做好的快照卷进行覆盖还原。LVM的快照卷功能有两个特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">快照卷的容量必须等同于逻辑卷的容量</span><br><span class="line"></span><br><span class="line">快照卷仅一次有效，一旦执行还原操作后则会立即删除</span><br></pre></td></tr></table></figure><p>首先查看卷组的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgdisplay</span><br></pre></td></tr></table></figure><p>第1步：使用-s参数生成一个快照卷，使用-L参数指定切割的大小。另外，还需要在命令后面写上是针对哪个逻辑卷执行的快照操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L 120M -s -n SNAP &#x2F;dev&#x2F;storge&#x2F;vo</span><br><span class="line">lvdisplay</span><br></pre></td></tr></table></figure><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015105039050.png" alt="image-20201015105039050"></p><p>第2步：在逻辑卷所挂载的目录中创建一个100MB的垃圾文件，然后再查看快照卷的状态。可以发现存储空间占的用量上升了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd if&#x3D;&#x2F;dev&#x2F;zero  of&#x3D;linux&#x2F;files  count&#x3D;1  bs&#x3D;100M</span><br><span class="line">lvdisplay</span><br></pre></td></tr></table></figure><p>第3步：为了校验SNAP快照卷的效果，需要对逻辑卷进行快照还原操作。在此之前记得先卸载掉逻辑卷设备与目录的挂载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">umount &#x2F;data</span><br><span class="line"></span><br><span class="line">lvconvert  --merge &#x2F;dev&#x2F;storge&#x2F;SNAP</span><br></pre></td></tr></table></figure><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015105435927.png" alt="image-20201015105435927"></p><p>第4步：快照卷会被自动删除掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a</span><br></pre></td></tr></table></figure><h4 id="删除逻辑卷"><a href="#删除逻辑卷" class="headerlink" title="删除逻辑卷"></a>删除逻辑卷</h4><p>当生产环境中想要重新部署LVM或者不再需要使用LVM时，则需要执行LVM的删除操作。为此，需要提前备份好重要的数据信息，然后依次删除逻辑卷、卷组、物理卷设备，这个顺序不可颠倒。</p><p>第1步：取消逻辑卷与目录的挂载关联，删除配置文件中永久生效的设备参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount  &#x2F;data</span><br><span class="line">vim  &#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure><p>第2步：删除逻辑卷设备，需要输入y来确认操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lvremove  &#x2F;dev&#x2F;storge&#x2F;vo</span><br></pre></td></tr></table></figure><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015110242342.png" alt="image-20201015110242342"></p><p>第3步：删除卷组，此处只写卷组名称即可，不需要设备的绝对路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgremove storge</span><br></pre></td></tr></table></figure><p>第4步：删除物理卷设备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pvremove  &#x2F;dev&#x2F;sdb  &#x2F;dev&#x2F;sdc</span><br></pre></td></tr></table></figure><p><img src="/2020/10/14/Linux%E5%9F%BA%E7%A1%80/image-20201015110441450.png" alt="image-20201015110441450"></p><p>在上述操作执行完毕之后，再执行lvdisplay、vgdisplay、pvdisplay命令来查看LVM的信息时就不会再看到信息了。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="Linux系统安全" scheme="http://yoursite.com/categories/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Linux加固" scheme="http://yoursite.com/tags/Linux%E5%8A%A0%E5%9B%BA/"/>
    
  </entry>
  
  <entry>
    <title>Centos7.1基础命令集</title>
    <link href="http://yoursite.com/2020/10/14/Centos7-1%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E9%9B%86/"/>
    <id>http://yoursite.com/2020/10/14/Centos7-1基础命令集/</id>
    <published>2020-10-14T03:09:31.000Z</published>
    <updated>2020-10-14T08:57:42.008Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><p>查看系统版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -q centos-release或cat &#x2F;etc&#x2F;redhat-release或more &#x2F;etc&#x2F;*release</span><br></pre></td></tr></table></figure><p>查看内核版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;version或uname -a</span><br></pre></td></tr></table></figure><p>查看硬件CPU核数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class="line">或 cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure><p>查看运行模式-CPU运行在多少位模式下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getconf LONG_BIT</span><br></pre></td></tr></table></figure><p>查看系统运行时长/负载数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uptime</span><br></pre></td></tr></table></figure><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>查看内存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;meminfo  内存的详细信息</span><br></pre></td></tr></table></figure><p>查看各分区使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><p>查看指定目录大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh 目录名</span><br></pre></td></tr></table></figure><p>查看所有分区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>查看所有交换分区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>查看所有网络接口信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>网络服务[重启|停止|开始]：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl  restart&#x2F;stop&#x2F;start  network.service</span><br></pre></td></tr></table></figure><p>查看网卡带宽：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool 网卡名</span><br></pre></td></tr></table></figure><p>确定网卡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -p eno1  一直闪烁的口为网口eno1</span><br></pre></td></tr></table></figure><p>查看路由表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><p>查看所有监听端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lntp</span><br></pre></td></tr></table></figure><p>查看所有已经建立的连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat  -antp</span><br></pre></td></tr></table></figure><p>某端口的使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:端口号</span><br></pre></td></tr></table></figure><p>配置网卡信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-XXX</span><br><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">NAME&#x3D;&quot;eno1&quot;</span><br><span class="line">IPADDR&#x3D;192.168.5.x</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">GATEWAY&#x3D;192.168.5.1</span><br><span class="line">DEVICE&#x3D;&quot;eno1&quot;</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">NETBOOT&#x3D;yes</span><br><span class="line">UUID&#x3D;&quot;a904ac18-b95a-49ae-94e6-be8266fe6a6b&quot;</span><br></pre></td></tr></table></figure><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>时区调整：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-local-rtc 1   #将硬件时钟调整与本地时钟一致</span><br><span class="line">timedatectl set-timezone Asia&#x2F;Shanghai  #设置系统时区为上海</span><br></pre></td></tr></table></figure><p>时间调整：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s 2012-11-10 10:20:20</span><br></pre></td></tr></table></figure><p>设置RTC(硬件时钟)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --systohc  设置硬件时间，使硬件时钟与系统时间同步</span><br></pre></td></tr></table></figure><p>查看时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl</span><br></pre></td></tr></table></figure><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>查看所有进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef |grep tomcat[进程关键字]</span><br></pre></td></tr></table></figure><p>实时显示进程状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>查看活动用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w</span><br></pre></td></tr></table></figure><p>查看指定用户信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id &lt;用户名&gt;</span><br></pre></td></tr></table></figure><p>查看用户登录日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure><p>查看系统所有用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -d: -f1 &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>开启服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start 名称.service</span><br></pre></td></tr></table></figure><p>重启服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart 名称.service</span><br></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop 名称.service</span><br></pre></td></tr></table></figure><p>开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable 名称.service</span><br></pre></td></tr></table></figure><p>当前状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status 名称.service</span><br></pre></td></tr></table></figure><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>centos7的防火墙用的是firewalld,它是动态的，可通过命令添加开启端口。</p><p>启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>查看状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><p>禁用服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable  firewalld</span><br></pre></td></tr></table></figure><p>开启端口命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">永久开启80端口：firewall-cmd -zone&#x3D;public --add-port&#x3D;80&#x2F;tcp -permanent</span><br><span class="line">--add-port&#x3D;80&#x2F;tcp #添加端口，格式为：端口&#x2F;通讯协议</span><br><span class="line">-permanent #永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure><p>更新防火墙规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><p>关闭firwalld：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service #停止firewall</span><br><span class="line">systemctl disable firewalld.service #禁止firewall开机启动</span><br><span class="line">firewall-cmd --state #查看默认防火墙状态（关闭后显示not running，开启后显示running）</span><br></pre></td></tr></table></figure><p>编辑iptables：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vi&#x2F;etc&#x2F;sysconfig&#x2F;iptables #编辑防火墙配置文件</span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:FORWARD ACCEPT[0:0]</span><br><span class="line">:OUTPUT ACCEPT[0:0]</span><br><span class="line">-A INPUT -m state--state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -jACCEPT</span><br><span class="line">-A INPUT -i lo -jACCEPT</span><br><span class="line">-A INPUT -p tcp -mstate --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -jACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080-j ACCEPT</span><br><span class="line">-A INPUT -j REJECT--reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br><span class="line">:wq! #保存退出</span><br><span class="line"></span><br><span class="line">systemctl restart iptables.service #最后重启防火墙使配置生效</span><br><span class="line">systemctl enable iptables.service #设置防火墙开机启动</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="问题解决" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="日常踩坑" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>产品文档输出</title>
    <link href="http://yoursite.com/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/"/>
    <id>http://yoursite.com/2020/10/11/产品文档输出/</id>
    <published>2020-10-11T03:54:22.000Z</published>
    <updated>2020-10-11T07:57:30.903Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="产品产生的过程"><a href="#产品产生的过程" class="headerlink" title="产品产生的过程"></a>产品产生的过程</h2><p>一款产品从本质上来讲，一定是满足了用户的某种需求。</p><h4 id="想法酝酿与构建"><a href="#想法酝酿与构建" class="headerlink" title="想法酝酿与构建"></a>想法酝酿与构建</h4><p>此阶段主要是从用户所面临的问题出发，抓住问题的核心所在，开始萌生一个产品的想法，逐渐经过酝酿及逻辑构建，形成产品化解决该问题的思路，即建立通过一个产品解决所遇到问题的意图。</p><h4 id="分析与论证"><a href="#分析与论证" class="headerlink" title="分析与论证"></a>分析与论证</h4><p>此阶段主要是从用户所面临的问题出发，抓住问题的核心所在，开始萌生一个产品的想法，逐渐经过酝酿及逻辑构建，形成产品化解决该问题的思路，即建立通过一个产品解决所遇到问题的意图。</p><h4 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h4><p>此阶段是在上一阶段分析论证认为产品的初步想法可行的前提下，开始全面采集和筛选产品需求，并对需求进行分析，界定需求范围。</p><h4 id="总体规划"><a href="#总体规划" class="headerlink" title="总体规划"></a>总体规划</h4><p>此阶段主要是完成界定清楚前进的方向和目标，筹划给出实现目标的策略。</p><h4 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h4><p>在产品大方向和目标确定后，此阶段就是要具体设计产品的基本骨架和血肉，是产品由概念一步一步走向实体，形成一个可观察可体验的原型呈现在用户眼前。具体来讲，包括产品用例结构、功能架构、信息架构以及交互体验、界面效果等几个方面的设计。</p><h4 id="开发实现"><a href="#开发实现" class="headerlink" title="开发实现"></a>开发实现</h4><p>此阶段是按照已经形成的产品需求，利用程序代码将产品真正实现，即将产品由一个仿真的实体变成一个真正的实体。</p><h4 id="上线发布"><a href="#上线发布" class="headerlink" title="上线发布"></a>上线发布</h4><p>当产品开发完成后，经过测试验证与之前设计的原型一致，并且能够稳定运行不出错误后，产品就可以正式被部署到服务器上，在网上上线发布，供广大目标用户使用。</p><h4 id="基本流程框架"><a href="#基本流程框架" class="headerlink" title="基本流程框架"></a>基本流程框架</h4><p>可以总结出产品设计的基本过程框架：</p><p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011121528240.png" alt="image-20201011121528240"></p><h2 id="产品设计工具"><a href="#产品设计工具" class="headerlink" title="产品设计工具"></a>产品设计工具</h2><h4 id="思维构建工具"><a href="#思维构建工具" class="headerlink" title="思维构建工具"></a>思维构建工具</h4><p>随着思维导图思想及信息技术的发展，人们设计出了专门的思维导图软件工具，用于制作思维导图，这样的软件工具有很多，如XMind、 MindManger、iMindMap、百度脑图、亿图图示等，在这些工具中，前两个被使用得比较多。</p><h4 id="流程图工具"><a href="#流程图工具" class="headerlink" title="流程图工具"></a>流程图工具</h4><p>流程图是以特定图形符号来描述流程的，流程图的基本符号如下：</p><p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011154625143.png" alt="image-20201011154625143"></p><p>有很多软件工具可以用来绘制流程图，其绘制方式大同小异，只要按照思路从绘图工具栏中拖动出需要的符号进行组合即可。常见的绘制流程图工具有以下几种：</p><p>1、纸和笔</p><p>2、亿图图示</p><p>3、Visio</p><p>4、ProcessOn</p><p>ProcessOn是一个基于Web的免费画流程图的网站。它的特点是：免费、不用安装、可以多人同时登录画一张流程图。</p><h4 id="原型设计工具"><a href="#原型设计工具" class="headerlink" title="原型设计工具"></a>原型设计工具</h4><p>原型就是用线条、图形描绘出来的产品框架。通常用于产品经理与研发人员之间的沟通，有的情况下，在产品未研发出来的时候，也会用原型面向用户测试产品的可用性等。</p><p>在实际工作中，产品经理可以利用各种各样的工具便捷地绘制原型。下面介绍一些基本的绘制原型的工具及其使用方法：</p><p>1、纸和笔</p><p>2、Axure RP</p><p>Axure RP是一个专业的快速原型设计工具。Axure代表美国Axure公司；RP则是Rapid Prototyping（快速原型）的缩写。Axure RP也是目前产品设计人员使用的主流原型设计工具，它的操作简单、上手快，可以轻松快捷地以鼠标的方式快速创建网站或者移动端产品的原型图，不用进行编程就可以在图上定义简单链接和高级交互。除此之外，还可自动生成用于演示的网页文档和Word文档，以供演示或者供开发人员沟通理解需求。目前，Axure RP具有Windows和Mac两个版本。</p><p>3、Balsamiq Mockups</p><p>Balsamiq Mockups是一款轻量的、手绘风格的原型设计工具，通过它你可以创建朴素的原型图，非常适合用来绘制低保真原型图。Balsamiq Mockups的运行环境多样，它能够在不同浏览器上运行；也可以安装在Windows 7、Mac等不同操作系统平台下；可以在线使用，亦可以离线使用。</p><p>4、POP</p><p>POP（Prototyping on Paper）是由台湾Woomoo团队开发的一款移动App原型设计软件。只要用手机拍下手绘草稿，在POP里设计好链接区域，就能变成可互动的原型。这款软件可以快速将你的想法从纸上转移到屏幕上并进行再加工。</p><h4 id="项目管理工具"><a href="#项目管理工具" class="headerlink" title="项目管理工具"></a>项目管理工具</h4><p>1、甘特图</p><p>所有的项目管理工具中，甘特图是容易理解、容易使用并内容较全面的一种。甘特图基本上是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间计划和实际的活动完成情况，它以图示的方式形象地表示出项目的实施顺序、开始时间和持续时间等。使用者可以直观地看到项目的进展情况，了解活动在什么时候进行、还剩下哪些工作要做，以及实际进展与计划要求的对比情况。</p><p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011155325800.png" alt="image-20201011155325800"></p><p>2、Teambition</p><p>Teambition提供了一个像便利贴墙的任务板，使用者可以在上面发布并阅读任务。针对每一个任务，还可以分解子任务、搭载附件、设定截止日期。</p><p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011155426192.png" alt="image-20201011155426192"></p><p>3、禅道</p><p>禅道是我国开发的一款开源项目管理软件，分为开源版本和专业版本。它的主要管理思想基于国际流行的敏捷项目管理方法——Scrum。Scrum方法注重实效，操作性强，非常适合软件研发项目的快速迭代开发。</p><p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011155527213.png" alt="image-20201011155527213"></p><p>禅道明确地将产品、项目、测试三者概念区分开，产品人员、开发团队、测试人员，三者分立，互相配合，又互相制约，通过需求、任务、bug来进行交相互动，最终通过项目拿到合格的产品。</p><p>总体来讲，禅道集产品管理、项目管理、质量管理、文档管理、组织管理和事务管理于一体，是一款专业的研发项目管理软件，完整覆盖了研发项目管理的核心流程。也就是说，它是专门针对软件研发项目管理的专业工具。</p><p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011155703831.png" alt="image-20201011155703831"></p><h2 id="产品PRD文档"><a href="#产品PRD文档" class="headerlink" title="产品PRD文档"></a>产品PRD文档</h2><p>在完成分析功能角色、分析业务流程、梳理产品结构、绘制原型这些工作之后，一个定义清晰、功能逻辑结构明确、信息结构和体验效果具象的产品已经鲜活地浮现在眼前。接下来的工作就是集合前期所有的设计成果，按一定的方式把这些成果进行归集和说明，形成文档输出，以便于其他相关人员理解和把握产品，按规划设计开展进一步的产品开发与实现的工作。一般为了让产品其他关联人员明确理解产品需求，需要产品经理输出的文档有BRD（商业需求文档）、MRD（市场需求文档）和PRD（产品需求文档）。在实际工作中，BRD和MRD通常由更高级别的角色负责决断，比如直接由公司老板或者负责产品的高管具体判断和决策。对于一般产品经理而言，最主要的是负责输出PRD。</p><h2 id="什么是PRD文档"><a href="#什么是PRD文档" class="headerlink" title="什么是PRD文档"></a>什么是PRD文档</h2><p>PRD（product requirement document）是指产品需求文档，它以文档的形式定义、说明产品需求，让团队内成员明确产品需求，达成共识，从而面向一致的目标和方向推进后续的工作。几乎团队的所有成员都会使用到PRD：研发人员、测试人员、交互设计师、运营人员等。例如研发人员根据PRD获知整个产品的逻辑，进而搭建产品架构进行开发；测试人员可以根据PRD建立测试用例；交互设计则可以根据PRD来设计交互细节。总之，在产品项目正式进入开发阶段之前，PRD是必须通过评审确定的重要文档。</p><p>PRD文档的形式主要有：Word和原型两种类型。有的产品设计人员习惯撰写Word来写PRD，有的产品设计人员则直接用原型来制作。目前来说，使用Word形式的PRD还是主流。</p><h2 id="PRD文档组成"><a href="#PRD文档组成" class="headerlink" title="PRD文档组成"></a>PRD文档组成</h2><p>PRD文档通常包括以下几个部分：</p><h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p>文档信息包括文档版本号、文档编号、产品名、归属部门/项目、编写人和编写日期等信息，如表5-9所示。一般来说，版本的命名格式是：××产品××××需求PRD_V2。</p><p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011115912741.png" alt="image-20201011115912741"></p><h4 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h4><p>版本记录信息包括：版本号、修订人、修订日期、修订内容和修订原因，如下表。文档“版本号”显示的当前修改的内容属于文档的第几个版本，“修订说明”这一部分需说明具体修改了哪些内容，以及修改的原因，以便阅读人理解。</p><p><img src="/2020/10/11/%E4%BA%A7%E5%93%81%E6%96%87%E6%A1%A3%E8%BE%93%E5%87%BA/image-20201011120024165.png" alt="image-20201011120024165"></p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>主要是展示文档的范围和结构。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>这一部分是对整个PRD的概述，介绍文档的目的、文档的使用对象、名词说明和参考资料。有的文档中会出现一些新的名词，在这里应该解释一下这些名词，方便适用对象的阅读。</p><h4 id="产品概述"><a href="#产品概述" class="headerlink" title="产品概述"></a>产品概述</h4><p>这部分是要对产品进行一个总体的概要说明。具体包括：产品概述、用户说明、运行环境等。</p><p>1、产品目标：介绍产品的研发背景和目标；</p><p>2、用户说明：介绍产品的最终使用者，以及使用者的角色和操作行为；</p><p>3、产品功能：包括总体的业务流程图、产品的功能结构图以及对应的优先级；</p><p>4、运行环境：说明产品上线后的使用环境，例如操作系统要求、使用的浏览器类型及其版本要求等；</p><p>5、项目周期：这部分介绍产品需求、设计、开发、测试、上线等的相关周期；</p><p>6、产品风险：描述产品可能存在的风险内容、可能的原因、造成的危害，以及相应的应对策略。</p><h4 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h4><p><strong>产品的功能性需求是PRD的核心内容。</strong>功能性需求是指有具体的完成内容的需求，例如：客户登录、邮箱网站的收发邮件、论坛网站的发帖留言等。相对应的还有非功能性需求，这是指软件产品为满足用户业务需求而必须具有且除功能性需求以外的特性，例如：产品性能方面的需求（比如能承担20万人同时使用），或者运营等其他部门的需求。</p><p>撰写产品的系统功能性需求时可从以下几个方面考虑：</p><p>1、需求信息</p><p>需求信息包括需求名称以及需求的优先级，优先级可以直接按序号来表示。</p><p>2、需求说明</p><p>需求说明是对某一项需求功能进行描述，描述清楚功能的使用者、使用场景、使用动作与步骤、使用结果。</p><p>3、功能用例图</p><p>这里要用用例图来说明此功能的具体情况。</p><p>4、功能流程图</p><p>这里即是用流程图展示此功能的运行情况。</p><p>5、产品界面流程</p><p>这部分要呈现上述用例图和流程图所描述的功能的产品原型界面。除了静态的原型界面，在原型界面上还要附上各个部件的文字说明，以及页面的动作和跳转逻辑。</p><p>6、相关数据字段</p><p>数据字段是数据库中的概念。我们把数据表中的每一行叫作一个“记录”，而表中每一列的数据都是属于同一类的，这个数据类型就是数据字段。比如设计一款产品的注册登录功能，需要收集用户的账号、密码、手机号这些信息，那么用户的“账号”“密码”“手机号”就是你要确定的数据字段。这其实与前面梳理产品的信息结构是对应的，产品的信息结构中规定了什么信息，产品开发时就要设计相应的字段进行记录。</p><h4 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h4><p>一般情况下非功能性需求包括以下两类：</p><p>1、产品性能方面需求</p><p>包括产品性能需求、测试环境需求、产品数据统计需求、安全性需求、产品兼容性需求等。</p><p>产品性能需求是指用户承载量、产品响应速度等类似的需求。</p><p>测试环境的需求包括产品测试环境与正式上线环境的需求。</p><p>产品数据统计需求主要包括相关事件埋点的统计需求、接入第三方数据统计接口的需求。</p><p>安全性需求则是包括恶意注册防范需求、恶意刷数据防范需求等。</p><p>产品兼容性需求很好理解，主要表现为产品在客户端和Web端的各种需求，例如主流设备的尺寸。</p><p>2、其他业务/部门的要求</p><p>这包括产品营销需求、运营需求、财务需求、法务需求、使用帮助、问题反馈等。确定这些需求时需要与产品相关部门进行沟通。只有充分地沟通，才能让更多的人协助产品的正常使用与上线。一般撰写PRD不一定包含以上所有的非功能性需求，根据实际情况选择即可。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>在实际工作中，有的PRD在描述完非功能性需求以后就结束了，有的还需要增添一些其他内容。例如运营计划，需要在这里介绍产品上线后如何运营，目标受众是什么，建议的推广策略，问题反馈途径，亮点宣传，以及与运营人员的协作方式，等等。</p><p>PRD文档没有统一的模板，这取决于产品团队的习惯，每个团队、每个产品设计人员都可能撰写出不同风格的文档。只要能够表述清楚产品的需求，文档的阅读者能够达成对产品的一致理解，并获取所需的信息即可。也就是说，PRD的核心意义在于沟通产品需求，以便达成切实一致的理解，所以只要内容清楚，有利于达成这个核心目标即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="问题解决" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="日常踩坑" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>Python-数据图表设计</title>
    <link href="http://yoursite.com/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2020/10/10/Python-数据图表设计/</id>
    <published>2020-10-10T07:02:15.000Z</published>
    <updated>2020-10-11T08:11:15.607Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>数据图形的绘制所使用的工具是matplotlib绘图库模块，使用前需先安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure><p>matplotlib是一个庞大的绘图库模块，只导入其中的pyplot子模块就可以完成许多图表绘制,调用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure><h2 id="简单的折线图"><a href="#简单的折线图" class="headerlink" title="简单的折线图"></a>简单的折线图</h2><h4 id="show"><a href="#show" class="headerlink" title="show()"></a>show()</h4><p>show( )方法主要是显示所绘制的图形，当绘制图形完成后，可以调用此方法。</p><h4 id="画线plot"><a href="#画线plot" class="headerlink" title="画线plot()"></a>画线plot()</h4><p>应用方式是将含数据的列表当参数传给plot( )，列表内的数据会被视为y轴的值，x轴的值会依列表值的索引位置自动产生。</p><p>如绘制数据基本上是1-8的平方值的折线：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010151348979.png" alt="image-20201010151348979"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010151435846.png" alt="image-20201010151435846"></p><p>可以看到左下角的轴刻度不是(0,0)，可以使用axis( )设定x,y轴的最小和最大刻度。</p><p>将轴刻度x轴设为0,8，y轴刻度设为0,70。</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010151553847.png" alt="image-20201010151553847"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010151617747.png" alt="image-20201010151617747"></p><h4 id="线条宽度linewidth"><a href="#线条宽度linewidth" class="headerlink" title="线条宽度linewidth"></a>线条宽度linewidth</h4><p>使用plot( )时，可以多加一个linewidth(缩写是lw)参数设定线条的粗细。</p><p>如设定线条宽度为3：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010151721189.png" alt="image-20201010151721189"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010151748089.png" alt="image-20201010151748089"></p><h4 id="标题的显示"><a href="#标题的显示" class="headerlink" title="标题的显示"></a>标题的显示</h4><p>目前matplotlib模块不支持中文显示，下列是几个图表重要的方法。</p><p>title( )：图表标题。</p><p>xlabel( )：x轴标题。</p><p>ylabel( )：y轴标题。</p><p>上述方法可以显示默认大小是12的字体，它的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title(标题名称，fontsize&#x3D;数值大小)  #同时可用在xlabel()和ylabel()</span><br></pre></td></tr></table></figure><p>使用默认字号为图表与x/y轴建立标题:</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010152051237.png" alt="image-20201010152051237"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010152116192.png" alt="image-20201010152116192"></p><h4 id="坐标轴刻度"><a href="#坐标轴刻度" class="headerlink" title="坐标轴刻度"></a>坐标轴刻度</h4><p>在设计图表时可以使用tick_params( )设计设定坐标轴的刻度大小、颜色以及应用范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tick_params(axis&#x3D;&#39;xx&#39;,labelsize&#x3D;xx,color&#x3D;&#39;xx&#39; )  #labelsize&#x3D;xx代表刻度大小</span><br></pre></td></tr></table></figure><p>如果axis的xx是both代表应用到x和y轴，如果xx是x代表应用到x轴，如果xx是y代表应用到y轴。color则是设定刻度的线条颜色，例如，red代表红色。</p><p>使用不同刻度与颜色：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010152728802.png" alt="image-20201010152728802"></p><h4 id="多组数据的应用"><a href="#多组数据的应用" class="headerlink" title="多组数据的应用"></a>多组数据的应用</h4><p>扩充多组数据，只要在plot( )内增加数据列表参数即可。此时plot( )的参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot(第一组数据，第二组数据.....)</span><br></pre></td></tr></table></figure><p>如设计多组数据图的应用：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010153402762.png" alt="image-20201010153402762"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010153452276.png" alt="image-20201010153452276"></p><h4 id="线条色彩与样式"><a href="#线条色彩与样式" class="headerlink" title="线条色彩与样式"></a>线条色彩与样式</h4><p>如果想设定线条色彩，可以在plot( )内增加下列参数设定，下列是常见的色彩表。</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010153652539.png" alt="image-20201010153652539"></p><p>下列是常见的样式表。可以混合使用，例如，‘r-.’代表红色虚点线。</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010153733132.png" alt="image-20201010153733132"></p><p>如采用不同色彩与线条样式绘制图表：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010153820459.png" alt="image-20201010153820459"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010153841916.png" alt="image-20201010153841916"></p><h4 id="刻度设计"><a href="#刻度设计" class="headerlink" title="刻度设计"></a>刻度设计</h4><p>目前所有绘制图表x轴和y轴的刻度皆是plot( )方法针对所输入的参数采用默认值设定。</p><p>可以使用pyplot模块的xticks( )/yticks( )分别设定x/y轴刻度。</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010154005309.png" alt="image-20201010154005309"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010154038326.png" alt="image-20201010154038326"></p><h4 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h4><p>图表设计完成，可以使用savefig( )保存图片文件，这个方法需放在show( )的前方，表示先存储再显示图表。</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010154530375.png" alt="image-20201010154530375"></p><h2 id="绘制散点图scatter"><a href="#绘制散点图scatter" class="headerlink" title="绘制散点图scatter( )"></a>绘制散点图scatter( )</h2><h4 id="散点图的绘制"><a href="#散点图的绘制" class="headerlink" title="散点图的绘制"></a>散点图的绘制</h4><p>绘制散点图可以使用scatter( )，最基本语法应用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scatter(x,y,s,c)</span><br></pre></td></tr></table></figure><p>(x,y)位置绘图，其中(0,0)位置在左下角，x轴刻度往右增加，y轴刻度往上增加。s是绘图点的大小，默认是20。c是颜色，默认是蓝色。</p><p>如在坐标轴(5,5)绘制一个点：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010155028889.png" alt="image-20201010155028889"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010155054982.png" alt="image-20201010155054982"></p><h4 id="绘制系列点"><a href="#绘制系列点" class="headerlink" title="绘制系列点"></a>绘制系列点</h4><p>绘制系列点，可以将系列点的x轴值放在一个列表，y轴值放在另一个列表，然后将这2个列表当参数放在scatter( )即可。</p><p>如绘制系列点的应用：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010155206923.png" alt="image-20201010155206923"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010155231822.png" alt="image-20201010155231822"></p><h4 id="设定绘图区间"><a href="#设定绘图区间" class="headerlink" title="设定绘图区间"></a>设定绘图区间</h4><p>可以使用axis( )设定绘图区间，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axis([xmin,xmax,ymin,ymax])  #分别代表x和y轴的最大最小区间</span><br></pre></td></tr></table></figure><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010155540194.png" alt="image-20201010155540194"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010155603393.png" alt="image-20201010155603393"></p><h2 id="Numpy模块"><a href="#Numpy模块" class="headerlink" title="Numpy模块"></a>Numpy模块</h2><p>Numpy是Python的一个扩充模块，主要是可以支持多维度空间的数组与矩阵运算。导入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Numpy as np</span><br></pre></td></tr></table></figure><h4 id="简单的数组linspace-和arange"><a href="#简单的数组linspace-和arange" class="headerlink" title="简单的数组linspace( )和arange( )"></a>简单的数组linspace( )和arange( )</h4><p>在Numpy模块中最基本的就是linspace( )方法，使用它可以很方便产生相同等距的数组，它的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linspace(start,end,num)</span><br></pre></td></tr></table></figure><p>start是起始值，end是结束值，num是设定产生多少个等距的数组值，num的默认值是50。</p><p>另一个常看到产生数组的方法是arange( )，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arange(start,stop,step)</span><br></pre></td></tr></table></figure><p>start是起始值如果省略默认值是0，stop是结束值但是所产生的数组通常不包含此值，step是数组相邻元素的间距如果省略默认值是1。</p><p>如建立0, 1, …, 9, 10的数组：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010160154049.png" alt="image-20201010160154049"></p><h4 id="绘制波形"><a href="#绘制波形" class="headerlink" title="绘制波形"></a>绘制波形</h4><p>有了数组数据，可以很方便绘制sin和cos的波形变化。</p><p>绘制sin( )和cos( )的波形：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010160338653.png" alt="image-20201010160338653"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010160405398.png" alt="image-20201010160405398"></p><h4 id="建立不等宽度的散点图"><a href="#建立不等宽度的散点图" class="headerlink" title="建立不等宽度的散点图"></a>建立不等宽度的散点图</h4><p>在scatter( )方法中，(x,y)的数据可以是列表也可以是矩阵，预设所绘制点大小s的值是20，这个s可以是一个值也可以是一个数组数据，当它是一个数组数据时，利用更改数组值的大小，就可以建立不同大小的散点图。</p><p>使用Python绘制散点图时，如果将2个点之间绘了上百或上千个点，则可以产生绘制线条的视觉，如果再加上每个点的大小不同，且依一定规律变化，则可以有特别效果。</p><p>如建立一个不等宽度的图形：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010160727201.png" alt="image-20201010160727201"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010160751723.png" alt="image-20201010160751723"></p><h4 id="色彩映射color-mapping"><a href="#色彩映射color-mapping" class="headerlink" title="色彩映射color mapping"></a>色彩映射color mapping</h4><p>在色彩的使用中是允许色彩也是数组（或列表）随着数据而变化，此时色彩的变化是根据所设定的色彩映射值(color mapping)而定，例如有一个色彩映射值是rainbow，内容如下：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010160857840.png" alt="image-20201010160857840"></p><p>在数组（或列表）中，数值低的值颜色在左边，会随着数值变高颜色往右边移动。需在scatter( )中增加color(也可用c)设定，这时color的值就变成一个数组（或列表）。然后需增加参数cmap（英文是color map），这个参数主要是指定使用哪一种色彩映射值。</p><p>如色彩映射的应用：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010161040674.png" alt="image-20201010161040674"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010161130550.png" alt="image-20201010161130550"></p><h4 id="色彩映射表"><a href="#色彩映射表" class="headerlink" title="色彩映射表"></a>色彩映射表</h4><p>目前matplotlib协会所提供的色彩映射内容如下：</p><p>序列色彩映射表</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010161358480.png" alt="image-20201010161358480"></p><p>序列2色彩映射表</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201010161435589.png" alt="image-20201010161435589"></p><p>直觉一致的色彩映射表</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160104828.png" alt="image-20201011160104828"></p><p>发散式的色彩映射表</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160145604.png" alt="image-20201011160145604"></p><p>定性色彩映射表</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160213279.png" alt="image-20201011160213279"></p><p>杂项色彩映射表</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160241512.png" alt="image-20201011160241512"></p><h2 id="随机数的应用"><a href="#随机数的应用" class="headerlink" title="随机数的应用"></a>随机数的应用</h2><p>随机数在统计的应用中是非常重要的知识，用到的随机数方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.random(N)   #传回N个0.0至1.0之间的数字</span><br></pre></td></tr></table></figure><p>如产生100个0.0至1.0之间的随机数，使用brg色彩映射表绘出这个图表。</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160536580.png" alt="image-20201011160536580"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160601595.png" alt="image-20201011160601595"></p><h4 id="随机数的移动"><a href="#随机数的移动" class="headerlink" title="随机数的移动"></a>随机数的移动</h4><p>可以针对随机数的特性，让每个点随着随机数的变化产生有序列的随机移动，经过大量值的运算后，每次均可产生不同但有趣的图形。</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160855186.png" alt="image-20201011160855186"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011160919789.png" alt="image-20201011160919789"></p><h4 id="隐藏坐标"><a href="#隐藏坐标" class="headerlink" title="隐藏坐标"></a>隐藏坐标</h4><p>可以使用axes( ).get_xaxis( )、axes( ).get_yaxis( )、set_visible( )方法隐藏坐标。</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011161028473.png" alt="image-20201011161028473"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1/image-20201011161053578.png" alt="image-20201011161053578"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-网络爬虫</title>
    <link href="http://yoursite.com/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2020/10/10/Python-网络爬虫/</id>
    <published>2020-10-10T05:07:42.000Z</published>
    <updated>2020-10-10T06:55:02.138Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="浏览网页"><a href="#浏览网页" class="headerlink" title="浏览网页"></a>浏览网页</h2><p>Python有提供webbrowser模块，可以调用这个模块的open( )方法，就可以打开指定的网页了。在使用前需导入此模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import webbrowser</span><br></pre></td></tr></table></figure><p>如打开百度：</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010131307765.png" alt="image-20201010131307765"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010131401320.png" alt="image-20201010131401320"></p><h2 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h2><p>requests是第三方模块，安装模块指令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><h4 id="下载网页"><a href="#下载网页" class="headerlink" title="下载网页"></a>下载网页</h4><p>requests.get( )方法内需放置欲下载网页信息的网址当参数，这个方法可以传回网页的HTML源文件。</p><p>使用requests.get( )之后传回的数据类型是Response对象。</p><h4 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h4><p>Response对象内有下列几个重要属性：</p><p>status_code：如果值是requests.codes.ok，表示获得的网页内容成功。</p><p>text：网页内容。</p><p>如打印网页原始内容：</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010131817536.png" alt="image-20201010131817536"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010131839717.png" alt="image-20201010131839717"></p><h4 id="搜索网页特定内容"><a href="#搜索网页特定内容" class="headerlink" title="搜索网页特定内容"></a>搜索网页特定内容</h4><p>网页内容下载后，如果我们想要搜寻特定字符串，可以使用许多方法。</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010131958962.png" alt="image-20201010131958962"></p><h4 id="网页服务器阻挡造成读取错误"><a href="#网页服务器阻挡造成读取错误" class="headerlink" title="网页服务器阻挡造成读取错误"></a>网页服务器阻挡造成读取错误</h4><p>有些网页也许基于安全原因，或是不想让太多网络爬虫造访造成网络流量增加，因此会设计程序阻挡网络爬虫提取信息，碰上这类问题就会产生406的错误，如下所示：</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010132122203.png" alt="image-20201010132122203"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010132144213.png" alt="image-20201010132144213"></p><p>406错误就是网页服务器阻挡。</p><h4 id="爬虫伪装成浏览器"><a href="#爬虫伪装成浏览器" class="headerlink" title="爬虫伪装成浏览器"></a>爬虫伪装成浏览器</h4><p>为了解决爬虫程序被服务器阻挡的困扰，我们可以将所设计的爬虫程序伪装成浏览器，方法是在程序前端加上headers内容。</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010132308670.png" alt="image-20201010132308670"></p><h4 id="存储下载的网页"><a href="#存储下载的网页" class="headerlink" title="存储下载的网页"></a>存储下载的网页</h4><p>使用requests.get( )获得网页内容时，是存储在Response对象类型内，如果要将这类型的对象存入硬盘内，需使用Response对象的iter_content( )方法，这个方法是采用重复迭代方式将Response对象内容写入指定的文件内，每次写入指定扇区大小是以Bytes为单位，一般可以设定1024×5或1024×10或更多。</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010132437922.png" alt="image-20201010132437922"></p><h2 id="查看网页原始文件"><a href="#查看网页原始文件" class="headerlink" title="查看网页原始文件"></a>查看网页原始文件</h2><p>检视网页的原始文件目的，主要是掌握几个关键重点，然后提取我们想要的数据。</p><p>如果使用的是Chrome浏览器，将鼠标光标放在网页上单击鼠标右键，打开快捷菜单，再执行View page source指令，也可以打开新窗口显示此网页的HTML原始文件。</p><h2 id="BeautifulSoup模块"><a href="#BeautifulSoup模块" class="headerlink" title="BeautifulSoup模块"></a>BeautifulSoup模块</h2><p>使用BeautifulSoup模块解析HTML文件，目前这个模块是第4版，模块名称是beautifulsoup4。安装模块指令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure><p>导入模块时，可以使用指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import bs4</span><br></pre></td></tr></table></figure><h4 id="建立beautifulsoup对象"><a href="#建立beautifulsoup对象" class="headerlink" title="建立beautifulsoup对象"></a>建立beautifulsoup对象</h4><p>建立BeautifulSoup对象的语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">htmlfile &#x3D; request.get(&#39;www.baidu.com&#39;)  #下载网页内容</span><br><span class="line"></span><br><span class="line">obj &#x3D; bs4.BeautifulSoup(htmlfile.text,&#39;lxml&#39;) #lxml是解析HTML文件的方式</span><br></pre></td></tr></table></figure><p>当网页下载后，将网页内容的Response对象传给bs4.BeautifulSoup( )方法，就可以建立BeautifulSoup对象。至于另一个参数“lxml”目的是注明解析HTML文件的方法，常用的有下列方法：</p><p>‘html.parser’：这是老旧的方法(3.2.3版本前)，兼容性比较不好。</p><p>‘lxml’：速度快，兼容性佳。</p><p>html5lib’：速度比较慢，但是解析能力强，需另外安装html5lib（pip install html5lib）。</p><h4 id="页标题title属性"><a href="#页标题title属性" class="headerlink" title="页标题title属性"></a>页标题title属性</h4><p>BeautifulSoup对象的title属性可以传回页标题的title标签内容。</p><p>如使用title属性解析myhtml.html文件的页标题：</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010133703575.png" alt="image-20201010133703575"></p><h4 id="传回文字text属性"><a href="#传回文字text属性" class="headerlink" title="传回文字text属性"></a>传回文字text属性</h4><p>可以使用text属性获得卷标的内容。</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010133921608.png" alt="image-20201010133921608"></p><h4 id="传回第一个符合的标签find"><a href="#传回第一个符合的标签find" class="headerlink" title="传回第一个符合的标签find()"></a>传回第一个符合的标签find()</h4><p>这个函数可以找寻HTML文件内第一个符合的标签内容，例如，find(‘h1’)是要找第一个h1的标签。如果找到了就传回该卷标字符串，可以使用text属性获得内容，如果没找到就传回None。</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010134345317.png" alt="image-20201010134345317"></p><h4 id="传回所有符合的标签find-all"><a href="#传回所有符合的标签find-all" class="headerlink" title="传回所有符合的标签find all()"></a>传回所有符合的标签find all()</h4><p>这个函数可以找寻HTML文件内所有符合的标签内容，例如，find_all(‘h1’)是要找所有h1的标签。如果找到了就传回该标签列表，如果没找到就传回空列表。</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010134500430.png" alt="image-20201010134500430"></p><h4 id="HTML元素上下文属性与getText"><a href="#HTML元素上下文属性与getText" class="headerlink" title="HTML元素上下文属性与getText( )"></a>HTML元素上下文属性与getText( )</h4><p>HTML元素内容的属性有下列3种：</p><p>textContent：内容，不含任何标签码。</p><p>innerHTML：元素内容，含子卷标码，但是不含本身标签码。</p><p>outerHTML：元素内容，含子卷标码，也含本身标签码。</p><p>如果有一个元素内容如下：</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010134812644.png" alt="image-20201010134812644"></p><p>则3个属性的内容分别如下：</p><p><img src="/2020/10/10/Python-%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/image-20201010135004153.png" alt="image-20201010135004153"></p><p>使用BeautifulSoup模块解析HTML文件时，如果传回的是列表，也可以配合索引应用getText( )取得列表元素内容，所取得的内容是textContent。</p><h4 id="select"><a href="#select" class="headerlink" title="select( )"></a>select( )</h4><p>select( )主要是以CSS选择器(selector)的观念寻找元素，如果找到，回传的是列表(list)，如果找不到则传回空列表。</p><p>使用示例如下：</p><p>objSoup.select(‘p’)：找寻所有&lt;</p><p>&gt;卷标的元素。</p><p>objSoup.select (‘img’)：找寻所有&lt;<img>&gt;卷标的元素。</p><p>objSoup.select (‘.happy’)：找寻所有CSS class属性为happy的元素。</p><p>objSoup.select (‘#author’)：找寻所有CSS id属性为author的元素。</p><p>objSoup.select (‘p #author’)：找寻所有</p><p>且id属性为author的元素。</p><p>objSoup.select (‘p .happy’)：找寻所有</p><p>且class属性为happy的元素。</p><p>objSoup.select (‘div strong’)：找寻所有在<section>元素内的<strong>元素。</strong></section></p><p>objSoup.select (‘input[name]’)：找寻所有<input>卷标且有name属性的元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-处理excel文件</title>
    <link href="http://yoursite.com/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/10/10/Python-处理excel文件/</id>
    <published>2020-10-10T03:03:04.000Z</published>
    <updated>2020-10-10T04:53:50.409Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>Excel是电子表格软件，主要是做数据的统计与分析。有时候我们可能会需要从数百或更多电子表格中依条件复制一些数据到其他表格，或是从数百或更多数据表中搜寻符合特定条件的数据等，这些皆是符合使用Python处理的条件。</p><p>需要使用外部模块openpyxl,安装指令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure><p>导入模块指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import openpyxl</span><br></pre></td></tr></table></figure><h2 id="EXCEL窗口"><a href="#EXCEL窗口" class="headerlink" title="EXCEL窗口"></a>EXCEL窗口</h2><p>Microsoft Excel窗口如下：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010110629013.png" alt="image-20201010110629013"></p><p>Microsoft Excel文件的扩展名是xlsx，下列是一些基本名词。</p><p>1、工作簿(workbook)：Excel的文件又称工作簿。</p><p>2、工作表(worksheet)：一个工作簿由不同数量的工作表组成。</p><p>3、栏(column)：工作表的栏名称是A、B、……</p><p>4、行(row)：工作表的行名称是1、2、……</p><p>5、单元格(cell)：工作表内的每一个格子称单元格，用(栏名, 行名)代表。</p><h2 id="读取EXCEL文件"><a href="#读取EXCEL文件" class="headerlink" title="读取EXCEL文件"></a>读取EXCEL文件</h2><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>导入openpyxl模块后，可以使用openpyxl.load_workbook( )方法打开Excel文件，然后可以回传Excel文件对象。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010111007456.png" alt="image-20201010111007456"></p><h4 id="取得工作表worksheet名称"><a href="#取得工作表worksheet名称" class="headerlink" title="取得工作表worksheet名称"></a>取得工作表worksheet名称</h4><p>可以使用get_sheet_names( )取得所打开工作簿文件的所有工作表，工作表将以列表数据类型回传。get_active_sheet( )可以取得当前工作表的名称，这里所指的当前工作表是打开文件后自动显示的工作表名称。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010111132003.png" alt="image-20201010111132003"></p><h4 id="设定当前工作的工作表"><a href="#设定当前工作的工作表" class="headerlink" title="设定当前工作的工作表"></a>设定当前工作的工作表</h4><p>使用Python操作Excel文件时，可能需随时更改当前工作表，可以使用get_sheet_by_name( )，然后将要设为当前工作表的名称当做这个方法的参数。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010111430749.png" alt="image-20201010111430749"></p><h4 id="取得工作表的内容"><a href="#取得工作表的内容" class="headerlink" title="取得工作表的内容"></a>取得工作表的内容</h4><p>有了当前工作表对象ws，可以用下列方式取得单元格内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws[&#39;栏行&#39;].value   #栏是A、B，行是1、2</span><br></pre></td></tr></table></figure><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010111645958.png" alt="image-20201010111645958"></p><p>除了可以使用value属性取得单元格内容外，也可以使用row、column或coordinate取得单元格相对位置信息。</p><h4 id="取得工作表内容的栏数和行数"><a href="#取得工作表内容的栏数和行数" class="headerlink" title="取得工作表内容的栏数和行数"></a>取得工作表内容的栏数和行数</h4><p>对于当前工作表对象而言，max_column和max_row可以分别传回工作表内容的栏数和行数。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010111822823.png" alt="image-20201010111822823"></p><h4 id="取得单元格的内容"><a href="#取得单元格的内容" class="headerlink" title="取得单元格的内容"></a>取得单元格的内容</h4><p>使用“ws[‘栏列’].value”取得单元格内容，也可以使用cell( )方法取得单元格内容，此时其语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.cell(column&#x3D;N,row&#x3D;M)  #N是栏编号，M是行编号</span><br></pre></td></tr></table></figure><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010112107454.png" alt="image-20201010112107454"></p><h4 id="工作表对象的rows和columns"><a href="#工作表对象的rows和columns" class="headerlink" title="工作表对象的rows和columns"></a>工作表对象的rows和columns</h4><p>当建立工作表对象ws成功后，会自动产生下列数据产生器(generators)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ws.rows:数据产生器以行的方式包裹</span><br><span class="line">ws.columns:数据产生器以栏的方式包裹</span><br></pre></td></tr></table></figure><p>由于ws.rows和ws.columns是数据产生器，若是想取得它的内容须先将它们转成列表(list)，然后就可以用索引方式取得。列出特定行与栏的信息。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010113605914.png" alt="image-20201010113605914"></p><p>对于数据产生器而言，我们可以使用逐行方式获得全部的工作表内容。</p><p>如使用逐行方式获取工作表全部内容：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010113728116.png" alt="image-20201010113728116"></p><p>使用逐栏方式获得全部的工作表内容：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010113905254.png" alt="image-20201010113905254"></p><h4 id="用整数取代域名"><a href="#用整数取代域名" class="headerlink" title="用整数取代域名"></a>用整数取代域名</h4><p>在Excel中栏名称是A、B、…、Z、AA、AB、AC、……例如，1代表A、2代表B、26代表Z、27代表AA、28代表AB。如果工作表的栏数很多，无法清楚了解到底索引是多少，转化方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get_column_letter(数值)   #将数值转化为字母</span><br><span class="line">column_index_from_string(字母)  #将字母转化为数值</span><br></pre></td></tr></table></figure><p>方法存在于openpyxl.utils模块内，程序前面要加上下列指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from openpyxl.utils import get_column_letter,column_index_from_string</span><br></pre></td></tr></table></figure><p>如将字段的字母转成数值与将数值转成字母：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010114530962.png" alt="image-20201010114530962"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010114607986.png" alt="image-20201010114607986"></p><h4 id="切片读取"><a href="#切片读取" class="headerlink" title="切片读取"></a>切片读取</h4><p>使用切片的观念读取某区间数据，例如，读取A3:E6数据可用下列方法：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010114705059.png" alt="image-20201010114705059"></p><h2 id="写入EXCEL文件"><a href="#写入EXCEL文件" class="headerlink" title="写入EXCEL文件"></a>写入EXCEL文件</h2><h4 id="建立EXCEL文件"><a href="#建立EXCEL文件" class="headerlink" title="建立EXCEL文件"></a>建立EXCEL文件</h4><p>openpyxl.Workbook( )可以建立空白的工作簿，默认所建立的文件是可擦写，如果想要设为只写模式，可以加上write_only=True参数。</p><h4 id="存储EXCEL文件"><a href="#存储EXCEL文件" class="headerlink" title="存储EXCEL文件"></a>存储EXCEL文件</h4><p>save( )方法可以存储Excel文件，这个方法需由Excel文件对象启动，先前我们是使用wb(workbook)当作文件对象的变量，使用语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.save(文件名)</span><br></pre></td></tr></table></figure><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010120423938.png" alt="image-20201010120423938"></p><h4 id="复制excel文件"><a href="#复制excel文件" class="headerlink" title="复制excel文件"></a>复制excel文件</h4><p>可以打开文件，然后新名称存储文件方式达到复制Excel文件的效果。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010120853984.png" alt="image-20201010120853984"></p><h4 id="建立工作表"><a href="#建立工作表" class="headerlink" title="建立工作表"></a>建立工作表</h4><p>create_sheet( )可以在工作簿内建立新的工作表。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010121838590.png" alt="image-20201010121838590"></p><h4 id="删除工作表"><a href="#删除工作表" class="headerlink" title="删除工作表"></a>删除工作表</h4><p>删除工作表可以使用remove_sheet( )方法，在使用时并不是直接将工作表名称当参数，必须使用工作簿对象wb调用get_sheet_by_name( )当作参数。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010122006529.png" alt="image-20201010122006529"></p><h4 id="写入单元格"><a href="#写入单元格" class="headerlink" title="写入单元格"></a>写入单元格</h4><p>如果想要写入资料，只要设定该单元格的值即可。</p><p>如将资料写入单元格：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010122307377.png" alt="image-20201010122307377"></p><h4 id="将列表数据写入单元格"><a href="#将列表数据写入单元格" class="headerlink" title="将列表数据写入单元格"></a>将列表数据写入单元格</h4><p>可以使用append( )方法将列表资料写入单元格，append这个名词有附加的意义，如果当前工作表没有资料，append( )可将数据从第一行(row)开始写入，如果当前工作表已经有数据，可将数据从已有数据的下一行开始写入。</p><p>如在空白工作表使用append( )输入列表数据：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010122542596.png" alt="image-20201010122542596"></p><h2 id="设定单元格的字体"><a href="#设定单元格的字体" class="headerlink" title="设定单元格的字体"></a>设定单元格的字体</h2><h4 id="font"><a href="#font" class="headerlink" title="font()"></a>font()</h4><p>Font对象主要功能是执行字体相关的设定，可以使用Font( )方法设定此对象，有了Font对象后就可以将它应用在单元格。这个方法常见的参数如下：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010122701729.png" alt="image-20201010122701729"></p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010122755848.png" alt="image-20201010122755848"></p><h4 id="字体色彩的设定"><a href="#字体色彩的设定" class="headerlink" title="字体色彩的设定"></a>字体色彩的设定</h4><p>所有颜色可以使用3个原色red(红色)、green(绿色)和blue(蓝色)，每个颜色数值在0—255间组成。Font( )方法内的参数color的值“FFFFFF”，分别代表Red、Green和Blue，下列是常见的256种颜色组合。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123010251.png" alt="image-20201010123010251"></p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123052984.png" alt="image-20201010123052984"></p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123119468.png" alt="image-20201010123119468"></p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123144636.png" alt="image-20201010123144636"></p><h2 id="数学公式的使用"><a href="#数学公式的使用" class="headerlink" title="数学公式的使用"></a>数学公式的使用</h2><p>常见的数学公式如下：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123337671.png" alt="image-20201010123337671"></p><p>如计算B1:B3单元格区间的加总、平均、最高分、最低分。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123518713.png" alt="image-20201010123518713"></p><h2 id="设定单元格高度宽度"><a href="#设定单元格高度宽度" class="headerlink" title="设定单元格高度宽度"></a>设定单元格高度宽度</h2><p>单元格预设的高度是12.75pt，72pt等于1英寸。可以使用column_dimensions属性设定行高。单元格默认的宽度是8.43个英文字符宽度，可以使用row_dimensions设定单元格的宽度。如果将高度或宽度设为0，则具有隐藏单元格效果。</p><p>如设定第一行(row)高度和第B栏(column)宽度：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010123642323.png" alt="image-20201010123642323"></p><h2 id="单元格对齐方式"><a href="#单元格对齐方式" class="headerlink" title="单元格对齐方式"></a>单元格对齐方式</h2><p>可以使用Alignment( )方法，须在程序前方导入下列模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from openpyxl.styles import Alignment</span><br></pre></td></tr></table></figure><p>Alignment( )方法内可以有下列2个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">horizontal：可以设定left(靠左)、center(居中)、right(靠右)对齐。</span><br><span class="line"></span><br><span class="line">vertical：可以设定top(靠上)、center(居中)、bottom(靠下)对齐。</span><br></pre></td></tr></table></figure><p>整个单元格设定的完整公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws[&#39;A1&#39;].alignment &#x3D; Alignment()</span><br></pre></td></tr></table></figure><h2 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h2><h4 id="合并单元格-1"><a href="#合并单元格-1" class="headerlink" title="合并单元格"></a>合并单元格</h4><p>可以使用merge_cells( )合并单元格，可以合并同一行(row)、同一栏(column)或一个区间的单元格。</p><h4 id="取消合并单元格"><a href="#取消合并单元格" class="headerlink" title="取消合并单元格"></a>取消合并单元格</h4><p>可以使用unmerge_cells( )取消合并单元格。</p><h2 id="建立图表"><a href="#建立图表" class="headerlink" title="建立图表"></a>建立图表</h2><p>Python可以建立的图表有许多，所有Excel可以建立的图表皆可使用Python建立，为了建立图表可以更方便地导入图表模块，程序需导入下列图表方法。BarChart(柱形图)、BarChart3D(3D柱形图)、PieChart(饼图)、PieChart3D(3D饼图)、BubbleChart(泡泡图)、AreaChart(分区图)、AreaChart3D(3D分区图)、LineChart(线段图)、LineChart3D(3D线段图)、RadarChart(雷达图)、StockChart(股票图)。上述英文名称就是建立图表的方法，导入方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from openpyxl.chart import BarChart,Reference #以导入BarChart为例</span><br></pre></td></tr></table></figure><p>另外需导入Reference方法，这个方法主要是供我们将建立图表所需的工作表数据或是卷标名称(有时也可称轴的卷标)数据导入所建的图表对象内。</p><h4 id="柱形图"><a href="#柱形图" class="headerlink" title="柱形图"></a>柱形图</h4><p>最常见的图表应用，主要是显示多组数据于一段时间的变化，从此类型也可以了解各组资料间比较的情形，应用时通常数值数据是在纵轴(y轴)，而标记是在横轴(x轴)。</p><p>如建立深石软件2020—2021年销售报表。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010124641750.png" alt="image-20201010124641750"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010124706829.png" alt="image-20201010124706829"></p><h4 id="3D柱形图"><a href="#3D柱形图" class="headerlink" title="3D柱形图"></a>3D柱形图</h4><p>要建立3D柱形图表，只要导入BarChart3D。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010124945532.png" alt="image-20201010124945532"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010125008131.png" alt="image-20201010125008131"></p><h4 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h4><p>饼图(PieChart)只适合一个数据系列，主要是供了解单笔数据相对于整体数据的关系比。</p><p>如将员工旅游意向调查表处理成饼图：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010125118771.png" alt="image-20201010125118771"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010125146949.png" alt="image-20201010125146949"></p><h4 id="3D饼图"><a href="#3D饼图" class="headerlink" title="3D饼图"></a>3D饼图</h4><p>要建立3D饼图表就很简单，只要导入PieChart3D。</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010125237535.png" alt="image-20201010125237535"></p><p>执行结果：</p><p><img src="/2020/10/10/Python-%E5%A4%84%E7%90%86excel%E6%96%87%E4%BB%B6/image-20201010125300188.png" alt="image-20201010125300188"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-处理PDF文件</title>
    <link href="http://yoursite.com/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/10/09/Python-处理PDF文件/</id>
    <published>2020-10-09T08:58:37.000Z</published>
    <updated>2020-10-10T02:58:33.403Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>需要使用外部模块PyPDF2，安装此模块时指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install PyPDF2</span><br></pre></td></tr></table></figure><p>导入模块指令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import PyPDF2</span><br></pre></td></tr></table></figure><h2 id="打开PDF文件"><a href="#打开PDF文件" class="headerlink" title="打开PDF文件"></a>打开PDF文件</h2><p>使用open( )打开PDF文件，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mypdf &#x3D; open(&#39;pdf_file&#39;,&#39;rb&#39;)  #rb代表以二进制打开</span><br></pre></td></tr></table></figure><p>pdf_file是要打开的文件，打开成功后会传回所打开PDF文件的文件对象。</p><h2 id="获得PDF文件的页数"><a href="#获得PDF文件的页数" class="headerlink" title="获得PDF文件的页数"></a>获得PDF文件的页数</h2><p>打开PDF文件成功后，可以使用PdfFileReader( )方法读取这个PDF文件，语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdfrd &#x3D; PyPDF2.PdfFileReader(mypdf)  读取PDF内容</span><br></pre></td></tr></table></figure><p>将所读取的内容放在pdfRd对象变量内，这个对象变量内含numPages属性记录此PDF文件的页数。</p><p>如计算travel.pdf的页数：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201009170922330.png" alt="image-20201009170922330"></p><h2 id="读取PDF页面内容"><a href="#读取PDF页面内容" class="headerlink" title="读取PDF页面内容"></a>读取PDF页面内容</h2><p>使用PdfFileReader( )方法读取这个PDF文件后，可以使用getPage(n)取得第n页的PDF内容，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdfcontent &#x3D; pdfrd.getPage(n)  #读取第n页内容</span><br></pre></td></tr></table></figure><p>PDF页面也是从第0页开始计算，页面内容被读入pdfContentObj对象后，可以使用extractText( )取得该页的字符串内容。需留意，PyPDF2模块对于读取英文文件，比较没有障碍，对于中文内容会出现乱码。另外，PyPDF2无法读取图表或表格数据。</p><p>如读取travel.pdf的第0页内容：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201009173327722.png" alt="image-20201009173327722"></p><h2 id="检查PDF是否加密"><a href="#检查PDF是否加密" class="headerlink" title="检查PDF是否加密"></a>检查PDF是否加密</h2><p>初次执行“pdfRd = PyPDF2.PdfFileReader(pdfObj)”之后，pdfRd对象会有isEncryted属性，如果此属性是True，表示文件有加密。如果此属性是False，表示文件没有加密。</p><p>检查文件是否加密：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201009174520989.png" alt="image-20201009174520989"></p><h2 id="解密PDF文件"><a href="#解密PDF文件" class="headerlink" title="解密PDF文件"></a>解密PDF文件</h2><p>对于加密的PDF文件，我们可以使用decrypt( )执行解密，如果解密成功decrypt( )会传回1，如果失败则传回0。使用decrypt( )解密时，是解pdfRd对象的密码不是整份PDF，未来如果其他程序要使用这个PDF，仍须执行解密才可阅读使用。</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201010105023956.png" alt="image-20201010105023956"></p><h2 id="PDF页面的旋转"><a href="#PDF页面的旋转" class="headerlink" title="PDF页面的旋转"></a>PDF页面的旋转</h2><p>在浏览PDF文件时，可以旋转PDF页面。rotateClockwise( )可以执行页面顺时针旋转，rotateCounterClockwise( )可以执行逆时针旋转。在这2个方法内可以传入90、180、270度执行旋转工作。</p><p>如将travel.pdf的第0页旋转90度，然后存入out18_7.pdf：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201010105210795.png" alt="image-20201010105210795"></p><h2 id="加密PDF文件"><a href="#加密PDF文件" class="headerlink" title="加密PDF文件"></a>加密PDF文件</h2><p>要将PDF文件加密，可以在将pdfWr对象正式使用write( )方法写入前调用encrypt( )执行，加密的密码当作参数放在encrypt( )方法内。</p><p>如将travel.pdf文件加密储存在output.pdf内，密码是deepstone。</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201010105319452.png" alt="image-20201010105319452"></p><h2 id="python破解密码"><a href="#python破解密码" class="headerlink" title="python破解密码"></a>python破解密码</h2><p>如果密码是由3个阿拉伯数字组成，表示有3个位数，每个位数是由0-1所组成。</p><p>破解3位数字的密码，破解程序执行过程会将所测试失败的密码不断打印出来直到找到密码。</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201010105623720.png" alt="image-20201010105623720"></p><p>如果密码位数比较多，只要增加循环数即可。密码一般是由英文字母组成，其实用英文字母也可以，只不过是增加一些转换上的问题。</p><p>如设定密码位数有3位，是由纯英文字母大写所组成。由于有26个英文字母，所以所有循环均是执行26圈，range(1, 26)，由于字母A的Unicode是65，所以i1(i2或i3也是)值加上64就会是相对应的英文字母。</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86PDF%E6%96%87%E4%BB%B6/image-20201010105757455.png" alt="image-20201010105757455"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-处理word文件</title>
    <link href="http://yoursite.com/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/10/09/Python-处理word文件/</id>
    <published>2020-10-09T06:28:51.000Z</published>
    <updated>2020-10-09T07:30:56.311Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>Word是二进制(binary)文件，同时Word还有字体格式、色彩与版面配置等，所以它的处理方式比起文本文件(txt)要复杂。</p><p>需要使用外部模块python-docx。安装指令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-docx</span><br></pre></td></tr></table></figure><p>导入模块指令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import docx</span><br></pre></td></tr></table></figure><h2 id="python中的word文件结构"><a href="#python中的word文件结构" class="headerlink" title="python中的word文件结构"></a>python中的word文件结构</h2><p>在python-docx模块内，将Word文件结构分成3层：</p><p>1、Document：这是最高层代表整个Word文件。</p><p>2、Paragraph：一个Word文件是由许多的段落所组成，在Python中整份文件的定义是Document，这些段落的定义就是Paragraph对象。我们使用Word编辑文件时，如果单击一次Enter键，会产生一个新的段落。在Python中一个段落代表一个Paragraph对象，所有段落以Paragraph对象列表(list)方式存在。</p><p>3、Run：Word文件要考虑的有字号、字体样式、色彩等，我们将这些称作样式。一个Run对象所指的是Paragraph对象中相同样式的连续文字，如果文字发生样式变化，Python将以新的Run对象代表。</p><h2 id="读取word文件内容"><a href="#读取word文件内容" class="headerlink" title="读取word文件内容"></a>读取word文件内容</h2><h4 id="建立docx对象"><a href="#建立docx对象" class="headerlink" title="建立docx对象"></a>建立docx对象</h4><p>首先需建立Word文件(Document)的对象docx对象，可用Document( )方法建立。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydoc &#x3D; docx.Document(&#39;文件名&#39;)  #建立docx对象mydoc</span><br></pre></td></tr></table></figure><h4 id="获得paragraph和Run数量"><a href="#获得paragraph和Run数量" class="headerlink" title="获得paragraph和Run数量"></a>获得paragraph和Run数量</h4><p>使用len()方法获得paragraph数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(mydoc.paragraphs)</span><br></pre></td></tr></table></figure><p>下列语法可以获得第n段paragraph的Run数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(mydoc.paragraphs[n].runs)  #n是第几段或者paragraph编号</span><br></pre></td></tr></table></figure><h4 id="列出paragraph的内容"><a href="#列出paragraph的内容" class="headerlink" title="列出paragraph的内容"></a>列出paragraph的内容</h4><p>打印第n段Paragraph内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(mydoc.paragraphs[n].text)</span><br></pre></td></tr></table></figure><h4 id="列出paragraph内run的内容"><a href="#列出paragraph内run的内容" class="headerlink" title="列出paragraph内run的内容"></a>列出paragraph内run的内容</h4><p>打印第n段Paragraph第m个Run内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(mydoc.paragraphs[n].runs[m].text)</span><br></pre></td></tr></table></figure><h4 id="读取文件与适度编排输出"><a href="#读取文件与适度编排输出" class="headerlink" title="读取文件与适度编排输出"></a>读取文件与适度编排输出</h4><p>word内容为：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009145349672.png" alt="image-20201009145349672"></p><p>程序内容为：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009145501800.png" alt="image-20201009145501800"></p><h2 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h2><p>save( )方法可以存储Document对象的文件，如果将建立Word文件与存储Word文件整个语法串连，整个语法如下：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009150028841.png" alt="image-20201009150028841"></p><h2 id="建立文件内容"><a href="#建立文件内容" class="headerlink" title="建立文件内容"></a>建立文件内容</h2><h4 id="建立标题"><a href="#建立标题" class="headerlink" title="建立标题"></a>建立标题</h4><p>使用add_heading( )方法建立文件标题内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydoc.add_heading(&#39;content of head&#39;)  #mydoc为自建的文件对象</span><br></pre></td></tr></table></figure><p>Word的标题有1-9，如果想建立不同的标题可以使用第2个参数‘level=n’。</p><p>使用下列语法在建立文件标题内容同时设定标题格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydoc.add_heading(&#39;content of head&#39;,level&#x3D;n)</span><br></pre></td></tr></table></figure><h4 id="建立段落paragraph内容"><a href="#建立段落paragraph内容" class="headerlink" title="建立段落paragraph内容"></a>建立段落paragraph内容</h4><p>可以使用add_paragraph( )方法建立文件的段落（也可称Paragraph）内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr &#x3D; mydoc.add_paragraph(&#39;content of paragraph&#39;)</span><br></pre></td></tr></table></figure><p>未来插入段落时可以将新段落插入此段落的前面，或是将Run内容插入此段落内。可以使用insert_paragraph_before( )方法，将段落插在上述ptr段落对象的前方。</p><p>如先插入2个段落，然后将新段落插在第一个段落的前面：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009150606065.png" alt="image-20201009150606065"></p><h4 id="建立run内容"><a href="#建立run内容" class="headerlink" title="建立run内容"></a>建立run内容</h4><p>Paragraph是由Run组成，当我们建立Paragraph成功后，未来若是想要在Paragraph内插入内容，可以使用add_run( )方法，此方法的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr.add_run(&#39;content of run&#39;)  #ptr是段落对象</span><br></pre></td></tr></table></figure><h4 id="强制换页输出"><a href="#强制换页输出" class="headerlink" title="强制换页输出"></a>强制换页输出</h4><p>add_page_break( )方法可以强制Word换页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydoc.add_page_break( )</span><br></pre></td></tr></table></figure><p>如果有插入段落时，会在新一页出现。</p><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>使用add_picture( )方法插入图片到Word文件内，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydoc.add_picture(&#39;image_file&#39;)</span><br></pre></td></tr></table></figure><p>如果插入图片时想要设定图片的宽度或高度，需导入docx.shared模块，然后就可以在add_picture( )方法内增加使用第2个参数width(宽度)或height(高度)，然后用Inches( )英寸函数或Cm( )公分函数设定图片宽度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from docx.shared import Inches</span><br><span class="line">mydoc.add_picture(&#39;image_file&#39;,width&#x3D;Inches(宽度值))</span><br></pre></td></tr></table></figure><h2 id="建立表格"><a href="#建立表格" class="headerlink" title="建立表格"></a>建立表格</h2><p>add_table( )方法可以建立表格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table &#x3D; mydoc.add_table(rows&#x3D;?,cols&#x3D;?) #执行完返回table表格对象</span><br></pre></td></tr></table></figure><h4 id="建立表格内容"><a href="#建立表格内容" class="headerlink" title="建立表格内容"></a>建立表格内容</h4><p>一次处理一列的表格内容，如下：</p><p>row = table.rows[0]</p><p>row.cell[0].text = ‘表格(0,0)的内容’</p><p>row.cell[1].text = ‘表格(0,1)的内容’</p><h4 id="插入表格列"><a href="#插入表格列" class="headerlink" title="插入表格列"></a>插入表格列</h4><p>使用add_row( )插入表格列。</p><h4 id="打印表格内容"><a href="#打印表格内容" class="headerlink" title="打印表格内容"></a>打印表格内容</h4><p>可以使用双层循环打印表格内容：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009152358214.png" alt="image-20201009152358214"></p><h4 id="表格的样式"><a href="#表格的样式" class="headerlink" title="表格的样式"></a>表格的样式</h4><p>可以使用table.style设定框线。</p><p>设定表格的样式，LightShading是浅色底纹，Accent1是辅色1，若是调整为Accent2，……，Accent6将有不同的结果，LightShading-Accept1。</p><h2 id="paragraph样式"><a href="#paragraph样式" class="headerlink" title="paragraph样式"></a>paragraph样式</h2><p>Paragraph样式就是所谓的段落样式，下列是常见的Word样式内容。</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009152616751.png" alt="image-20201009152616751"></p><p>在插入段落时，可以在add_paragraph( )方法内增加第2个参数“style=样式名称”，这样就可以在插入段落同时设定段落的样式。</p><h2 id="Run的样式"><a href="#Run的样式" class="headerlink" title="Run的样式"></a>Run的样式</h2><p>Run的样式重点就是设定Run的文字(text)属性，下列是常见的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bold 粗体</span><br><span class="line">italic 斜体</span><br><span class="line">underline 下划线</span><br><span class="line">strike 删除线</span><br></pre></td></tr></table></figure><p>当我们建立一个Run对象时，会回传Run对象，此时若将此对象的样式设为True，相当于可以建立该Run对象的样式。</p><p>如建立Run内容，然后设定此内容的属性为粗体(bold)与斜体：</p><p><img src="/2020/10/09/Python-%E5%A4%84%E7%90%86word%E6%96%87%E4%BB%B6/image-20201009153002680.png" alt="image-20201009153002680"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-正则表达式</title>
    <link href="http://yoursite.com/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/10/06/Python-正则表达式/</id>
    <published>2020-10-06T10:23:20.000Z</published>
    <updated>2020-10-09T06:24:32.699Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>Python有关正则表达式的方法是在re模块内，使用正则表达式需要导入re模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br></pre></td></tr></table></figure><h4 id="搜寻字符串模式"><a href="#搜寻字符串模式" class="headerlink" title="搜寻字符串模式"></a>搜寻字符串模式</h4><p>正则表达式是一种文本模式的表达方法，在这个方法中使用\d表示0—9的数字字符。由逸出字符的观念可知，当字符串放入函数内需增加‘\’，所以整个正则表达式的使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;\\d\\dd\\d\\d\\d-\\d\\d\\d\\d&#39;</span><br><span class="line">或r&#39;\d\dd\d\d\d-\d\d\d\d&#39;</span><br></pre></td></tr></table></figure><h4 id="使用re-compile-建立Regex对象"><a href="#使用re-compile-建立Regex对象" class="headerlink" title="使用re.compile( )建立Regex对象"></a>使用re.compile( )建立Regex对象</h4><p>Regex是Regular expression的简称，在re模块内有compile( )方法，可以将欲搜寻字符串的正则表达式当作字符串参数放在此方法内，然后会传回一个Regex对象。</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rule &#x3D; re.compile(r&#39;\d\dd\d\d\d-\d\d\d\d&#39;)</span><br><span class="line"></span><br><span class="line">对于重复出现的字符串可以用大括号内部加上重复次数方式表达：</span><br><span class="line">rule &#x3D; re.compile(r&#39;\d&#123;4&#125;-\d&#123;3&#125;&#39;)</span><br></pre></td></tr></table></figure><h4 id="搜寻对象"><a href="#搜寻对象" class="headerlink" title="搜寻对象"></a>搜寻对象</h4><p>在Regex对象内有search( )方法，可以由Regex对象启用，然后将欲搜寻的字符串放在这个方法内，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mb &#x3D; rule.search(msg)</span><br></pre></td></tr></table></figure><p>如果找不到比对相符的字符串会传回None，如果找到比对相符的字符串会将结果传回所设定的变量对象。</p><h4 id="findall"><a href="#findall" class="headerlink" title="findall()"></a>findall()</h4><p>这个方法会将搜寻到的目标用列表方式传回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rule &#x3D; re.compile(r&#39;\d\dd\d\d\d-\d\d\d\d&#39;) #建立rule对象</span><br><span class="line">mb &#x3D; rule.findall(string)  #string是欲搜寻的字符串</span><br></pre></td></tr></table></figure><p>findall( )函数由rule对象启用，最后会将搜寻结果的列表传给mb，只要打印mb就可以得到执行结果。</p><h4 id="使用小括号分组"><a href="#使用小括号分组" class="headerlink" title="使用小括号分组"></a>使用小括号分组</h4><p>括号分组是以连字符“-”区别，然后用小括号隔开群组。如下面两个分组：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007093232469.png" alt="image-20201007093232469"></p><h4 id="使用管道"><a href="#使用管道" class="headerlink" title="使用管道"></a>使用管道</h4><p>|(pipe)在正规表示法称管道，使用管道我们可以同时搜寻比对多个字符串，例如，想要搜寻Mary和Tom字符串，可以使用下列表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patter &#x3D; &#39;mary|tom&#39;  #注意单引号&#39;和|旁不留空白</span><br></pre></td></tr></table></figure><h4 id="使用？做搜寻"><a href="#使用？做搜寻" class="headerlink" title="使用？做搜寻"></a>使用？做搜寻</h4><p>在正则表达式中若某些括号内的字符串或正则表达式可有可无，执行搜寻时皆算成功，例如，na字符串可有可无，表达方式是(na)?。</p><h4 id="使用-做搜寻"><a href="#使用-做搜寻" class="headerlink" title="使用*做搜寻"></a>使用*做搜寻</h4><p>在正则表达式中若某些字符串或正则表达式可从0到多次，执行搜寻时皆算成功，例如，na字符串可从0到多次，表达方式是(na)*。</p><h4 id="使用-做搜寻-1"><a href="#使用-做搜寻-1" class="headerlink" title="使用+做搜寻"></a>使用+做搜寻</h4><p>在正则表达式中若是某些字符串或正则表达式可从1到多次，执行搜寻时皆算成功，例如，na字符串可从1到多次，表达方式是(na)+。</p><h4 id="搜寻时忽略大小写"><a href="#搜寻时忽略大小写" class="headerlink" title="搜寻时忽略大小写"></a>搜寻时忽略大小写</h4><p>搜寻时若是在search( )或findall( )内增加第三个参数re.I或re.IGNORECASE，搜寻时就会忽略大小写，至于打印输出时将以原字符串的格式显示。</p><p>如以忽略大小写方式执行找寻相符字符串：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007094336734.png" alt="image-20201007094336734"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007094405095.png" alt="image-20201007094405095"></p><h4 id="使用大括号设定比对次数"><a href="#使用大括号设定比对次数" class="headerlink" title="使用大括号设定比对次数"></a>使用大括号设定比对次数</h4><p>大括号除了可以设定重复次数，也可以设定指定范围，例如，(son){3,5}代表所搜寻的字符串如果是‘sonsonson’‘sonsonsonson’或‘sonsonsonsonson’皆算是相符合的字符串。</p><h4 id="贪婪与非贪婪模式"><a href="#贪婪与非贪婪模式" class="headerlink" title="贪婪与非贪婪模式"></a>贪婪与非贪婪模式</h4><p>如使用搜寻模式‘(son){3,5}’，搜寻字符串‘sonsonsonsonson’。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007095020973.png" alt="image-20201007095020973"></p><p>上述程序所设定的搜寻模式可知3、4或5个son重复就算找到了，可是Python执行结果是列出最多重复的字符串，5次重复，这是Python的默认模式，这种模式又称贪婪(greedy)模式。</p><p>另一种是列出最少重复的字符串，称非贪婪模式，方法是在正则表达式的搜寻模式右边增加？符号。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007095124395.png" alt="image-20201007095124395"></p><h2 id="正则表达式的特殊字符"><a href="#正则表达式的特殊字符" class="headerlink" title="正则表达式的特殊字符"></a>正则表达式的特殊字符</h2><h4 id="特殊字符表"><a href="#特殊字符表" class="headerlink" title="特殊字符表"></a>特殊字符表</h4><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201007095540458.png" alt="image-20201007095540458"></p><h4 id="字符分类"><a href="#字符分类" class="headerlink" title="字符分类"></a>字符分类</h4><p>python中可以用中括号来设定字符。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[a-z]：代表a-z的小写字符</span><br><span class="line">[A-Z]：代表A-Z的大写字符</span><br><span class="line">[aeiouAEIOU]：代表英文发音的元音字符</span><br><span class="line">[2-5]：代表2-5的数字</span><br></pre></td></tr></table></figure><p>在字符分类中，中括号内可以不用放上正则表示法的反斜杠\执行.、?、*、(、)等字符的转译。</p><h4 id="字符分类的-字符"><a href="#字符分类的-字符" class="headerlink" title="字符分类的^字符"></a>字符分类的^字符</h4><p>中括号内的左方加上^字符，意义是搜寻不在这些字符内的所有字符。</p><p>在正规表示法中起始位置加上^字符，表示正则表示法的字符串必须出现在被搜寻字符串的起始位置，这样搜寻成功才算成功。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009135707635.png" alt="image-20201009135707635"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009135738751.png" alt="image-20201009135738751"></p><h4 id="正则表示法的-字符"><a href="#正则表示法的-字符" class="headerlink" title="正则表示法的$字符"></a>正则表示法的$字符</h4><p>正则表示法的末端放置$字符时，表示正则表示法的字符串必须出现在被搜寻字符串的最后位置，这样搜寻成功才算成功。</p><h4 id="单一字符使用通配符“-”"><a href="#单一字符使用通配符“-”" class="headerlink" title="单一字符使用通配符“.”"></a>单一字符使用通配符“.”</h4><p>通配符(wildcard)“.”表示可以搜寻除了换行字符以外的所有字符，但是只限定一个字符。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009140029088.png" alt="image-20201009140029088"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009140048223.png" alt="image-20201009140048223"></p><h4 id="所有字符使用通配符“-”"><a href="#所有字符使用通配符“-”" class="headerlink" title="所有字符使用通配符“.*”"></a>所有字符使用通配符“.*”</h4><p>“.”字符与“*”组合，可以搜寻所有字符，意义是搜寻0到多个通配符（换行字符除外）。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009140223690.png" alt="image-20201009140223690"></p><h4 id="换行字符的处理"><a href="#换行字符的处理" class="headerlink" title="换行字符的处理"></a>换行字符的处理</h4><p>用“.*”搜寻时碰上换行字符，搜寻就停止。Python的re模块提供参数re.DOTALL，功能是包括搜寻换行字符，可以将此参数放在search( )、findall( )或compile( )。</p><h2 id="MatchObject对象"><a href="#MatchObject对象" class="headerlink" title="MatchObject对象"></a>MatchObject对象</h2><h4 id="re-match"><a href="#re-match" class="headerlink" title="re.match( )"></a>re.match( )</h4><p>re.search( )搜寻字符串，搜寻成功时可以产生MatchObject对象，re.match( )方法搜寻成功后也将产生MatchObject对象。</p><p>这个方法其实和re.search( )相同，差异是re.match()只搜寻比对字符串开始的字，如果失败就算失败。re.search( )则是搜寻整个字符串。至于re.match( )搜寻成功会传回MatchObject对象，若是搜寻失败会传回None，这部分与re.search( )相同。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009141736734.png" alt="image-20201009141736734"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009141801562.png" alt="image-20201009141801562"></p><h4 id="MatchObject几个重要的方法"><a href="#MatchObject几个重要的方法" class="headerlink" title="MatchObject几个重要的方法"></a>MatchObject几个重要的方法</h4><p>当使用re.search( )或re.match( )搜寻成功时，会产生MatchOjbect对象。</p><p>Python提供下列取得MatchObject对象内容的重要方法。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009141921625.png" alt="image-20201009141921625"></p><p>如分别使用re.match( )和re.search( )搜寻字符串Joah，成功搜寻到字符串时，分别用start( )、end( )和span( )方法列出字符串出现的位置。</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009142021370.png" alt="image-20201009142021370"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/image-20201009142054105.png" alt="image-20201009142054105"></p><h4 id="sub-方法"><a href="#sub-方法" class="headerlink" title="sub()方法"></a>sub()方法</h4><p>Python re模块内的sub( )方法可以用新的字符串取代原本字符串的内容。</p><p>sub( )方法的基本使用语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; re.sub(pattern,newstr,msg)  # msg是整个要处理的字符串或句子</span><br></pre></td></tr></table></figure><p>pattern是欲搜寻的字符串，如果搜寻成功则用newstr取代，同时成功取代的结果回传给result变量，如果搜寻到多个相同字符串，这些字符串将全部被取代，需留意原先msg内容将不会改变。如果搜寻失败则将msg内容回传给result变量，当然msg内容也不会改变。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-异常处理</title>
    <link href="http://yoursite.com/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/10/06/Python-异常处理/</id>
    <published>2020-10-06T08:38:13.000Z</published>
    <updated>2020-10-06T10:17:05.679Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="程序异常"><a href="#程序异常" class="headerlink" title="程序异常"></a>程序异常</h2><p>Python提供功能可以让我们捕捉异常和撰写异常处理程序，当发生异常被我们捕捉时会去执行异常处理程序，然后程序可以继续执行。</p><h4 id="try-except"><a href="#try-except" class="headerlink" title="try-except"></a>try-except</h4><p>发生异常被捕捉时程序会执行异常处理程序，然后跳开异常位置，再继续往下执行。这时要使用try -except指令，它的语法格式如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164108843.png" alt="image-20201006164108843"></p><p>执行try:下面的指令，如果正常则跳离except部分，如果指令有错误异常，则检查此异常是否是异常对象所指的错误，如果是代表异常被捕捉了，则执行此异常对象下面的异常处理程序。</p><h4 id="try-except-else"><a href="#try-except-else" class="headerlink" title="try-except-else"></a>try-except-else</h4><p>Python在try - except中又增加了else指令，这个指令存放的主要目的是try内的指令正确时，可以执行else内的指令区块，我们可以将这部分指令区块称正确处理程序，这样可以增加程序的可读性。此时语法格式如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164238383.png" alt="image-20201006164238383"></p><h4 id="FileNotFoundError"><a href="#FileNotFoundError" class="headerlink" title="FileNotFoundError"></a>FileNotFoundError</h4><p>一个常常发生的异常是打开文件时找不到文件，这时会产生FileNotFoundError异常。</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164341891.png" alt="image-20201006164341891"></p><h4 id="分析单一文件的字数"><a href="#分析单一文件的字数" class="headerlink" title="分析单一文件的字数"></a>分析单一文件的字数</h4><p>如设计一个计算文章字数的函数wordsNum，只要传递文章文件名，就可以获得此篇文章的字数。</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164602832.png" alt="image-20201006164602832"></p><h2 id="多组异常处理程序"><a href="#多组异常处理程序" class="headerlink" title="多组异常处理程序"></a>多组异常处理程序</h2><h4 id="常见的异常对象"><a href="#常见的异常对象" class="headerlink" title="常见的异常对象"></a>常见的异常对象</h4><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164750005.png" alt="image-20201006164750005"></p><p>Python提供了一个通用型的异常对象Exception，它可以捕捉各式的基础异常。</p><p>如程序的异常对象设为Exception：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006164906040.png" alt="image-20201006164906040"></p><h4 id="捕捉多个异常"><a href="#捕捉多个异常" class="headerlink" title="捕捉多个异常"></a>捕捉多个异常</h4><p>在try: - except的使用中，可以设计多个except捕捉多种异常，此时语法如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165007916.png" alt="image-20201006165007916"></p><h4 id="使用一个except捕捉多个异常"><a href="#使用一个except捕捉多个异常" class="headerlink" title="使用一个except捕捉多个异常"></a>使用一个except捕捉多个异常</h4><p>Python也允许设计一个except，捕捉多个异常，此时语法如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165101291.png" alt="image-20201006165101291"></p><h4 id="使用Python内置的错误信息"><a href="#使用Python内置的错误信息" class="headerlink" title="使用Python内置的错误信息"></a>使用Python内置的错误信息</h4><p>Python支持发生异常时使用系统内置的异常处理信息。此时语法格式如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165216377.png" alt="image-20201006165216377"></p><p>e是系统内置的异常处理信息，e可以是任意字符。</p><h4 id="捕捉所有异常"><a href="#捕捉所有异常" class="headerlink" title="捕捉所有异常"></a>捕捉所有异常</h4><p>Python提供语法让我们可以一次捕捉所有异常，此时try - except语法如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165325759.png" alt="image-20201006165325759"></p><h2 id="丢出异常"><a href="#丢出异常" class="headerlink" title="丢出异常"></a>丢出异常</h2><p>Python直译器发现异常时，自行丢出异常对象，如果我们不处理程序就终止执行，如果我们使用try - except处理程序可以在异常中继续执行。</p><p>那么程序如果发生某些状况，我们自己将它定义为异常然后丢出异常信息，程序停止正常往下执行，同时让程序跳到自己设计的except去执行。它的语法如下：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165525546.png" alt="image-20201006165525546"></p><p>如目前有些金融机构在客户建立网络账号时，会要求密码长度必须在5到8个字符间，设计一个程序，这个程序内有passWord( )函数，这个函数会检查密码长度，如果长度小于5或是长度大于8皆抛出异常。</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165626571.png" alt="image-20201006165626571"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165649633.png" alt="image-20201006165649633"></p><h2 id="记录Traceback字符串"><a href="#记录Traceback字符串" class="headerlink" title="记录Traceback字符串"></a>记录Traceback字符串</h2><p>每次错误屏幕皆出现Traceback字符串，在这个字符串中指出程序错误的原因。导入traceback模块，就可以使用traceback.format_exc( )记录这个Traceback字符串。</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006165921029.png" alt="image-20201006165921029"></p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>Python的关键词finally功能是和try配合使用，在try之后可以有except或else，这个finally关键词必须放在except和else之后，同时不论是否有异常发生一定会执行这个finally内的程序代码。这个功能主要是用在Python程序与数据库连接时，输出连接相关信息。</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006170032835.png" alt="image-20201006170032835"></p><h2 id="程序断言assert"><a href="#程序断言assert" class="headerlink" title="程序断言assert"></a>程序断言assert</h2><p>Python的assert关键词主要功能是协助在程序设计阶段，对整个程序的执行状态做一个全面性的安全检查，以确保程序不会发生语意上的错误。</p><p>断言(assert)主要功能是确保程序执行的某个阶段，必须符合一定的条件，如果不符合这个条件时程序主动抛出异常，让程序终止同时主动打印出异常原因，方便程序设计师侦错。它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 条件，&#39;字符串&#39;</span><br></pre></td></tr></table></figure><p>程序执行至此阶段时测试条件，如果条件响应是True，程序不理会逗号“,”右边的字符串正常往下执行。如果条件响应是False，程序终止同时将逗号“,”右边的字符串输出到Traceback的字符串内。</p><p>停用断言assert，可以在Windows的命令提示环境，执行程序时使用“-O”选项停用断言。</p><h2 id="程序日志模块logging"><a href="#程序日志模块logging" class="headerlink" title="程序日志模块logging"></a>程序日志模块logging</h2><p>Python有程序日志logging功能，这个功能可以协助我们执行程序的除错，有了这个功能我们可以自行设定关键变量在每一个程序阶段的变化，由这个关键变量的变化可方便我们执行程序的除错。</p><h4 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h4><p>Python内有提供logging模块，这个模块有提供方法可以让我们使用程序日志logging功能，在使用前须先使用import导入此模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br></pre></td></tr></table></figure><h4 id="logging的等级"><a href="#logging的等级" class="headerlink" title="logging的等级"></a>logging的等级</h4><p>logging模块共分5个等级，从最低到最高等级顺序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DEBUG等级使用logging.debug( )显示程序日志内容，所显示的内容是程序的小细节，最低层级的内容，感觉程序有问题时可使用它追踪关键变量的变化过程。</span><br><span class="line"></span><br><span class="line">INFO等级使用logging.info( )显示程序日志内容，所显示的内容是记录程序一般发生的事件。</span><br><span class="line"></span><br><span class="line">WARNING等级使用logging.warning( )显示程序日志内容，所显示的内容虽然不会影响程序的执行，但是未来可能导致问题的发生。</span><br><span class="line"></span><br><span class="line">ERROR等级使用logging.error( )显示程序日志内容，通常显示程序在某些状态将引发错误的缘由。</span><br><span class="line"></span><br><span class="line">CRITICAL等级使用logging.critical( )显示程序日志内容，这是最重要的等级，通常是显示将让整个系统当掉或中断的错误。</span><br></pre></td></tr></table></figure><p>程序设计时，可以使用下列函数设定显示信息的等级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(level&#x3D;logging.DEBUG)  #设定DEBUG等级</span><br></pre></td></tr></table></figure><p>当设定logging为某一等级时，未来只有此等级或更高等级的logging会被显示。</p><p>如显示所有等级的logging信息：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006170937172.png" alt="image-20201006170937172"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006171000146.png" alt="image-20201006171000146"></p><h4 id="格式化logging信息输出format"><a href="#格式化logging信息输出format" class="headerlink" title="格式化logging信息输出format"></a>格式化logging信息输出format</h4><p>可以使用在logging.basicConfig( )方法内增加format格式化输出信息为空字符串‘’的方式，取消显示前导输出信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(level&#x3D;logging.DEBUG,format&#x3D;&#39;&#39;)</span><br></pre></td></tr></table></figure><h4 id="时间信息asctime"><a href="#时间信息asctime" class="headerlink" title="时间信息asctime"></a>时间信息asctime</h4><p>可以在format内配合asctime列出系统时间，这样可以列出每一重要阶段关键变量发生的时间。</p><p>如列出每一个logging输出时的时间</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181140290.png" alt="image-20201006181140290"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181205827.png" alt="image-20201006181205827"></p><p>要输出原先logging.xxx( )的输出信息，必须在format内增加message格式。</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181302448.png" alt="image-20201006181302448"></p><p>执行结果：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181323359.png" alt="image-20201006181323359"></p><h4 id="将程序日志logging输出到文件"><a href="#将程序日志logging输出到文件" class="headerlink" title="将程序日志logging输出到文件"></a>将程序日志logging输出到文件</h4><p>将logging输出在屏幕，其实不太方便逐一核对关键变量值的变化，此时可以考虑将logging输出到文件，方法是在logging.basicConfig( )增加filename=“文件名”，这样就可以将logging输出到指定的文件内。</p><p>如将程序日志输出到txt里：</p><p><img src="/2020/10/06/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/image-20201006181530241.png" alt="image-20201006181530241"></p><h4 id="停用程序日志logging"><a href="#停用程序日志logging" class="headerlink" title="停用程序日志logging"></a>停用程序日志logging</h4><p>可以使用下列方法停用日志logging：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.disable(level)  #level是停用logging的等级</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-文件读取与写入</title>
    <link href="http://yoursite.com/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/"/>
    <id>http://yoursite.com/2020/10/05/Python-文件读取与写入/</id>
    <published>2020-10-05T04:05:47.000Z</published>
    <updated>2020-10-06T08:33:43.862Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>文件路径图形如下：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201005121343034.png" alt="image-20201005121343034"></p><h4 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h4><p>在操作系统中可以使用2种方式表达文件路径。</p><p>1.绝对路径：路径从根目录开始表示，以上图为例，其绝对路径为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Python\ch14\ch14_1.py</span><br></pre></td></tr></table></figure><p>2.相对路径：指相对于当前工作目录的路径，若是当前工作目录是D:\Python\ch14，它的相对路径是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch14_1.py</span><br></pre></td></tr></table></figure><p>另外，在操作系统处理文件夹的观念中会使用2个特殊符号“.”和“..”，“.”指的是当前文件夹，“..”指的是上一层文件夹。但是在使用上，当指当前文件夹时也可以省略“.\”。</p><h4 id="os模块与os-path模块"><a href="#os模块与os-path模块" class="headerlink" title="os模块与os.path模块"></a>os模块与os.path模块</h4><p>在Python内有关文件路径的模块是os。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import os #导入os模块</span><br></pre></td></tr></table></figure><p>在os模块内有另一个常用模块os.path，由于os.path是在os模块内，所以导入os模块后不用再导入os.path模块。</p><h4 id="取得当前工作目录"><a href="#取得当前工作目录" class="headerlink" title="取得当前工作目录"></a>取得当前工作目录</h4><p>os模块内的getcwd( )可以取得当前工作目录。</p><p>如列出当前工作目录：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145223242.png" alt="image-20201006145223242"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145254888.png" alt="image-20201006145254888"></p><h4 id="取得绝对路径"><a href="#取得绝对路径" class="headerlink" title="取得绝对路径"></a>取得绝对路径</h4><p>os.path模块的abspath(path)会传回path的绝对路径，通常我们可以使用这个方法将文件或文件夹的相对路径转成绝对路径。</p><p>如取得绝对路径的应用：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145432196.png" alt="image-20201006145432196"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145456563.png" alt="image-20201006145456563"></p><h4 id="传回特定路段的相对路径"><a href="#传回特定路段的相对路径" class="headerlink" title="传回特定路段的相对路径"></a>传回特定路段的相对路径</h4><p>os.path模块的relpath(path, start)会传回从start到path的相对路径，如果省略start，则传回当前工作目录至path的相对路径。</p><p>如传回相对路径的应用：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145653302.png" alt="image-20201006145653302"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006145831779.png" alt="image-20201006145831779"></p><h4 id="检查路径的方法exist-isabs-isdir-isfile"><a href="#检查路径的方法exist-isabs-isdir-isfile" class="headerlink" title="检查路径的方法exist/isabs/isdir/isfile"></a>检查路径的方法exist/isabs/isdir/isfile</h4><p>下列是常用的os.path模块方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exist(path)：如果path的文件或文件夹存在传回True，否则传回False。</span><br><span class="line"></span><br><span class="line">isabs(path)：如果path的文件或文件夹是绝对路径传回True，否则传回False。</span><br><span class="line"></span><br><span class="line">isdir(path)：如果path是文件夹传回True，否则传回False。</span><br><span class="line"></span><br><span class="line">isfile(path)：如果path是文件传回True，否则传回False。</span><br></pre></td></tr></table></figure><h4 id="文件与目录的操作mkdir-rmdir-remove-chdir"><a href="#文件与目录的操作mkdir-rmdir-remove-chdir" class="headerlink" title="文件与目录的操作mkdir/rmdir/remove/chdir"></a>文件与目录的操作mkdir/rmdir/remove/chdir</h4><p>这几个方法是在os模块内，执行下列操作前先用os.path.exists( )检查是否存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir(path)：建立path目录。</span><br><span class="line"></span><br><span class="line">rmdir(path)：删除path目录，限制只能是空的目录。</span><br><span class="line"></span><br><span class="line">remove(path)：删除path文件。</span><br><span class="line"></span><br><span class="line">chdir(path)：将当前工作文件夹改至path。</span><br></pre></td></tr></table></figure><h4 id="传回文件路径os-path-join"><a href="#传回文件路径os-path-join" class="headerlink" title="传回文件路径os.path.join( )"></a>传回文件路径os.path.join( )</h4><p>这个方法可以将os.path.join( )参数内的字符串结合为一个文件路径，参数可以有2个到多个。</p><p>如使用for循环将一个列表内的文件与一个路径结合：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006150938010.png" alt="image-20201006150938010"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151000741.png" alt="image-20201006151000741"></p><h4 id="获得特定文件的大小"><a href="#获得特定文件的大小" class="headerlink" title="获得特定文件的大小"></a>获得特定文件的大小</h4><p>os.path.getsize( )方法可以获得特定文件的大小。</p><p>如获得某个文件的文件大小：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151159257.png" alt="image-20201006151159257"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151218139.png" alt="image-20201006151218139"></p><h4 id="获得特定工作目录的内容"><a href="#获得特定工作目录的内容" class="headerlink" title="获得特定工作目录的内容"></a>获得特定工作目录的内容</h4><p>os.listdir()方法将以列表方式列出特定工作目录的内容。</p><p>如列出特定工作目录所有文件的大小：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151349241.png" alt="image-20201006151349241"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151414535.png" alt="image-20201006151414535"></p><h4 id="获得特定工作目录内容glob"><a href="#获得特定工作目录内容glob" class="headerlink" title="获得特定工作目录内容glob"></a>获得特定工作目录内容glob</h4><p>Python内还有一个模块可用于列出特定工作目录内容glob，当导入这个模块后可以使用glob方法获得特定工作目录的内容，这个方法最大特色是可以使用通配符“<em>”，例如，可用“</em>.txt”获得所有txt扩展名的文件。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151603715.png" alt="image-20201006151603715"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006151629769.png" alt="image-20201006151629769"></p><h4 id="遍历目录树os-walk"><a href="#遍历目录树os-walk" class="headerlink" title="遍历目录树os.walk( )"></a>遍历目录树os.walk( )</h4><p>在os模块内有提供一个os.walk( )方法可以让我们遍历目录树，这个方法每次执行循环时将传回3个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当前工作目录名称(dirName)。</span><br><span class="line"></span><br><span class="line">当前工作目录底下的子目录列表(sub_dirNames).</span><br><span class="line"></span><br><span class="line">当前工作目录底下的文件列表(fileNames)。</span><br></pre></td></tr></table></figure><p>语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for dirname,sub_dirNames,fileNames in os.walk(&quot;目录路径&quot;)：</span><br><span class="line">                  程序区块</span><br></pre></td></tr></table></figure><p>上述dirName, sub_dirNames, fileNames名称可以自行命名，顺序则不可以更改，至于目录路径可以使用绝对地址或相对地址，如果不注明则代表当前工作目录的子目录。</p><p>如此目录内容如下:</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006152102778.png" alt="image-20201006152102778"></p><p>遍历此oswalk目录，同时列出内容:</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006152200228.png" alt="image-20201006152200228"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006152229395.png" alt="image-20201006152229395"></p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>Python处理读取或写入文件首先需将文件打开，然后可以一次读取所有文件内容或是一行一行读取文件内容。Python可以使用open( )函数打开文件，文件打开后会传回文件对象。</p><h4 id="读取整个文件read"><a href="#读取整个文件read" class="headerlink" title="读取整个文件read()"></a>读取整个文件read()</h4><p>文件打开后，可以使用read( )读取所打开的文件，使用read( )读取时，所有的文件内容将以一个字符串方式被读取然后存入字符串变量内，只要打印此字符串变量相当于可以打印整个文件内容。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006154553632.png" alt="image-20201006154553632"></p><h4 id="with关键词"><a href="#with关键词" class="headerlink" title="with关键词"></a>with关键词</h4><p>Python提供一个关键词with应用在打开文件与建立文件对象时，使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(打开的文件) as 文件对象：</span><br><span class="line">     相关操作</span><br></pre></td></tr></table></figure><p>使用这种方式打开文件，最大特色是可以不必在程序中关闭文件，with指令会在结束不需要此文件时自动将它关闭，文件经“with open( ) as文件对象”打开后会有一个文件对象，就可以使用read( )读取此文件对象的内容。</p><h4 id="逐行读取文件内容"><a href="#逐行读取文件内容" class="headerlink" title="逐行读取文件内容"></a>逐行读取文件内容</h4><p>Python逐行读取文件内容，可以使用下列循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for line in file_obj:  #line和obj取名任意，file_obj是文件对象</span><br><span class="line">     循环相关指令</span><br></pre></td></tr></table></figure><h4 id="逐行读取使用readlines"><a href="#逐行读取使用readlines" class="headerlink" title="逐行读取使用readlines( )"></a>逐行读取使用readlines( )</h4><p>使用with关键词配合open( )时，所打开的文件对象当前只在with区块内使用，特别是想要遍历此文件对象时。Python另外有一个方法readlines( )可以逐行读取，同时以列表方式储存，另一个特色是读取时每行的换行字符皆会储存在列表内。</p><p>如使用readlines( )逐行读取txt：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006155704715.png" alt="image-20201006155704715"></p><h4 id="字符串的替换"><a href="#字符串的替换" class="headerlink" title="字符串的替换"></a>字符串的替换</h4><p>使用Word处理时常常会使用寻找/取代功能，Python也有这个方法可以使新字符串取代旧字符串。</p><p>字符串对象.replace(旧字符串, 新字符串) # 在字符串对象内，新字符串将取代旧字符串。</p><p>如将“工专”改为“科大”：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006155837575.png" alt="image-20201006155837575"></p><h4 id="数据搜寻使用find"><a href="#数据搜寻使用find" class="headerlink" title="数据搜寻使用find( )"></a>数据搜寻使用find( )</h4><p>对于字符串的使用，Python提供一个方法find( )，这个方法除了可以执行数据搜寻以外，如果搜寻到数据还会传回数据的索引位置，如果没有找到则传回-1。使用语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index &#x3D; S.find(sub,[start,end])</span><br></pre></td></tr></table></figure><p>S代表被搜寻的字符串，sub是欲搜寻的字符串，index是如果搜寻到时传回的索引值，start和end代表可以被搜寻字符串的区间，若是省略表示全部搜寻，如果没有找到则传回-1给index。</p><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h4 id="将结果写入空文件内"><a href="#将结果写入空文件内" class="headerlink" title="将结果写入空文件内"></a>将结果写入空文件内</h4><p>打开文件open( )函数使用时默认是mode=‘r’读取文件模式，因此如果打开文件是供读取可以省略mode=‘r’。若是要供写入，那么就要设定写入模式mode=‘w’，程序设计时可以省略mode，直接在open( )函数内输入‘w’。如果所打开的文件需要读取和写入可以使用‘r+’。如果所打开的文件不存在open( )会建立该文件对象，如果所打开的文件已经存在，原文件内容将被清空。</p><p>输出到文件可以使用write( )方法，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件对象.write(欲输出数据)  #可将数据输出到文件对象</span><br></pre></td></tr></table></figure><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006160430673.png" alt="image-20201006160430673"></p><h4 id="写入数值资料"><a href="#写入数值资料" class="headerlink" title="写入数值资料"></a>写入数值资料</h4><p>write( )输出时无法输出数值数据，如果想要使用write( )将数值数据输出，必须使用str( )将数值数据转成字符串数据。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006160556264.png" alt="image-20201006160556264"></p><h4 id="附加写入"><a href="#附加写入" class="headerlink" title="附加写入"></a>附加写入</h4><p>附加文件主要是可以将文件输出到所打开的文件末端，当以open( )打开时，需增加参数mode=‘a’或是用‘a’，其实a是append的缩写。用open( )打开文件使用‘a’参数时，如果所打开的文件不存在，Python会打开文件供写入；如果所打开的文件存在，Python在执行写入时不会清空原先的文件内容。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006160717650.png" alt="image-20201006160717650"></p><h4 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a>shutil模块</h4><p>这个模块有提供一些方法可以让我们在Python程序内执行文件或目录的复制、删除、更改位置和更改名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import shutil</span><br></pre></td></tr></table></figure><p>1.文件拷贝copy()</p><p>在shutil模块可以使用copy( )执行文件的复制，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.copy(源位置，目的位置)</span><br></pre></td></tr></table></figure><p>执行前source文件一定要存在否则会产生错误。</p><p>2.目录的复制copytree()</p><p>copytree( )的语法格式与copy( )相同，只不过这是复制目录，复制时目录底下的子目录或文件也将被复制，此外，执行前目录一定要存在否则会产生错误。</p><p>3.文件的移动move()</p><p>在shutil模块可以使用move( )执行文件的移动，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.move(源文件位置，目的文件位置)</span><br></pre></td></tr></table></figure><p>可将source文件移动到destination目的位置，执行前source文件一定要存在否则会产生错误，执行后source文件将不再存在。</p><p>4.文件名的更改move()</p><p>在移动过程如果目的路径含有文件名，则可以达到更改名称的效果。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006161246384.png" alt="image-20201006161246384"></p><p>5.目录的移动move()</p><p>move( )也可以执行目录的移动，在移动时子目录也将随着移动。</p><p>如将当前工作目录的子目录dir37移至D:\Python目录下。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006161409265.png" alt="image-20201006161409265"></p><p>6.目录更改名称move()</p><p>如果在移动过程目的的目录不存在，此时就可以达到目录更改名称的目的了，甚至路径名称也可能更改。</p><p>如将当前子目录dir38移动并改名为out38：</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006161539283.png" alt="image-20201006161539283"></p><p>7.删除有数据的目录rmtree( )</p><p>os模块的rmdir( )只能删除空的目录，如果要删除含数据文件的目录须使用rmtree( )。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006161656882.png" alt="image-20201006161656882"></p><h4 id="第三方模块删除send2trash"><a href="#第三方模块删除send2trash" class="headerlink" title="第三方模块删除send2trash( )"></a>第三方模块删除send2trash( )</h4><p>Python内置的shutil模块在删除文件后就无法复原了，当前有一个第三方的模块send2trash，执行删除文件或文件夹后是将被删除的文件放在回收站，如果后悔可以救回。不过在使用此模块前须先下载这个外部模块。可以进入安装Python的文件夹，然后在DOS环境安装此模块，安装指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install send2trash</span><br></pre></td></tr></table></figure><p>安装完成后就可以使用下列方式删除文件或目录了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import send2trash</span><br><span class="line">sendtrash.sendtrash(文件或文件夹)</span><br></pre></td></tr></table></figure><h2 id="文件压缩与解压缩zipFile"><a href="#文件压缩与解压缩zipFile" class="headerlink" title="文件压缩与解压缩zipFile"></a>文件压缩与解压缩zipFile</h2><p>Windows操作系统有提供功能将一般文件或目录压缩，压缩后的扩展名是zip，Python内有zipFile模块也可以将文件或目录压缩以及解压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import zipFile</span><br></pre></td></tr></table></figure><h4 id="文件或目录的压缩"><a href="#文件或目录的压缩" class="headerlink" title="文件或目录的压缩"></a>文件或目录的压缩</h4><p>执行文件压缩前首先要使用ZipFile( )方法建立一份压缩后的档名，在这个方法中另外要加上‘w’参数，注明未来是供write( )方法写入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filezip &#x3D; zipfile.ZipFile(&#39;out.zip&#39;,&#39;w&#39;) #outzip是存储压缩的结果</span><br></pre></td></tr></table></figure><p>fileZip和out.zip皆可以自由设定名称，fileZip是压缩文件对象代表的是out.zip，未来将被压缩的文件数据写入此对象，就可以将结果存入out.zip。虽然ZipFile( )无法执行整个目录的压缩，不过可用循环方式将目录底下的文件压缩，即可达到压缩整个目录的目的。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006162303119.png" alt="image-20201006162303119"></p><h4 id="读取zip文件"><a href="#读取zip文件" class="headerlink" title="读取zip文件"></a>读取zip文件</h4><p>ZipFile对象有namelist( )方法可以传回zip文件内所有被压缩的文件或目录名称，同时以列表方式传回此对象。这个传回的对象可以使用infolist( )方法传回各元素的属性，如文件名filename、文件大小file_size、压缩结果大小compress_size、文件时间data_time。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006162448350.png" alt="image-20201006162448350"></p><h4 id="解压缩zip文件"><a href="#解压缩zip文件" class="headerlink" title="解压缩zip文件"></a>解压缩zip文件</h4><p>解压缩zip文件可以使用extractall( )方法。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006162535954.png" alt="image-20201006162535954"></p><h2 id="认识编码格式encode"><a href="#认识编码格式encode" class="headerlink" title="认识编码格式encode"></a>认识编码格式encode</h2><p>当前为止所谈到的文本文件(.txt)的文件打开有关文件编码部分皆是使用Windows操作系统默认方式，文本模式下常用的编码方式有utf-8和cp950。使用open( )打开文件时，可以增加另一个常用的参数encoding，整个open( )的语法将如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_obj &#x3D; open(file,mode&#x3D;&#39;r&#39;,encoding&#x3D;&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure><h4 id="记事本默认的编码"><a href="#记事本默认的编码" class="headerlink" title="记事本默认的编码"></a>记事本默认的编码</h4><p>中文Windows操作系统记事本默认的编码是ANSI，在这个编码格式下，在Python的open( )内我们可以使用预设的encoding=“cp950”编码，因为这是Python预设所以我们可以省略此参数。</p><h4 id="utf-8编码"><a href="#utf-8编码" class="headerlink" title="utf-8编码"></a>utf-8编码</h4><p>utf-8英文全名是8-bit Unicode Transformation Format，这是一种适合多语系的编码规则，主要方法是使用可变长度字节方式储存字符，以节省内存空间。</p><p>这种编码规则已经包含了全球所有语言的字符了，所以采用这种编码方式设计网页时，其他国家的浏览器只要支持utf-8编码皆可显示。</p><p>utf-8是国际通用的编码，如果你使用Linux或Max OS，一般也是用国际编码，所以如果打开文件发生错误，请先检查文件的编码格式。</p><p><img src="/2020/10/05/Python-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/image-20201006163020610.png" alt="image-20201006163020610"></p><h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><p>剪贴板的功能是属第三方pyperclip模块内，使用前需使用下列方式安装此模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyperclip</span><br></pre></td></tr></table></figure><p>然后程序前面导入pyperclip模块功能:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pyperclip</span><br></pre></td></tr></table></figure><p>安装完成后就可以使用下列两个方法：</p><ol><li>copy( )：可将列表数据复制至剪贴板。</li><li>paste( )：将剪贴板数据复制回字符串变量.。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-模块</title>
    <link href="http://yoursite.com/2020/10/05/Python-%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/10/05/Python-模块/</id>
    <published>2020-10-05T02:44:47.000Z</published>
    <updated>2020-10-05T03:54:58.665Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>在大型计划的程序设计中，每个人可能只是负责一小功能的函数或类设计，为了可以让团队的其他人可以互相分享设计成果，最后每个人所负责的功能函数或类将存储在模块(module)中，然后供团队其他成员使用。</p><h2 id="将自建函数存储在模块中"><a href="#将自建函数存储在模块中" class="headerlink" title="将自建函数存储在模块中"></a>将自建函数存储在模块中</h2><p>一个大型程序一定是由许多的函数或类所组成，为了让程序的工作可以分工以及增加程序的可读性，可以将所建的函数或类存储成模块(module)形式的独立文件，未来再加以调用引用。</p><p>模块的扩展名与Python程序文件一样，是py。</p><p>如建立一个模块，此模块名称是makefood.py：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005105636944.png" alt="image-20201005105636944"></p><h2 id="应用建立的函数模块"><a href="#应用建立的函数模块" class="headerlink" title="应用建立的函数模块"></a>应用建立的函数模块</h2><h4 id="import模块名称"><a href="#import模块名称" class="headerlink" title="import模块名称"></a>import模块名称</h4><p>要导入模块所用语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import 模块名 #导入模块</span><br></pre></td></tr></table></figure><p>程序中要引用模块中的函数语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块名称.函数名称</span><br></pre></td></tr></table></figure><h4 id="导入模块内特定单一函数"><a href="#导入模块内特定单一函数" class="headerlink" title="导入模块内特定单一函数"></a>导入模块内特定单一函数</h4><p>如果只想导入模块内单一特定的函数，可以使用下列语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块名称 import 函数名称</span><br></pre></td></tr></table></figure><p>程序引用所导入的函数时可以省略模块名称。</p><h4 id="导入模块内多个函数"><a href="#导入模块内多个函数" class="headerlink" title="导入模块内多个函数"></a>导入模块内多个函数</h4><p>如果想导入模块内多个函数，函数名称间需以逗号隔开，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块名称  import 函数名称1，函数名称2，函数名称3....</span><br></pre></td></tr></table></figure><h4 id="导入模块内所有函数"><a href="#导入模块内所有函数" class="headerlink" title="导入模块内所有函数"></a>导入模块内所有函数</h4><p>如果想导入模块内所有函数，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块 import *</span><br></pre></td></tr></table></figure><h4 id="使用as给函数指定替代名称"><a href="#使用as给函数指定替代名称" class="headerlink" title="使用as给函数指定替代名称"></a>使用as给函数指定替代名称</h4><p>可以自行给模块的函数名称一个替代名称，未来可以使用这个替代名称代替原先模块的名称。语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块名称 import 函数名称 as 替代名称</span><br></pre></td></tr></table></figure><h4 id="给模块指定替代名称"><a href="#给模块指定替代名称" class="headerlink" title="给模块指定替代名称"></a>给模块指定替代名称</h4><p>Python也允许给模块替代名称，未来可以使用此替代名称导入模块，其语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import 函数名称 as 替代名称</span><br></pre></td></tr></table></figure><h2 id="将自建的类的存储在模块中"><a href="#将自建的类的存储在模块中" class="headerlink" title="将自建的类的存储在模块中"></a>将自建的类的存储在模块中</h2><p>当程序设计越来越复杂时，可能我们也会建立许多类，Python也允许我们将所建立的类储存在模块内。</p><h4 id="建立类内容的模块"><a href="#建立类内容的模块" class="headerlink" title="建立类内容的模块"></a>建立类内容的模块</h4><p>模块的扩展名与Python程序文件一样，是py。</p><p>如建立一个模块，此模块名称是banks.py：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005111329305.png" alt="image-20201005111329305"></p><h2 id="应用建立的类模块"><a href="#应用建立的类模块" class="headerlink" title="应用建立的类模块"></a>应用建立的类模块</h2><h4 id="导入模块的单一类"><a href="#导入模块的单一类" class="headerlink" title="导入模块的单一类"></a>导入模块的单一类</h4><p>语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块名称 import 类名称</span><br></pre></td></tr></table></figure><p>如导入Banks类：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005111612456.png" alt="image-20201005111612456"></p><h4 id="导入模块的多个类"><a href="#导入模块的多个类" class="headerlink" title="导入模块的多个类"></a>导入模块的多个类</h4><p>使用下列方式导入多个类别，所导入的类别名称间需以逗号隔开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块名称 import 类名称1，类名称2....</span><br></pre></td></tr></table></figure><h4 id="导入模块内的所有类"><a href="#导入模块内的所有类" class="headerlink" title="导入模块内的所有类"></a>导入模块内的所有类</h4><p>导入模块内所有类别，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from 模块名称 import *</span><br></pre></td></tr></table></figure><h4 id="模块内导入另一个模块的类"><a href="#模块内导入另一个模块的类" class="headerlink" title="模块内导入另一个模块的类"></a>模块内导入另一个模块的类</h4><p>有时候可能一个模块内有太多类别了，此时可以考虑将一系列的类别分成2个或更多个模块储存。如果拆成类别的模块彼此有衍生关系，则子类别也需将父类别导入，执行时才不会有错误产生。</p><p>如在下面的这个程序中，分别导入了两个模块</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112102241.png" alt="image-20201005112102241"></p><h2 id="随机数random模块"><a href="#随机数random模块" class="headerlink" title="随机数random模块"></a>随机数random模块</h2><p>所谓的随机数是指平均散布在某区间的数字，随机数其实用途很广，最常见的应用是设计游戏时可以控制输出结果。</p><h4 id="randint"><a href="#randint" class="headerlink" title="randint()"></a>randint()</h4><p>这个方法可以随机产生指定区间的整数，它的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randint(min,max) #可以产生min与max之间的整数值</span><br></pre></td></tr></table></figure><p>如猜数字游戏，这个程序首先会用randint( )方法产生一个1到10之间的数字，然后如果猜的数值太小会要求猜大一些，如果猜的数值太大会要求猜小一些，最后列出猜了几次才答对。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112423088.png" alt="image-20201005112423088"></p><p>一般赌场的机器其实可以用随机数控制输赢，例如：某个猜大小机器，一般人以为猜对率是50%，但是只要控制随机数，赌场可以直接控制输赢比例。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112557560.png" alt="image-20201005112557560"></p><p>庄家可以在程序启动时先设定赢的比率。第2个关键点是程序产生的随机数，由1～100的随机数决定玩家是赢或输，猜大小只是幌子。例如，庄家刚开始设定赢的机率是80%，相当于如果随机数是在81～100的算玩家赢，如果随机数是1～80算玩家输。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112801874.png" alt="image-20201005112801874"></p><h4 id="choice"><a href="#choice" class="headerlink" title="choice()"></a>choice()</h4><p>这个方法可以在一个列表(list)中随机传回一个元素。</p><p>如有一个水果列表，使用choice( )方法随机选取一个水果。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005112940391.png" alt="image-20201005112940391"></p><h4 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle()"></a>shuffle()</h4><p>这个方法可以将列表元素重新排列，扑克牌(Porker)游戏，在发牌前可以使用这个方法将牌打乱重新排列。</p><p>如将列表内的扑克牌次序打乱，然后重新排列。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113123051.png" alt="image-20201005113123051"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113202439.png" alt="image-20201005113202439"></p><h2 id="时间time-模块"><a href="#时间time-模块" class="headerlink" title="时间time()模块"></a>时间time()模块</h2><h4 id="time"><a href="#time" class="headerlink" title="time()"></a>time()</h4><p>time( )方法可以传回自1970年1月1日00:00:00AM以来的秒数。</p><p>如计算自1970年1月1日00:00:00AM以来的秒数：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113510187.png" alt="image-20201005113510187"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113555999.png" alt="image-20201005113555999"></p><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><p>sleep( )方法可以让工作暂停，这个方法的参数单位是秒。</p><p>如每秒打印一次列表的内容：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113719219.png" alt="image-20201005113719219"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005113744430.png" alt="image-20201005113744430"></p><h4 id="asctime"><a href="#asctime" class="headerlink" title="asctime()"></a>asctime()</h4><p>这个方法会以可以阅读方式列出目前系统时间。</p><p>如列出目前系统的时间：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114056882.png" alt="image-20201005114056882"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114120954.png" alt="image-20201005114120954"></p><h4 id="localtime"><a href="#localtime" class="headerlink" title="localtime()"></a>localtime()</h4><p>这个方法可以返回目前时间的结构数据，所返回的结构可以用索引方式获得个别内容。</p><p>使用localtime( )方法列出目前时间的结构数据，同时使用索引列出个别内容。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114233599.png" alt="image-20201005114233599"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114337802.png" alt="image-20201005114337802"></p><h2 id="系统sys模块"><a href="#系统sys模块" class="headerlink" title="系统sys模块"></a>系统sys模块</h2><p>这个模块可以控制Python Shell窗口信息。</p><h4 id="version"><a href="#version" class="headerlink" title="version()"></a>version()</h4><p>这个属性可以列出目前所使用Python的版本信息。</p><h4 id="stdin对象"><a href="#stdin对象" class="headerlink" title="stdin对象"></a>stdin对象</h4><p>这是一个对象，stdin是standard input的缩写，是指从屏幕输入（可想成PythonShell窗口），这个对象可以搭配readline( )方法，然后可以读取屏幕输入直到按下Enter键的字符串。</p><p>如从屏幕读取8个字符数的应用：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114656329.png" alt="image-20201005114656329"></p><h4 id="stdout对象"><a href="#stdout对象" class="headerlink" title="stdout对象"></a>stdout对象</h4><p>这是一个对象，stdout是standard ouput的缩写，是指从屏幕输出（可想成Python Shell窗口），这个对象可以搭配write( )方法，然后可以从屏幕输出数据。</p><p>如使用stdout对象输出内容：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005114745601.png" alt="image-20201005114745601"></p><h2 id="keyword-模块"><a href="#keyword-模块" class="headerlink" title="keyword()模块"></a>keyword()模块</h2><p>这个模块有一些Python关键词的功能。</p><h4 id="kwlist属性"><a href="#kwlist属性" class="headerlink" title="kwlist属性"></a>kwlist属性</h4><p>这个属性含所有Python的关键词。</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005115247148.png" alt="image-20201005115247148"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E6%A8%A1%E5%9D%97/image-20201005115310167.png" alt="image-20201005115310167"></p><h4 id="iskeyword"><a href="#iskeyword" class="headerlink" title="iskeyword()"></a>iskeyword()</h4><p>这个方法可以传回参数的字符串是否是关键词，如果是传回True，如果否传回False。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础5</title>
    <link href="http://yoursite.com/2020/10/05/Python-%E5%9F%BA%E7%A1%805/"/>
    <id>http://yoursite.com/2020/10/05/Python-基础5/</id>
    <published>2020-10-05T02:27:18.000Z</published>
    <updated>2020-10-05T02:41:08.290Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>函数的语法格式如下：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003103823057.png" alt="image-20201003103823057"></p><p>函数名称 名称必须是唯一的，程序未来可以调用引用。</p><p>参数值可有可无的，完全视函数设计需要，可以接收调用函数传来的变量，各参数值之间是用逗号“,”隔开。</p><p>return [返回值1,返回值2 , … ]不论是return或接续右边的返回值皆是可有可无，如果有返回多个数据彼此需以逗号“,”隔开。</p><h4 id="函数的参数设计"><a href="#函数的参数设计" class="headerlink" title="函数的参数设计"></a>函数的参数设计</h4><p>在真实的函数设计与应用中大多是需要传递一些参数的。</p><p>如传递一个参数：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003152402426.png" alt="image-20201003152402426"></p><p>当所设计的函数需要传递多个参数，调用此函数时就需要特别留意传递参数的位置需要正确，最后才可以获得正确的结果。最常见的传递参数是数值或字符串数据。</p><p>如设计减法的函数subtract( )，第一个参数会减去第二个参数，然后列出执行结果。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003152522193.png" alt="image-20201003152522193"></p><p>关键词参数(keyword arguments)是指调用函数时，参数是用参数名称=值配对方式呈现。Python也允许在调用需传递多个参数的函数时，直接将参数名称=值用配对方式传送，这个时候参数的位置就不重要了。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003152806604.png" alt="image-20201003152806604"></p><h4 id="函数返回none"><a href="#函数返回none" class="headerlink" title="函数返回none"></a>函数返回none</h4><p>Python在直译时会自动返回处理成“return None”，相当于返回None。在一些程序语言，例如，C语言这个None就是NULL，None在Python中独立成为一个数据类型NoneType。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003153234774.png" alt="image-20201003153234774"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003153305754.png" alt="image-20201003153305754"></p><h4 id="函数返回数值"><a href="#函数返回数值" class="headerlink" title="函数返回数值"></a>函数返回数值</h4><p>参数具有返回值功能，将可以大大增加程序的可读性，返回的基本方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return result  #result就是返回的值</span><br></pre></td></tr></table></figure><p>使用return返回函数数据时，也允许返回多个数据，各个数据间只要以逗号隔开即可。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003155117536.png" alt="image-20201003155117536"></p><h4 id="函数返回字典数据"><a href="#函数返回字典数据" class="headerlink" title="函数返回字典数据"></a>函数返回字典数据</h4><p>函数除了可以返回数值或字符串数据外，也可以返回比较复杂的数据，例如，字典或列表等。</p><p>如调用时会输入VIP_ID编号和Name姓名数据，函数将返回所建立的字典数据：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003155456390.png" alt="image-20201003155456390"></p><h4 id="调用函数时参数是列表"><a href="#调用函数时参数是列表" class="headerlink" title="调用函数时参数是列表"></a>调用函数时参数是列表</h4><p>在调用函数时，也可以将列表（此列表可以是由数值、字符串或字典所组成）当参数传递给函数，然后函数可以遍历列表内容，然后执行更进一步的运作。</p><p>如函数遍历列表：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003155759704.png" alt="image-20201003155759704"></p><h4 id="传递任意数量的参数"><a href="#传递任意数量的参数" class="headerlink" title="传递任意数量的参数"></a>传递任意数量的参数</h4><p>在设计Python的函数时，有时候可能会碰上不知道会有多少个参数会传递到这个函数。</p><p>如建立一个冰淇淋的配料程序，一般冰淇淋可以在上面加上配料，这个程序在调用制作冰淇淋函数make_icecream( )时，可以传递0到多个配料，然后make_icecream( )函数会将配料结果的冰淇淋列出来。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003160237052.png" alt="image-20201003160237052"></p><h4 id="递归式函数设计recursive"><a href="#递归式函数设计recursive" class="headerlink" title="递归式函数设计recursive"></a>递归式函数设计recursive</h4><p>一个函数可以调用其他函数也可以调用自己，其中调用本身的动作称递归式(recursive)调用，递归式调用有下列特色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每次调用自己时，都会使范围越来越小。</span><br><span class="line"></span><br><span class="line">必须要有一个终止的条件来结束递归函数。</span><br></pre></td></tr></table></figure><p>递归函数最常见的应用是处理正整数的阶乘(factorial)，一个正整数的阶乘是所有小于以及等于该数的正整数的积，同时如果正整数是0则阶乘为1，依照观念正整数是1时阶乘也是1。此阶乘数字的表示法为n!。</p><p>如使用递归函数执行阶乘(factorial)运算：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003160601838.png" alt="image-20201003160601838"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003160632987.png" alt="image-20201003160632987"></p><p>上述factorial( )函数的终止条件是参数值为1的情况，由第4行判断然后返回1，下列是正整数为3时递归函数的示意：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003160741064.png" alt="image-20201003160741064"></p><h4 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h4><p>某个变量只有在该函数内使用，影响范围限定在这个函数内，这个变量称局部变量(local variable)。如果某个变量的影响范围是在整个程序，则这个变量称全局变量(global variable)。</p><p>Python程序在调用函数时会建立一个内存工作区间，在这个内存工作区间可以处理属于这个函数的变量，当函数工作结束，返回原先调用程序时，这个内存工作区间就被收回，原先存在的变量也将被销毁，这也是为何局部变量的影响范围只限定在所属的函数内。</p><p>一般在主程序内建立的变量称全局变量，这个变量程序内与本程序的所有函数皆可以引用。如设定一个全局变量，然后函数也可以调用引用：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003161110904.png" alt="image-20201003161110904"></p><p>全局变量与函数内的局部变量不要使用相同的名称，因为很容易造成混淆。如果全局变量与函数内的局部变量使用相同的名称，Python会将相同名称的区域与全局变量视为不同的变量，在局部变量所在的函数是使用局部变量内容，其他区域则是使用全局变量的内容。</p><p>如局部变量与全局变量定义了相同的变量msg，但是内容不相同。然后执行打印，可以发现在函数与主程序所打印的内容有不同的结果。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003161301240.png" alt="image-20201003161301240"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201003162247407.png" alt="image-20201003162247407"></p><h4 id="程序设计需要注意"><a href="#程序设计需要注意" class="headerlink" title="程序设计需要注意"></a>程序设计需要注意</h4><p>一般程序设计时有关使用局部变量需注意下列事项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部变量内容无法在其他函数引用.</span><br><span class="line"></span><br><span class="line">局部变量内容无法在主程序引用.</span><br></pre></td></tr></table></figure><h4 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h4><p>所谓的匿名函数(anonymous function)是指一个没有名称的函数，Python是使用def定义一般函数，匿名函数则是使用lambda来定义，有的人称之为lambda表达式，也可以将匿名函数称lambda函数。通常会将匿名函数与Python的内置函数filter( )、map( )等共同使用，此时匿名函数将只是这些函数的参数。</p><p>匿名函数最大特色是可以有许多的参数，但是只能有一个程序码表达式，然后可以将执行结果返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda arg1,arg2.... :expression  #arg1为参数，可以有多个参数</span><br></pre></td></tr></table></figure><p>单一参数的匿名函数应用，可以返回平方值：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004201336873.png" alt="image-20201004201336873"></p><p>含2个参数的匿名函数应用，可以返回参数的积：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004201451152.png" alt="image-20201004201451152"></p><h4 id="匿名函数使用与filter"><a href="#匿名函数使用与filter" class="headerlink" title="匿名函数使用与filter( )"></a>匿名函数使用与filter( )</h4><p>匿名函数一般是用在不需要函数名称的场合，例如，一些高阶函数(higher-orderfunction)的参数可能是函数，这时就很适合使用匿名函数，同时让程序变得更简洁。有一个内置函数filter( )，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(function,iterable)</span><br></pre></td></tr></table></figure><p>函数将依次对iterable(可以重复执行，例如，字符串string、列表list或元组tuple)的元素(item)放入function(item)内，然后将function( )函数执行结果是True的元素(item)组成新的筛选对象(filter object)返回。</p><h4 id="匿名函数使用与map"><a href="#匿名函数使用与map" class="headerlink" title="匿名函数使用与map( )"></a>匿名函数使用与map( )</h4><p>内置函数map( )，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(function,interable)</span><br></pre></td></tr></table></figure><p>函数将依次对iterable(可以重复执行，例如，字符串string、列表list或元组tuple)的元素(item)放入function(item)内，然后将function( )函数执行结果组成新的筛选对象(filter object)返回。</p><h2 id="类-面向对象程序"><a href="#类-面向对象程序" class="headerlink" title="类-面向对象程序"></a>类-面向对象程序</h2><p>Python其实是一种面向对象的编程(Object Oriented Programming)，在Python中其实所有的数据类型皆是对象，Python也允许程序设计师自创数据类型，这种自创的数据类型就是类。</p><p>设计程序时可以将世间万物分组归类，然后使用类(class)定义你的分类。</p><h4 id="类的定义及使用"><a href="#类的定义及使用" class="headerlink" title="类的定义及使用"></a>类的定义及使用</h4><p>类的语法定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class classname():    #类名称第一个字母必须大写</span><br><span class="line">  statement1</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>如对银行的类定义：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004202307701.png" alt="image-20201004202307701"></p><p>Banks是类名称，在这个类中定义了一个属性(attribute)title与一个方法(method)motto。</p><p>在类内定义方法(method)的方式与定义函数的方式相同，但是不可以称之为函数(function)，必须称之为方法(method)，在程序设计时我们可以随时调用函数，但是只有属于该类的对象(object)才可调用相关的方法。</p><h4 id="操作类的属性与方法"><a href="#操作类的属性与方法" class="headerlink" title="操作类的属性与方法"></a>操作类的属性与方法</h4><p>操作类的属性与方法首先需定义该类的对象(object)变量，使用下列方式操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.类的属性</span><br><span class="line">object.类的方法()</span><br></pre></td></tr></table></figure><h4 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h4><p>建立类很重要的一个工作是初始化整个类，所谓的初始化类是在类内建立一个初始化方法(method)，这是一个特殊方法，当在程序内定义这个类的对象时将自动执行这个方法。初始化方法有一个固定名称是“<strong>init</strong>( )”，写法是init左右皆是2个底线字符，init其实是initialization的缩写，通常又将这类初始化的方法称构造函数(constructor)。</p><p>如设定初始化方法，同时存第一笔开户的钱100元入银行，然后列出存款金额。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004202809117.png" alt="image-20201004202809117"></p><h4 id="类的访问权限-封装"><a href="#类的访问权限-封装" class="headerlink" title="类的访问权限-封装"></a>类的访问权限-封装</h4><p>类内的属性可以让外部引用的称公有(public)属性，而可以让外部引用的方法称公有方法。Python也提供一个私有属性与方法的观念，这个观念的主要精神是类外无法直接更改类内的私有属性，类外也无法直接调用私有方法，这个观念又称封装(encapsulation)。</p><p>Python对于类内的属性增加了私有属性(private attribute)的观念，应用方式是定义时在属性名称前面增加__(2个底线)，定义为私有属性后，类外的程序就无法引用了。</p><p>封装前：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203310489.png" alt="image-20201004203310489"></p><p>封装后：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203350625.png" alt="image-20201004203350625"></p><p>类有私有的属性，那么也有私有方法(private method)，它的观念与私有属性类似，类外的程序无法调用。至于定义方式与私有属性相同，只要在方法前面加上__(2个底线)符号即可。</p><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>在面向对象程序设计中类是可以继承的，其中被继承的类称父类(parent class)或基类(base class)，继承的类称子类(child class)或衍生类(derived class)。类继承的最大优点是许多父类的公有方法或属性，在子类中不用重新设计，可以直接引用。</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203553583.png" alt="image-20201004203553583"></p><p>在程序设计时，基类(base class)必须在衍生类(derived class)前面，整个程序代码结构如下：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203633339.png" alt="image-20201004203633339"></p><p>衍生类继承了基类的公有属性与方法，同时也可以有自己的属性与方法。</p><p>如Banks类建立一个分行Shilin_Banks，这个衍生类没有任何数据，直接引用基类的公有函数，执行银行的存款作业：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004203745811.png" alt="image-20201004203745811"></p><p>如何取得基类的私有属性？</p><p>基于保护原因，类外是无法直接取得类内的私有属性，即使是它的衍生类也无法直接读取，如果真要取得可以使用return方式，传回私有属性内容。</p><p>如衍生类对象取得基类的银行名称title的属性：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004204206862.png" alt="image-20201004204206862"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004204230275.png" alt="image-20201004204230275"></p><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>在面向对象的程序设计中，也常会发生一个类继承多个类的应用，此时子类也同时继承了多个类的方法。在这个时候，当多个父类拥有相同名称的方法时，应该先执行哪一个父类的方法。在程序中可用下列语法代表继承多个类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 类名称(父类1，父类2.....，父类n)</span><br><span class="line">      类内容</span><br></pre></td></tr></table></figure><h4 id="type与instance"><a href="#type与instance" class="headerlink" title="type与instance"></a>type与instance</h4><p>可以使用type( )函数得到某一对象变量的类。</p><p>isinstance( )函数可以传回对象的类是否属于某一类，它包含2个参数，它的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isinstance(对象，类)   #可传回True或False</span><br></pre></td></tr></table></figure><p>如果对象的类是属于第2个参数类或属于第2个参数的子类，则传回True，否则传回False。</p><h4 id="特殊属性-文档字符串doc"><a href="#特殊属性-文档字符串doc" class="headerlink" title="特殊属性-文档字符串doc"></a>特殊属性-文档字符串<em>doc</em></h4><p>若是遇到<strong>xx</strong>类的字符串就要特别留意了，这些大多数是特殊属性或方法。</p><p>文档字符串的英文原意是文档字符串(docstring)，Python鼓励程序设计师在设计函数或类时，尽量为函数或类增加文档的批注，未来可以使用<strong>doc</strong>特殊属性列出此文档批注。</p><p>如将文档批注应用在函数：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004205537211.png" alt="image-20201004205537211"></p><h4 id="特殊属性-name属性"><a href="#特殊属性-name属性" class="headerlink" title="特殊属性-name属性"></a>特殊属性-name属性</h4><p>在网络上看别人写的程序，一定会经常在程序末端看到下列叙述：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004205636412.png" alt="image-20201004205636412"></p><p>如果上述程序是自己执行，那么<strong>name</strong>就一定是<strong>main</strong>。如果被import到另一个程序，则<strong>name</strong>是本身的文件名。</p><p>总结就是<strong>name</strong>可以判别这个程序是自己执行或是被其他程序import导入当成模块使用。</p><h4 id="类的特殊方法–str–方法"><a href="#类的特殊方法–str–方法" class="headerlink" title="类的特殊方法–str–方法"></a>类的特殊方法–str–方法</h4><p>类的特殊方法，可以协助返回易读取的字符串。</p><p>如在定义<strong>str</strong>( )方法下，列出类的对象：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004210015409.png" alt="image-20201004210015409"></p><p>执行结果：</p><p><img src="/2020/10/05/Python-%E5%9F%BA%E7%A1%805/image-20201004210111832.png" alt="image-20201004210111832"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础4</title>
    <link href="http://yoursite.com/2020/10/02/Python-%E5%9F%BA%E7%A1%804/"/>
    <id>http://yoursite.com/2020/10/02/Python-基础4/</id>
    <published>2020-10-02T07:15:33.000Z</published>
    <updated>2020-10-02T12:18:59.604Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h2 id="循环设计"><a href="#循环设计" class="headerlink" title="循环设计"></a>循环设计</h2><h4 id="基本for循环"><a href="#基本for循环" class="headerlink" title="基本for循环"></a>基本for循环</h4><p>for循环可以让程序将整个对象内的元素遍历(也可以称迭代)，在遍历期间，同时可以纪录或输出每次遍历的状态或称轨迹。for循环基本语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for var in 可迭代对象：</span><br><span class="line">    程序代码</span><br><span class="line">#将可迭代对象的元素当作var，重复执行，直到每个元素皆被执行一次，整个循环才会停止。</span><br></pre></td></tr></table></figure><p>可迭代对象(iterable object)可以是列表、元组、字典与集合或range( )，</p><p>如列出球员名称：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002152630616.png" alt="image-20201002152630616"></p><p>执行结果：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002152709207.png" alt="image-20201002152709207"></p><p>循环的流程示意图：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002152754322.png" alt="image-20201002152754322"></p><h4 id="for循环应用在列表"><a href="#for循环应用在列表" class="headerlink" title="for循环应用在列表"></a>for循环应用在列表</h4><p>Python也允许将for循环应用在截取区间列表元素上。</p><p>如列出列表前3和后三球员的名称：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002153012619.png" alt="image-20201002153012619"></p><p>tip：升幂是指由小到大排列。降幂是指由大到小排列。</p><h4 id="for循环应用在数据类别的判断"><a href="#for循环应用在数据类别的判断" class="headerlink" title="for循环应用在数据类别的判断"></a>for循环应用在数据类别的判断</h4><p>如有一个files列表内含一系列文件名，请将“.py”的Python程序另外建立到py列表，然后打印。</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002153355995.png" alt="image-20201002153355995"></p><h4 id="for循环删除列表内所有元素"><a href="#for循环删除列表内所有元素" class="headerlink" title="for循环删除列表内所有元素"></a>for循环删除列表内所有元素</h4><p>Python没有提供删除整个列表元素的方法，不过我们可以使用for循环完成此工作。</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002153514307.png" alt="image-20201002153514307"></p><h4 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h4><p>Python可以使用range( )函数产生一个等差序列，称这等差序列为可迭代对象(iterable object)，也可以称是range对象。由于range( )是产生等差序列，可以将此等差序列当作循环的计数器。</p><p>range的用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(start,stop,step)</span><br></pre></td></tr></table></figure><p>stop是唯一必须的值，等差序列是产生stop的前一个值。</p><p>当range(n)函数搭配一个参数时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(n) # 将产生0，1，...，n-1的可迭代对象内容</span><br></pre></td></tr></table></figure><h4 id="嵌套for循环"><a href="#嵌套for循环" class="headerlink" title="嵌套for循环"></a>嵌套for循环</h4><p>如果外循环要执行n次，内循环要执行m次，则整个循环执行的次数是n*m次，设计这类循环时要特别注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外层循环的索引值与内层循环的索引值必须不同</span><br><span class="line">程序代码的内缩一定要小心</span><br></pre></td></tr></table></figure><p>嵌套循环基本语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 对象：</span><br><span class="line">    ....</span><br><span class="line">    for 变量 in 对象：</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>如打印9*9乘法表</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002154711352.png" alt="image-20201002154711352"></p><p>执行结果：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002154746535.png" alt="image-20201002154746535"></p><h4 id="结束循环break"><a href="#结束循环break" class="headerlink" title="结束循环break"></a>结束循环break</h4><p>某些条件发生时可以离开循环，可以在循环内执行break指令，即可立即离开循环，这个指令通常是和if语句配合使用。下列是常用的语法格式：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002154918808.png" alt="image-20201002154918808"></p><p>流程图如下：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002154955490.png" alt="image-20201002154955490"></p><h4 id="循环暂时停止continue"><a href="#循环暂时停止continue" class="headerlink" title="循环暂时停止continue"></a>循环暂时停止continue</h4><p>某些条件发生时可以不往下执行循环内容，此时可以用continue指令，这个指令通常是和if语句配合使用。下列是常用的语法格式：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155121884.png" alt="image-20201002155121884"></p><p>流程图如下：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155156087.png" alt="image-20201002155156087"></p><h4 id="for-else循环"><a href="#for-else循环" class="headerlink" title="for else循环"></a>for else循环</h4><p>如果期待所有的if叙述条件是False时，在最后一次循环后，可以执行特定程序区块指令，这个指令通常是和if和break语句配合使用。下列是常用的语法格式：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155330311.png" alt="image-20201002155330311"></p><p> 流程图如下：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155405810.png" alt="image-20201002155405810"></p><p>如数学中测试某一个数字n是否是质数，质数的条件是：</p><p>2是质数，n不可被2至n-1的数字整除。</p><p>如果所输入的数字是质数则列出是质数，否则列出不是质数。</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155555414.png" alt="image-20201002155555414"></p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>一直执行直到条件运算为False才会离开循环，所以设计while循环时一定要设计一个条件可以离开循环，相当于让循环结束。程序设计时，如果忘了设计条件可以离开循环，程序造成无限循环状态。</p><p>语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 条件运算：</span><br><span class="line">   程序区块</span><br></pre></td></tr></table></figure><p>while语法流程图：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155746278.png" alt="image-20201002155746278"></p><p>如猜数字游戏，程序用变量answer存储欲猜的数字，程序执行时用变量guess存储所猜的数字：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002155850070.png" alt="image-20201002155850070"></p><h4 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h4><p>pass指令是什么事也不做，如果想要建立一个无限循环可以使用下列写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">   pass</span><br></pre></td></tr></table></figure><h2 id="元组Tuple"><a href="#元组Tuple" class="headerlink" title="元组Tuple"></a>元组Tuple</h2><p>Python提供一种数据类型称元组(tuple)，这种数据类型结构与列表完全相同，但是它与列表最大的差异是，它的元素值与元素个数不可更改。</p><h4 id="元组的定义"><a href="#元组的定义" class="headerlink" title="元组的定义"></a>元组的定义</h4><p>列表在定义时是将元素放在中括号内，元组的定义则是将元素放在小括号“( )”内，元组的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple_1 &#x3D; (元素1，元素2....)</span><br><span class="line"></span><br><span class="line">tuple2&#x3D;(元素1，) #只有一个元素的元组</span><br></pre></td></tr></table></figure><p>元组的每一个数据称元素，元素可以是整数、字符串或列表等，这些元素放在小括号( )内，彼此用逗号“,”隔开。如果要打印元组内容，可以用print( )函数，将元组名称当作变量名称即可。</p><h4 id="读取元组数据"><a href="#读取元组数据" class="headerlink" title="读取元组数据"></a>读取元组数据</h4><p>定义元组时是使用小括号“( )”，如果想要读取元组内容，和列表是一样的，用中括号“[ ]”。在Python中元组元素是从索引值0开始配置。所以如果是元组的第一个元素，索引值是0，第二个元素索引值是1。</p><p>语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple1[i] #读取索引i的元组元素</span><br></pre></td></tr></table></figure><h4 id="遍历元组数据"><a href="#遍历元组数据" class="headerlink" title="遍历元组数据"></a>遍历元组数据</h4><p>在Python可以使用for循环遍历所有元组元素。</p><p>如假设元组是由字符串和数值组成的密码：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002163223009.png" alt="image-20201002163223009"></p><h4 id="重新定义元组"><a href="#重新定义元组" class="headerlink" title="重新定义元组"></a>重新定义元组</h4><p>如果想要修改元组元素，可以使用重新定义元组方式处理。</p><p>如用重新定义方式修改元组元素内容：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002163611561.png" alt="image-20201002163611561"></p><h4 id="元组切片"><a href="#元组切片" class="headerlink" title="元组切片"></a>元组切片</h4><p>元组切片观念与列表切片观念相同。</p><p>元组切片的应用：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002163846961.png" alt="image-20201002163846961"></p><h4 id="方法与函数"><a href="#方法与函数" class="headerlink" title="方法与函数"></a>方法与函数</h4><p>应用在列表上的方法或函数如果不会更改元组内容，则可以将它应用在元组，如len( )。如果会更改元组内容，则不可以将它应用在元组，如append( )、insert( )或pop( )。</p><p>如列出元组元素长度（个数）:</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002164045777.png" alt="image-20201002164045777"></p><h4 id="列表与元组数据互换"><a href="#列表与元组数据互换" class="headerlink" title="列表与元组数据互换"></a>列表与元组数据互换</h4><p>有需要将列表(list)与元组(tuple)数据类型互换，可以使用下列指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list():将元组数据类型改为列表</span><br><span class="line"></span><br><span class="line">tuple():将列表数据类型改为元组</span><br></pre></td></tr></table></figure><p>获取最大值、最小值：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002164525223.png" alt="image-20201002164525223"></p><h4 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h4><p>这是一个内置函数，参数内容主要是可迭代(iterable)的对象，如列表等。然后将相对应的元素打包成元组(tuple)，最后传给zip对象，可以使用list( )函数将zip对象转成列表。</p><p>zip的应用：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002164842327.png" alt="image-20201002164842327"></p><p>执行结果：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002164912719.png" alt="image-20201002164912719"></p><p>如果在zip( )函数内增加“*”符号，相当于可以unzip( )列表。</p><p>如恢复zip前的列表：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002165030151.png" alt="image-20201002165030151"></p><p>执行结果：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002165054580.png" alt="image-20201002165054580"></p><h4 id="元组的优点"><a href="#元组的优点" class="headerlink" title="元组的优点"></a>元组的优点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以更安全的保护数据。</span><br><span class="line">加快程序的执行速度，元组(tuple)结构比列表(list)简单，占用较少的系统资源，程序执行时速度比较快。</span><br></pre></td></tr></table></figure><h2 id="字典Dict"><a href="#字典Dict" class="headerlink" title="字典Dict"></a>字典Dict</h2><p>列表(list)与元组(tuple)是依序排列是序列数据结构，只要知道元素的特定位置，即可使用索引观念取得元素内容。字典并不是依序排列的数据结构，通常可称是非序列数据结构，所以无法使用类似列表的数值(0, 1, … n)索引观念取得元素内容。</p><h4 id="定义字典"><a href="#定义字典" class="headerlink" title="定义字典"></a>定义字典</h4><p>字典也是一个列表型的数据结构，但是它的元素是用“键-值”方式配对存储，在操作时是用键(key)取得值(value)的内容。定义字典时，是将键-值放在大括号“{}”内，字典的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict_1 &#x3D; &#123;键1:值1,.....,键n:值n&#125;</span><br></pre></td></tr></table></figure><p>字典的值(value)可以是任何Python的对象，可以是数值、字符串、列表等</p><h4 id="列出字典元素的值"><a href="#列出字典元素的值" class="headerlink" title="列出字典元素的值"></a>列出字典元素的值</h4><p>字典的元素是“键-值”配对设定，如果想要取得元素的值，可以将键当作是索引方式处理，因此字典内的元素不可有重复的键。</p><p>传回键值的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fruits[&#39;水蜜桃&#39;]  #用字典变量[&#39;键&#39;]取得值</span><br></pre></td></tr></table></figure><h4 id="增加字典元素"><a href="#增加字典元素" class="headerlink" title="增加字典元素"></a>增加字典元素</h4><p>可使用下列语法格式增加字典元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict_1 [键] &#x3D; 值 #dict_1为字典变量</span><br></pre></td></tr></table></figure><p>如为fruits字典增加橘子一斤18元：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002170216824.png" alt="image-20201002170216824"></p><h4 id="删除字典特定元素"><a href="#删除字典特定元素" class="headerlink" title="删除字典特定元素"></a>删除字典特定元素</h4><p>删除字典的特定元素的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del  dict_1[键] #删除特定键的元素</span><br></pre></td></tr></table></figure><h4 id="删除所有字典元素"><a href="#删除所有字典元素" class="headerlink" title="删除所有字典元素"></a>删除所有字典元素</h4><p>Python有提供方法clear( )可以将字典的所有元素删除，此时字典仍然存在，不过将变成空的字典。</p><p>如删除fruits字典的所有元素：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002170528529.png" alt="image-20201002170528529"></p><p>Python也有提供del指令可以将整个字典删除，字典一经删除就不再存在。它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del dict_1</span><br></pre></td></tr></table></figure><p>在程序设计时，也允许先建立一个空字典，建立空字典的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict_2 &#x3D;&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="字典的复制"><a href="#字典的复制" class="headerlink" title="字典的复制"></a>字典的复制</h4><p>为了要保护原先字典内容，常会需要将字典复制，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_dict &#x3D; dict_1.copy()</span><br></pre></td></tr></table></figure><p>上述所复制的字典是独立存在新地址的字典。</p><h4 id="取得字典元素的数量"><a href="#取得字典元素的数量" class="headerlink" title="取得字典元素的数量"></a>取得字典元素的数量</h4><p>在列表(list)或元组(tuple)使用的方法len( )也可以应用在字典，它的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length&#x3D; len(dict_1)</span><br></pre></td></tr></table></figure><p>可以用下列语法验证元素是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">键 in dict_1 #验证键元素是否存在</span><br></pre></td></tr></table></figure><h4 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h4><p>1.遍历字典的键-值</p><p>Python有提供方法items( )，可以让我们取得字典键-值配对的元素：</p><p>如使用for循环加items()方法</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002171650626.png" alt="image-20201002171650626"></p><p>2.遍历字典的键</p><p>不想要取得字典的值(value)，只想要键(keys)，Python有提供方法keys( )，可以取得字典的键内容。</p><p>3.遍历字典的值</p><p>Python有提供方法values( )，可以取得字典值列表。</p><p>如使用for循环加上values( )方法取得字典的值：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002172037258.png" alt="image-20201002172037258"></p><p>在字典的应用中键不可有重复，值是可以重复。</p><h4 id="字典内含列表元素"><a href="#字典内含列表元素" class="headerlink" title="字典内含列表元素"></a>字典内含列表元素</h4><p>在Python的应用中也允许将列表放在字典内，这时列表将是字典某键的值。如果想要遍历这类数据结构，需要使用嵌套循环和字典的方法items( )，外层循环是取得字典的键，内层循环则是将含列表的值拆解。</p><p>如定义内含字符串的字典，然后再拆解打印：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002172510824.png" alt="image-20201002172510824"></p><h4 id="字典常用函数和方法"><a href="#字典常用函数和方法" class="headerlink" title="字典常用函数和方法"></a>字典常用函数和方法</h4><p>len():可以列出字典元素的个数。</p><p>get():搜寻字典的键，如果键存在则传回该键的值，如果不存在则传回默认值，ret_value = dict.get(key),default=none。</p><p>fromkeys():建立字典的一个方法。</p><p>setdefault()方法基本上与get( )相同，不同之处在于get( )方法不会改变字典内容。使用setdefault( )方法时若所搜寻的键不在，会将键-值加入字典，如果有设定默认值则将键:默认值加入字典，如果没有设定默认值则将键:None加入字典。</p><p>pop(): 这个方法可以删除字典元素，它的语法格式如下：</p><p>ret.value = dict.pop(key)</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合的基本观念是无序且每个元素是唯一的，集合元素的内容是不可变的(immutable)，常见的元素有整数(intger)、浮点数(float)、字符串(string)、元组(tuple)等。至于可变(mutable)内容列表(list)、字典(dict)、集合(set)等不可以是集合元素。</p><h4 id="建立集合"><a href="#建立集合" class="headerlink" title="建立集合"></a>建立集合</h4><p>Python可以使用大括号“{ }”或set( )函数建立集合。</p><p>Python允许我们直接使用大括号“{ }”设定集合，如：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174052833.png" alt="image-20201002174052833"></p><p>集合的特色是元素是唯一的，所以如果设定集合时有重复元素情形，多的部分将被舍去。</p><p>可以使用内置的set( )函数建立集合，set( )函数参数的内容可以是字符串(string)、列表(list)、元组(tuple)等。这时原先字符串(string)、列表(list)、元组(tuple)的元素将被转成集合元素。</p><p>如使用set( )函数建立空集合：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174250783.png" alt="image-20201002174250783"></p><h4 id="大数据与集合的应用"><a href="#大数据与集合的应用" class="headerlink" title="大数据与集合的应用"></a>大数据与集合的应用</h4><p>在海量数据中将重复的数据删除，只要将列表数据使用set( )函数转为集合数据，再使用list( )函数将集合数据转为列表数据就可以了。</p><p>如将列表内重复性的数据删除：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174548719.png" alt="image-20201002174548719"></p><p>执行结果：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174628978.png" alt="image-20201002174628978"></p><h4 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h4><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174706619.png" alt="image-20201002174706619"></p><h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><p>在Python语言的交集符号是“&amp;”，另外，也可以使用intersection( )方法完成这个工作。</p><p>如有数学与物理2个夏令营，这个程序会列出同时参加这2个夏令营的成员：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174821819.png" alt="image-20201002174821819"></p><h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><p>在Python语言的并集符号是“|”，另外，也可以使用union( )方法完成这个工作。</p><p>如有数学与物理2个夏令营，这个程序会列出参加这2个夏令营的所有成员：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002174939938.png" alt="image-20201002174939938"></p><h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><p>有A和B两个集合，如果想获得属于A集合元素，同时不属于B集合则可以使用差集(A-B)。如果想获得属于B集合元素，同时不属于A集合则可以使用差集(B-A)。</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175319303.png" alt="image-20201002175319303"></p><p>在Python语言的差集符号是“-”，另外，也可以使用difference( )方法完成这个工作。</p><p>如有数学与物理2个夏令营，列出参加数学夏令营但是没有参加物理夏令营的所有成员。列出参加物理夏令营但是没有参加数学夏令营的所有成员：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175158969.png" alt="image-20201002175158969"></p><p>使用difference( )方法完成A-B差集与B-A差集的应用：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175247473.png" alt="image-20201002175247473"></p><h4 id="对称差集"><a href="#对称差集" class="headerlink" title="对称差集"></a>对称差集</h4><p>有A和B两个集合，如果想获得属于A或是B集合元素，但是排除同时属于A和B的元素，则可以使用对称差集。</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175414485.png" alt="image-20201002175414485"></p><p>在Python语言的对称差集符号是“^”，另外，也可以使用symmetric_difference( )方法完成。</p><p>如有数学与物理2个夏令营，列出参加数学夏令营或参加物理夏令营，但是排除同时参加2个夏令营的所有成员：</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175517327.png" alt="image-20201002175517327"></p><h4 id="等于和不等于"><a href="#等于和不等于" class="headerlink" title="等于和不等于"></a>等于和不等于</h4><p>等于的Python符号是“==”，可以得知2个集合是否相等，如果相等传回True，否则传回False。</p><p>不等于的Python符号是“!=”，可以得知2个集合是否不相等，如果不相等传回True，否则传回False。</p><h4 id="是成员in与不是成员"><a href="#是成员in与不是成员" class="headerlink" title="是成员in与不是成员"></a>是成员in与不是成员</h4><p>Python的关键词in可以测试元素是否是集合的元素成员。</p><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175718711.png" alt="image-20201002175718711"></p><p>Python的关键词not in可以测试元素是否不是集合的元素成员。</p><h4 id="适合集合的方法"><a href="#适合集合的方法" class="headerlink" title="适合集合的方法"></a>适合集合的方法</h4><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002175835796.png" alt="image-20201002175835796"></p><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><p>add( )可以增加一个元素，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合A.add(新增元素)</span><br></pre></td></tr></table></figure><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><p>集合复制像列表复制一样，有深复制(deep copy)与浅复制(shallowcopy)，这个方法不需参数，语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新集合名称 &#x3D; 旧集合名称.copy()</span><br></pre></td></tr></table></figure><p>copy( )是浅复制，经过复制后未来一个集合内容改变时，不会影响到另一个集合的内容。</p><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>如果指定删除的元素存在集合内，remove( )可以删除这个集合元素；如果指定删除的元素不存在集合内，将有KeyError产生。它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合A.remove(欲删除的元素)</span><br></pre></td></tr></table></figure><h4 id="discard"><a href="#discard" class="headerlink" title="discard()"></a>discard()</h4><p>discard( )可以删除集合的元素，如果元素不存在也不会有错误产生。语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retvalue &#x3D; 集合A.discard(欲删除的元素)</span><br></pre></td></tr></table></figure><p>会将集合A内，discard( )参数指定的元素删除。不论删除结果为何，这个方法会传回None。</p><h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p>pop( )是用随机方式删除集合元素，所删除的元素将被传回，如果集合是空集合则程序会产生TypeError错误。</p><p>使用格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret &#x3D; 集合A.pop()</span><br></pre></td></tr></table></figure><p>会随机删除集合A内的元素，所删除的元素将被传回ret_element。</p><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p>clear会删除集合内所有元素，传回值是None。</p><h4 id="两个集合间"><a href="#两个集合间" class="headerlink" title="两个集合间"></a>两个集合间</h4><p>isdisjoint( )：</p><p>如果2个集合没有共同的元素会传回True，否则传回False。用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret_bolan &#x3D; 集合A.isdisjoint(集合B)</span><br></pre></td></tr></table></figure><p>issubset():</p><p>这个方法可以测试一个函数是否是另一个函数的子集合，例如，A集合所有元素均可在B集合内发现，则A集合是B集合的子集合。如果是则传回True，否则传回False。</p><p>用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret_bolan &#x3D; 集合A.issubset(集合B)</span><br></pre></td></tr></table></figure><p>issuperset():</p><p>这个方法可以测试一个函数是否是另一个函数的父集合，例如，B集合所有元素均可在A集合内发现，则A集合是B集合的父集合。如果是则传回True，否则传回False。</p><p>intersection update( ):</p><p>这个方法将传回集合的交集，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret &#x3D; A.intersection_update(*B):</span><br></pre></td></tr></table></figure><p>上述<em>B代表可以有1到多个集合，如果只有一个集合，例如是B，则执行后A将是A与B的交集。如果</em>B代表(B, C)，则执行后A将是A、B与C的交集。</p><p>update():</p><p>可以将一个集合的元素加到调用此方法的集合内，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合A.update(集合B)  #将集合B的元素加到集合A内</span><br></pre></td></tr></table></figure><p>difference update():</p><p>可以删除集合内与另一集合重复的元素，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">集合A.difference update(集合B)  #集合A内与集合B重复的元素删除，结果存在A集合</span><br></pre></td></tr></table></figure><h4 id="适用于集合的基本函数操作"><a href="#适用于集合的基本函数操作" class="headerlink" title="适用于集合的基本函数操作"></a>适用于集合的基本函数操作</h4><p><img src="/2020/10/02/Python-%E5%9F%BA%E7%A1%804/image-20201002201804967.png" alt="image-20201002201804967"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础3</title>
    <link href="http://yoursite.com/2020/09/25/Python-%E5%9F%BA%E7%A1%803/"/>
    <id>http://yoursite.com/2020/09/25/Python-基础3/</id>
    <published>2020-09-25T13:10:14.000Z</published>
    <updated>2020-10-02T07:20:36.064Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="程序流程控制if"><a href="#程序流程控制if" class="headerlink" title="程序流程控制if"></a>程序流程控制if</h2><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>Python语言所使用的关系运算符表：</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925211445336.png" alt="image-20200925211445336"></p><p>运算如果是真会传回True，如果是伪会传回False。</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>Python所使用的逻辑运算符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">and ---相当于逻辑符号AND</span><br><span class="line"></span><br><span class="line">or ---相当于逻辑符号OR</span><br><span class="line"></span><br><span class="line">not ---相当于逻辑符号NOT</span><br></pre></td></tr></table></figure><p>逻辑运算符and的图例说明:</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925211707974.png" alt="image-20200925211707974"></p><p>逻辑运算符or的图例说明:</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925211743164.png" alt="image-20200925211743164"></p><p>逻辑运算符not的图例说明:</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925211824495.png" alt="image-20200925211824495"></p><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>if语句的基本语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(条件判断)：</span><br><span class="line"> 程序代码</span><br></pre></td></tr></table></figure><p>流程图：</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925212035174.png" alt="image-20200925212035174"></p><p>在Python内是使用内缩方式区隔if语句的程序代码区块，编辑程序时可以用Tab键内缩或是直接内缩4个字符空间，表示这是if语句的程序代码区块。</p><h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h4><p>条件判断为True时执行某一个程序代码区块，当条件判断为False时执行另一段程序代码区块，此时可以使用if … else语句，它的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(条件为真)：</span><br><span class="line">程序代码区块1</span><br><span class="line">else：</span><br><span class="line">程序代码区块2</span><br></pre></td></tr></table></figure><p>流程图：</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925214652836.png" alt="image-20200925214652836"></p><h4 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if  elif  else语句"></a>if  elif  else语句</h4><p>这是一个多重判断，基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(条件判断1)：</span><br><span class="line">程序代码区块1</span><br><span class="line">elif(条件判断2):</span><br><span class="line">程序代码区块2</span><br><span class="line">else：</span><br><span class="line">程序代码块n</span><br></pre></td></tr></table></figure><p>流程图：</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925215242142.png" alt="image-20200925215242142"></p><h4 id="嵌套的if语句"><a href="#嵌套的if语句" class="headerlink" title="嵌套的if语句"></a>嵌套的if语句</h4><p>嵌套的if语句是指在if语句内有其他的if语句，如：</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925215606572.png" alt="image-20200925215606572"></p><h2 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h2><p>列表(list)是Python的一种可以更改内容的数据类型，它是由一系列元素所组成的序列。</p><p>定义列表的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_list&#x3D;[元素1，元素2.....，元素n]</span><br></pre></td></tr></table></figure><p>列表的每一个数据称元素，这些元素放在中括号[ ]内，彼此用逗号“,”隔开。如果要打印列表内容，可以使用print( )函数，将列表名称当作变量名称即可。</p><h4 id="读取列表元素"><a href="#读取列表元素" class="headerlink" title="读取列表元素"></a>读取列表元素</h4><p>可以用列表名称与索引读取列表元素的内容，在Python中元素是从索引值0开始配置。所以如果是列表的第一个元素，索引值是0，第二个元素索引值是1，其他依此类推，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_list&#x3D;[i]  #读取索引i的列表元素</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jame&#x3D;[12,13,14,15,16]</span><br><span class="line">game1,game2,game3,game4,game5&#x3D;jame</span><br><span class="line">print(&quot;jame得分&quot;,game1,game2,game3,game4,game5)</span><br></pre></td></tr></table></figure><h4 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h4><p>常会需要取得列表前几个元素、后几个元素、某区间元素或是依照一定规则排序的元素，所取得的系列元素也可称子列表，这个观念称列表切片。可以用下列方法：</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20200925222934240.png" alt="image-20200925222934240"></p><p>在列表使用中，如果索引值是-1，代表是最后一个列表元素。</p><p>在Python中索引-1代表最后1个元素，-2代表最后第2个元素，其他负索引观念可依次类推。</p><h4 id="列表统计最大、最小、总和"><a href="#列表统计最大、最小、总和" class="headerlink" title="列表统计最大、最小、总和"></a>列表统计最大、最小、总和</h4><p>如果列表内容全部是数值则可以使用max( )函数获得列表的最大值，min( )函数可以获得列表的最小值，sum( )函数可以获得列表的总和。如果列表内容全部是字符或字符串则可以使用max( )函数获得列表的unicode码值的最大值，min( )函数可以获得列表的unicode码值最小值。sum( )则不可使用在列表元素为非数值情况。</p><h4 id="列表个数len"><a href="#列表个数len" class="headerlink" title="列表个数len"></a>列表个数len</h4><p>len( )函数可以获得列表的元素个数。</p><h4 id="列表相加"><a href="#列表相加" class="headerlink" title="列表相加"></a>列表相加</h4><p>Python是允许列表相加的，相当于将列表结合。</p><p>如果将列表以一个数字，这个数字相当于是列表元素重复次数。</p><h4 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h4><p>删除指定索引的列表元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del name_list[i]  #删除索引i的列表元素</span><br></pre></td></tr></table></figure><p>删除列表区间元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del name_list[start:end] #删除从索引start到end-1索引的列表元素</span><br></pre></td></tr></table></figure><p>用step作为每隔多少区间再删除:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del name_list[start:end:step]  #每隔step步，删除所有start到end-1</span><br></pre></td></tr></table></figure><p>建立一个空列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_list&#x3D;[]</span><br></pre></td></tr></table></figure><h4 id="删除列表"><a href="#删除列表" class="headerlink" title="删除列表"></a>删除列表</h4><p>Python允许我们删除整个列表，列表一经删除后就无法复原，同时也无法做任何操作了，删除列表的方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del name_list #删除列表name_list</span><br></pre></td></tr></table></figure><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>在面向对象的程序设计(Object Oriented Programming)观念里，所有数据皆算是一个对象(Object)，例如，整数、浮点数、字符串或是本章所提的列表皆是一个对象。可以为所建立的对象设计一些方法(method)，供这些对象使用，在这里所提的方法就是函数。</p><p>Python有为一些基本对象提供默认的方法，要使用这些方法可以在对象后先放小数点，再放方法名称，基本语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.方法()</span><br></pre></td></tr></table></figure><p>字符串操作常用的方法(method)如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lower( )：将字符串转成小写</span><br><span class="line"></span><br><span class="line">upper( )：将字符串转成大写</span><br><span class="line"></span><br><span class="line">title( )：将字符串转成第一个字母大写，其他是小写</span><br><span class="line"></span><br><span class="line">rstrip( )：删除字符串尾端多余的空白</span><br><span class="line"></span><br><span class="line">lstrip( )：删除字符串开始端多余的空白</span><br><span class="line"></span><br><span class="line">strip( )：删除字符串头尾两边多余的空白</span><br></pre></td></tr></table></figure><h4 id="增加与删除列表元素"><a href="#增加与删除列表元素" class="headerlink" title="增加与删除列表元素"></a>增加与删除列表元素</h4><p>在列表末端增加元素append( )：</p><p>Python为列表内置了新增元素的方法append( )，这个方法，可以在列表末端直接增加元素。方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namelist.append(&#39;新增元素&#39;)</span><br></pre></td></tr></table></figure><p>插入列表元素insert( )：</p><p>append( )方法是固定在列表末端插入元素，insert( )方法则是可以在任意位置插入元素，它的使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert(索引，元素内容) #索引是插入位置，元素内容是插入内容</span><br></pre></td></tr></table></figure><p>删除列表元素pop():</p><p>pop( )方法删除元素最大的优点是，删除后将弹出所删除的值，使用pop( )时若是未指明所删除元素的位置，一律删除列表末端的元素。pop( )的使用方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value&#x3D;namelist.pop()  #没有索引是删除列表末端的元素</span><br><span class="line">value&#x3D;namelist.pop(i)  #删除指定索引值的列表元素</span><br></pre></td></tr></table></figure><p>删除指定元素remove():</p><p>在删除列表元素时，有时可能不知道元素在列表内的位置，此时可以使用remove()方法删除指定的元素，它的使用方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namelist.remove(想删除的元素内容)</span><br></pre></td></tr></table></figure><h4 id="列表的排序"><a href="#列表的排序" class="headerlink" title="列表的排序"></a>列表的排序</h4><p>颠倒排序reverse( )：</p><p>reverse( )可以颠倒排序列表元素，它的使用方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namelist.reverse()  #颠倒namlist中的列表元素</span><br></pre></td></tr></table></figure><p>列表经颠倒排放后，就算永久性更改了，如果要复原，可以再执行一次reverse( )方法。</p><p>sort( )排序：</p><p>sort( )方法可以对列表元素由小到大排序，这个方法同时对纯数值元素与纯英文字符串元素有非常好的效果。需要注意的是，经排序后原列表的元素顺序会被永久更改。它的使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namelist.sort()</span><br></pre></td></tr></table></figure><p>sorted( )排序:</p><p>如果不希望更改列表元素顺序，可以使用另一种排序sorted( )，使用这个排序可以获得想要的排序结果，我们可以用新列表存储新的排序列表，同时原先列表的顺序将不更改。它的使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newlist.sorted(namelist)</span><br></pre></td></tr></table></figure><h4 id="列表操作index"><a href="#列表操作index" class="headerlink" title="列表操作index"></a>列表操作index</h4><p>index可以返回特定元素内容第一次出现的索引值，它的使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引值&#x3D;列表名称.index(搜寻值)</span><br></pre></td></tr></table></figure><h4 id="列表操作count"><a href="#列表操作count" class="headerlink" title="列表操作count"></a>列表操作count</h4><p>可以返回特定元素内容出现的次数，它的使用格式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">次数&#x3D;列表名称.count(搜寻值)</span><br></pre></td></tr></table></figure><h4 id="列表操作join"><a href="#列表操作join" class="headerlink" title="列表操作join"></a>列表操作join</h4><p>这个方法可以将列表的元素组成一个字符串，它的使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char.join(seq)</span><br></pre></td></tr></table></figure><p>seq表示参数必须为列表、元组等序列数据，char则是组合后各元素间的分隔字符，可以是单一字符，也可以是字符串。</p><h4 id="列表内含列表"><a href="#列表内含列表" class="headerlink" title="列表内含列表"></a>列表内含列表</h4><p>列表内含列表的基本格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num&#x3D;[1,2,3,4,[7,8,9]]</span><br></pre></td></tr></table></figure><p>num是一个列表，在这个列表内有另一个列表[7, 8, 9]，因为内部列表的索引值是5，所以可以用num[5]，获得这个元素列表的内容.</p><p><img src="/2020/09/25/Python-%E5%9F%BA%E7%A1%803/image-20201002150307424.png" alt="image-20201002150307424"></p><p>想要存取列表内的列表元素，可以使用下列格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num[索引1][索引2]</span><br></pre></td></tr></table></figure><p>索引1是元素列表原先索引位置，索引2是元素列表内部的索引。</p><h4 id="列表的深复制"><a href="#列表的深复制" class="headerlink" title="列表的深复制"></a>列表的深复制</h4><p>只要有一个列表更改元素会影响到另一个列表同步更改的复制称深复制(deep copy)。</p><p>假设我喜欢的运动是，篮球与棒球，可以用下列方式设定列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysports&#x3D;[&#39;football&#39;，‘baseetball’]</span><br></pre></td></tr></table></figure><p>如果我的朋友也喜欢这2种运动，可以下列方式设定列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friedsports&#x3D;mysports</span><br></pre></td></tr></table></figure><h4 id="列表的浅复制-shallow-copy"><a href="#列表的浅复制-shallow-copy" class="headerlink" title="列表的浅复制-shallow copy"></a>列表的浅复制-shallow copy</h4><p>浅复制(shallow copy)观念是，执行复制后当一个列表改变后，不会影响另一个列表的内容。方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frinedsports&#x3D;mysports[:]</span><br></pre></td></tr></table></figure><h4 id="split-处理字符串"><a href="#split-处理字符串" class="headerlink" title="split( )处理字符串"></a>split( )处理字符串</h4><p>这个方法(method)，可以将字符串以空格为分隔符，将字符串拆开，变成一个列表。变成列表后我们可以使用len( )获得此列表的元素个数，这相当于可以计算字符串是由多少个英文字母组成，由于中文字之间没有空格，该方法只适用在纯英文文件。</p><h4 id="in和not-in"><a href="#in和not-in" class="headerlink" title="in和not in"></a>in和not in</h4><p>主要是用于判断一个对象是否属于另一个对象，对象可以是字符串(string)、列表(list)、元组(Tuple)。语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolan&#x3D;obj1 in obj2 # obj1在obj2内会传回True</span><br><span class="line">boolan&#x3D;obj1 not in obj2 # obj1不在obj2内会传回True</span><br></pre></td></tr></table></figure><h4 id="is和not-is"><a href="#is和not-is" class="headerlink" title="is和not is"></a>is和not is</h4><p>用于比较两个对象是否相同，在此所谓相同并不只是内容相同，而是指对象变量指向相同的内存，对象可以是变量、字符串、列表、元组(Tuple)。语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolan&#x3D;obj1 is obj2 # obj1等于obj2会传回True</span><br><span class="line">boolan&#x3D;obj1 not is obj2 # obj1不等于obj2会传回True</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础2</title>
    <link href="http://yoursite.com/2020/09/22/Python-%E5%9F%BA%E7%A1%802/"/>
    <id>http://yoursite.com/2020/09/22/Python-基础2/</id>
    <published>2020-09-22T05:54:58.000Z</published>
    <updated>2020-09-24T14:41:24.325Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Python的基本数据类型有下列几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数值数据类型：常见的数值数据又可分成整数(int)和浮点数(float）</span><br><span class="line"></span><br><span class="line">布尔值(Boolean)数据类型</span><br><span class="line"></span><br><span class="line">字符串(string)数据类型</span><br></pre></td></tr></table></figure><h4 id="查看数据类型type"><a href="#查看数据类型type" class="headerlink" title="查看数据类型type"></a>查看数据类型type</h4><p>type( )函数可以列出变量的数据类型类别。</p><h4 id="整数与浮点数的运算"><a href="#整数与浮点数的运算" class="headerlink" title="整数与浮点数的运算"></a>整数与浮点数的运算</h4><p>Python具有简单自动转换能力，在计算时会将整数转换为浮点数再执行运算。</p><p>如不同数据类型的运算：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924213432821.png" alt="image-20200924213432821"></p><p>执行结果为：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924213517737.png" alt="image-20200924213517737"></p><h4 id="进位与函数"><a href="#进位与函数" class="headerlink" title="进位与函数"></a>进位与函数</h4><p>Python中定义凡是0b开头的数字，代表这是2进位的整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin()函数可以将一般数字转换为2进位</span><br></pre></td></tr></table></figure><p>Python中定义凡是0o开头的数字，代表这是8进位的整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oct()函数可以将一般数字转换为8进位</span><br></pre></td></tr></table></figure><p>Python中定义凡是0x开头的数字，代表这是16进位的整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hex()函数可以将一般数字转换为16进位</span><br></pre></td></tr></table></figure><h4 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h4><p>int( )：将数据类型强制转换为整数。</p><p>float( )：将数据类型强制转换为浮点数。</p><p>如将浮点数强制转换为整数的运算：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924214228593.png" alt="image-20200924214228593"></p><p>运算结果：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924214254420.png" alt="image-20200924214254420"></p><h4 id="数值运算常用函数"><a href="#数值运算常用函数" class="headerlink" title="数值运算常用函数"></a>数值运算常用函数</h4><p>abs()：计算绝对值。</p><p>pow(x,y)：返回x的y次方。</p><p>round()：返回四舍六入，不是四舍五入。</p><h4 id="布尔值类型"><a href="#布尔值类型" class="headerlink" title="布尔值类型"></a>布尔值类型</h4><p>Python的布尔值(Boolean)数据类型的值有两种，True(真)或False(伪)，它的数据类型代号是bool。这个布尔值一般是应用在程序流程的控制，特别是在条件表达式中。</p><p>如果将布尔值数据类型强制转换成整数，当原值是True，将得到1；当原值是False，将得到0。</p><p>如将布尔值强制转换为整数，同时列出转换的结果：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924214812881.png" alt="image-20200924214812881"></p><p>执行结果：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924214839869.png" alt="image-20200924214839869"></p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>字符串(string)数据是指两个单引号(‘)之间或是两个双引号(“)之间任意个数字元符号的数据，它的数据类型代号是str。</p><p>数学的运算符“+”，可以执行两个字符串相加，产生新的字符串。</p><p>str( )函数可以强制将数值数据转换为字符串数据。</p><p>使用单引号与双引号设定与输出字符串数据：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215013609.png" alt="image-20200924215013609"></p><p>执行结果：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215041213.png" alt="image-20200924215041213"></p><p>在处理多于一行的字符串时，可以使用三个单引号（或是三个双引号）将字符串包夹。</p><h5 id="关于逸出字符"><a href="#关于逸出字符" class="headerlink" title="关于逸出字符"></a>关于逸出字符</h5><p>在字符串使用中，如果字符串内有一些特殊字符，如单引号、双引号等，必须在此特殊字符前加上“\”(反斜杠)，才可正常使用，这种含有“\”符号的字符称逸出字符(Escape Character)。如下表：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215517313.png" alt="image-20200924215517313"></p><p>字符串使用中特别是碰到字符串含有单引号时，如果是使用单引号定义这个字符串时，必须要使用此逸出字符，才可以顺利显示。</p><h5 id="字符串数据的转换"><a href="#字符串数据的转换" class="headerlink" title="字符串数据的转换"></a>字符串数据的转换</h5><p>如果字符串含一个字符或一个文字时，可以使用下列执行数据的转换：</p><p>chr( x )：可以返回函数x值的字符，x是ASCII码值。</p><p>ord( x )：可以返回函数字符参数的Unicode码值，如果是中文字也可传回Unicode码值。如果是英文字符，Unicode码值与ASCII码值是一样的。</p><p>在Python可以允许将字符串与整数相乘，结果是字符串将重复该整数的次数。如下：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215902501.png" alt="image-20200924215902501"></p><p>执行结果：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924215932287.png" alt="image-20200924215932287"></p><p>有时设计程序时，想将字符串分行输出，可以使用字符串加法功能，在加法过程中加上换行字符“\n”即可产生字符串分行输出的结果。</p><h5 id="字符串前加r"><a href="#字符串前加r" class="headerlink" title="字符串前加r"></a>字符串前加r</h5><p>在使用Python时，如果在字符串前加上r，可以防止逸出字符(Escape Character)被转译。</p><h2 id="基本输入与输出"><a href="#基本输入与输出" class="headerlink" title="基本输入与输出"></a>基本输入与输出</h2><p>help( )函数可以列出某一个Python的指令或函数的使用说明。</p><h4 id="格式化输出print"><a href="#格式化输出print" class="headerlink" title="格式化输出print"></a>格式化输出print</h4><p>在使用格式化输出时，基本使用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print（“输出格式区” % （变量系列区））</span><br></pre></td></tr></table></figure><p>可以放置变量系列区对应的格式化字符，基本意义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%d：格式化整数输出</span><br><span class="line"></span><br><span class="line">%s：格式化字符串输出</span><br><span class="line"></span><br><span class="line">%f：格式化浮点数输出</span><br><span class="line"></span><br><span class="line">%x：格式化16进制输出</span><br><span class="line"></span><br><span class="line">%o：格式化8进制输出</span><br></pre></td></tr></table></figure><h4 id="精准格式化输出"><a href="#精准格式化输出" class="headerlink" title="精准格式化输出"></a>精准格式化输出</h4><p>print( )函数在格式化过程中，有提供功能可以设定保留多少格的空间让资料做输出，语法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%(+|-)nd：格式化整数输出</span><br><span class="line"></span><br><span class="line">%(+|-)m.nf：格式化浮点数输出</span><br><span class="line"></span><br><span class="line">%(+|-)nx：格式化16进位整数输出</span><br><span class="line"></span><br><span class="line">%(+|-)no：格式化8进位整数输出</span><br><span class="line"></span><br><span class="line">%(-)ns：格式化字符串输出</span><br></pre></td></tr></table></figure><p>对浮点数而言，m代表保留多少格数供输出（包含小数点），n则是小数数据保留格数。至于其他的数据格式n则是保留多少格数空间，如果保留格数空间不足将完整输出数据，如果保留格数空间太多则数据靠右对齐。</p><p>如果格式化数值数据有加上负号(-)，表示保留格数空间有多时，数据将靠左输出。如果格式化数值数据有加上正号(+)，表示输出数据是正值时，将在左边加上正值符号。</p><h4 id="format函数"><a href="#format函数" class="headerlink" title="format函数"></a>format函数</h4><p>字符串使用format方法做格式化的动作，基本使用格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;输出格式区&quot; .format(&quot;变量系列区&quot;))</span><br></pre></td></tr></table></figure><p>在输出格式区内的字符串变量使用“{ }”表示。</p><h4 id="输出数据到文件"><a href="#输出数据到文件" class="headerlink" title="输出数据到文件"></a>输出数据到文件</h4><h5 id="打开一个文件open"><a href="#打开一个文件open" class="headerlink" title="打开一个文件open"></a>打开一个文件open</h5><p>open( )函数可以打开一个文件供读取或写入，如果这个函数执行成功，会传回文件对象，这个函数的基本使用格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_open&#x3D;open(file,mode&#x3D;&quot;r&quot;)</span><br></pre></td></tr></table></figure><p>mode代表写入模式，基本的模式有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">“r”：这是预设，打开文件供读取(read)。</span><br><span class="line"></span><br><span class="line">“w”：打开文件供写入，如果原先文件有内容将被覆盖。</span><br><span class="line"></span><br><span class="line">“a”：打开文件供写入，如果原先文件有内容，新写入数据将附加在后面。</span><br><span class="line"></span><br><span class="line">“x”：打开一个新的文件供写入，如果所打开的文件已经存在会产生错误。</span><br><span class="line"></span><br><span class="line">“b”：以二进制模式打开文件。</span><br><span class="line"></span><br><span class="line">“t”：打开本文(txt)文件模式，这是默认。</span><br><span class="line"></span><br><span class="line">“+”：打开文件供更新用。</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1&#x3D;open(&quot;d:\1.txt&quot;,mode&#x3D;&quot;w&quot;)</span><br><span class="line">f1.close()</span><br></pre></td></tr></table></figure><h4 id="数据输入input"><a href="#数据输入input" class="headerlink" title="数据输入input"></a>数据输入input</h4><p>input( )函数功能与print( )函数功能相反，这个函数会从屏幕读取用户从键盘输入的数据，它的使用格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value&#x3D;input(&quot;promt:&quot;)</span><br></pre></td></tr></table></figure><p>value是变量，所输入的数据会存储在此变量内，特别需注意的是所输入的数据不论是字符串或是数值数据返回到value时一律是字符串数据，如果要执行数学运算需要用int( )函数转换为整数。</p><p>基本数据输入与运算示例：</p><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924223817769.png" alt="image-20200924223817769"></p><h4 id="列出所有内置函数dir"><a href="#列出所有内置函数dir" class="headerlink" title="列出所有内置函数dir"></a>列出所有内置函数dir</h4><p>可以使用下列方式列出Python所提供的内置函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir(_ _builtins_ _) 列出python内置函数</span><br></pre></td></tr></table></figure><p><img src="/2020/09/22/Python-%E5%9F%BA%E7%A1%802/image-20200924224110041.png" alt="image-20200924224110041"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python-基础1</title>
    <link href="http://yoursite.com/2020/09/18/Python-%E5%9F%BA%E7%A1%801/"/>
    <id>http://yoursite.com/2020/09/18/Python-基础1/</id>
    <published>2020-09-18T05:16:44.000Z</published>
    <updated>2020-09-18T06:24:59.764Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918134047614.png" alt="image-20200918134047614"></p><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="关于python"><a href="#关于python" class="headerlink" title="关于python"></a>关于python</h2><p>Python是一种直译式(Interpreted )、面向对象(Object Oriented )的程序语言，所谓的直译式语言是指，直译器(Interpretor)会将程序代码一句一句直接执行，不需要经过编译(compile)动作，将语言先转换成机器码，再予以执行。目前它的直译器是CPython，这是由C语言编写的一个直译程序。</p><p>Python的最初设计者是吉多·范罗姆苏(Guido van Rossum)，目前Python语言是由Python软件基金会管理，有关新版软件的相关信息可以在这个基金会网址(<a href="http://www.python.org)上下载浏览。" target="_blank" rel="noopener">www.python.org)上下载浏览。</a></p><p>2000年10月16日Python 2.0正式发表，主要是增加了垃圾回收的功能，同时支持Unicode。2008年12月3日Python 3.0正式发表，Python 2.7x已经被确定为最后一个Python 2.x的版本。</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918134202904.png" alt="image-20200918134202904"></p><p>Python是一种跨平台的程序语言，几乎主要操作系统，例如，Windows、MacOS、UNIX/LINUX等，皆可以安装和使用，可以在某一个平台上使用Python设计一个程序，未来这个程序也可以在其他平台上顺利运作。</p><h2 id="python的应用"><a href="#python的应用" class="headerlink" title="python的应用"></a>python的应用</h2><p>python的应用范围很广，部分应用范围为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">设计动画游戏</span><br><span class="line"></span><br><span class="line">支持图形接口(Graphical User Interface，GUI)开发</span><br><span class="line"></span><br><span class="line">开发与管理网站</span><br><span class="line"></span><br><span class="line">执行大数据分析</span><br><span class="line"></span><br><span class="line">企业内部开发工具</span><br><span class="line"></span><br><span class="line">黑客攻防</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>程序注释主要功能是让你所设计的程序可读性更高，更容易了解。</p><h4 id="注释符号"><a href="#注释符号" class="headerlink" title="注释符号"></a>注释符号</h4><p>“#”符号右边的文字，称程序注释，Python语言的直译器会忽略此符号右边的文字。</p><h4 id="单引号或双引号"><a href="#单引号或双引号" class="headerlink" title="单引号或双引号"></a>单引号或双引号</h4><p>如果要进行大段落的注释，可以用三个单引号或双引号将注释文字包夹。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是一个暂时存储数据的地方，在Python中可以用“=”等号设定变量的内容。</p><h4 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h4><p>Python对于变量的命名有一些规则要遵守，否则会造成程序错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">必须由英文字母、_(下画线)或中文字开头，建议使用英文字母</span><br><span class="line"></span><br><span class="line">变量名称只能由英文字母、数字、_(下画线)或中文字所组成</span><br><span class="line"></span><br><span class="line">英文字母大小写是敏感的，例如，Name与name被视为不同变量名称</span><br><span class="line"></span><br><span class="line">Python系统保留字（或称关键词）或Python内置函数名称不可当作变量名称</span><br></pre></td></tr></table></figure><p>下列是不可当作变量名称的Python系统保留字</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918134656457.png" alt="image-20200918134656457"></p><p>下列是不可当作变量名称的Python系统内置函数</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918134858584.png" alt="image-20200918134858584"></p><p>不合法变量示例</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918135000191.png" alt="image-20200918135000191"></p><h2 id="基本数学运算"><a href="#基本数学运算" class="headerlink" title="基本数学运算"></a>基本数学运算</h2><h4 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h4><p>四则运算是指加( + )、减( - )、乘( × )和除( / )。</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918135802081.png" alt="image-20200918135802081"></p><h4 id="余数和整除"><a href="#余数和整除" class="headerlink" title="余数和整除"></a>余数和整除</h4><p>余数(mod)所使用的符号是“%”，可计算出除法运算中的余数。整除所使用的符号是“//”，是指除法运算中只保留整数部分。</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918140437516.png" alt="image-20200918140437516"></p><h4 id="次方"><a href="#次方" class="headerlink" title="次方"></a>次方</h4><p>次方的符号是“ ** ”。</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918140547002.png" alt="image-20200918140547002"></p><h4 id="运算的优先级"><a href="#运算的优先级" class="headerlink" title="运算的优先级"></a>运算的优先级</h4><p>Python语言碰上计算式同时出现在一个指令内时，除了括号“ (”、“)”最优先外，其余计算优先次序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.次方</span><br><span class="line"></span><br><span class="line">2.乘法、除法、求余数(%)、求整数(&#x2F;&#x2F;)，彼此依照出现顺序运算</span><br><span class="line"></span><br><span class="line">3.加法、减法，彼此依照出现顺序运算</span><br></pre></td></tr></table></figure><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>常见的赋值运算符如下：</p><p><img src="/2020/09/18/Python-%E5%9F%BA%E7%A1%801/image-20200918141445718.png" alt="image-20200918141445718"></p><h4 id="等号的多重指定使用"><a href="#等号的多重指定使用" class="headerlink" title="等号的多重指定使用"></a>等号的多重指定使用</h4><p>使用Python时，可以一次设定多个变量等于某一数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;y&#x3D;z&#x3D;10</span><br><span class="line">x&#x3D;10</span><br><span class="line">y&#x3D;10</span><br><span class="line">z&#x3D;10</span><br></pre></td></tr></table></figure><p>Python也允许多个变量同时指定不同的数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x,y,z &#x3D;10,20,30</span><br><span class="line">x&#x3D;10</span><br><span class="line">y&#x3D;20</span><br><span class="line">z&#x3D;30</span><br></pre></td></tr></table></figure><p>将2个变量内容交换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x,y&#x3D;10,20</span><br><span class="line">x,y&#x3D;y,x</span><br><span class="line">x&#x3D;20</span><br><span class="line">y&#x3D;10</span><br></pre></td></tr></table></figure><h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>程序设计时，如果某个变量不再需要，可以使用del指令将此变量删除，相当于可以收回原变量所占的内存空间，以节省内存空间。</p><p>删除格式为：del 变量名称</p><h4 id="python的断行"><a href="#python的断行" class="headerlink" title="python的断行"></a>python的断行</h4><p>将一个语句分成多行：</p><p>碰上一个语句很长，需要分成2行或更多行撰写，此时可以在叙述后面加上“\”符号，Python解释器会将下一行的语句视为这一行的语句。特别注意，在“\”符号右边不可加上任何符号或文字，即使是注释符号也不允许。</p><p>也可以在语句内使用小括号，如果使用小括号，就可以在语句右边加上注释符号。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安装kafka</title>
    <link href="http://yoursite.com/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/"/>
    <id>http://yoursite.com/2020/08/02/CentOS7安装kafka/</id>
    <published>2020-08-02T10:11:31.000Z</published>
    <updated>2020-08-04T15:38:21.506Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="CentOS7下安装kafka"><a href="#CentOS7下安装kafka" class="headerlink" title="CentOS7下安装kafka"></a>CentOS7下安装kafka</h1><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>Kafka 服务端代码是用 Scala 开发语言编写的，Scala 是 JVM 系语言中的一种，这意味着用 Scala 编写的源代码编译之后也是 Java 字节码，并运行在 Java 虚拟机上。因此，在开始安装 Kafka 之前，我们需要先在系统上安装 JDK（Java SE Development Kit， Java SE开发套件），JDK 包含的 JRE（Java SE Runtime Environment，Java 运行时环境）是运行 Java 应用程序所必需的。</p><p>多数情况下，推荐安装 JDK 8 及以上的版本，因为 Kafka 自 2.0.0 版本开始，就已经正式摒弃对 Java 7 的支持了。另外，运行 Kafka 还需要安装 Apache ZooKeeper 服务，该服务是用来同步分布式进程。</p><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><h4 id="1、环境"><a href="#1、环境" class="headerlink" title="1、环境"></a>1、环境</h4><p>操作系统：centos7.4</p><p>安装包版本： jdk-8u221-linux-x64.tar.gz</p><h4 id="2、卸载系统自带-OpenJDK"><a href="#2、卸载系统自带-OpenJDK" class="headerlink" title="2、卸载系统自带 OpenJDK"></a>2、卸载系统自带 OpenJDK</h4><p>如果 CentOS 系统中集成了 OpenJDK，那么需要先卸载自带的 OpenJDK 才能安装标准版 JDK，卸载具体步骤如下：</p><p>1、系统终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure><p>若系统中集成了 OpenJDK，会出现 xxxx_openjdk_xxxx 的信息；</p><p>2、删除 OpenJDK：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps rpm -qa | grep java</span><br></pre></td></tr></table></figure><h4 id="3、安装JDK1-8"><a href="#3、安装JDK1-8" class="headerlink" title="3、安装JDK1.8"></a>3、安装JDK1.8</h4><p>1、将下载的安装包使用winscp拷贝至服务器<code>/usr/local/src</code>目录下。</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802182606968.png" alt="image-20200802182606968"></p><p>2、新建JDK安装目录 <code>/usr/local/java</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;java</span><br></pre></td></tr></table></figure><p>3、解压文件 jdk-8u221-linux-x64.tar.gz 至安装目录 /usr/local/java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf jdk-8u221-linux-x64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;java</span><br></pre></td></tr></table></figure><p>4、配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>JAVA_HOME为JDK安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_221</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib</span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure><p>5、让更新的环境变量生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>6、检测安装是否成功，若安装并配置成功，可以看到以输出；如果得到诸如“-bash: java: 未找到命令 ”就需要退回去反复检査安装和配置步骤是否正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802183301282.png" alt="image-20200802183301282"></p><h2 id="安装和配置ZooKeeper"><a href="#安装和配置ZooKeeper" class="headerlink" title="安装和配置ZooKeeper"></a>安装和配置ZooKeeper</h2><h4 id="1、下载安装包"><a href="#1、下载安装包" class="headerlink" title="1、下载安装包"></a>1、下载安装包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"></span><br><span class="line">wget http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;zookeeper&#x2F;zookeeper-3.5.8&#x2F;apache-zookeeper-3.5.8-bin.tar.gz</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802184047139.png" alt="image-20200802184047139"></p><h4 id="2、新建-安装目录"><a href="#2、新建-安装目录" class="headerlink" title="2、新建 安装目录"></a>2、新建 安装目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;zookeeper</span><br></pre></td></tr></table></figure><h4 id="3、解压至zookeeper目录"><a href="#3、解压至zookeeper目录" class="headerlink" title="3、解压至zookeeper目录"></a>3、解压至zookeeper目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line"></span><br><span class="line">tar zxvf apache-zookeeper-3.5.8-bin.tar.gz -C &#x2F;usr&#x2F;local&#x2F;zookeeper</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802184509754.png" alt="image-20200802184509754"></p><h4 id="4、配置zookeeper"><a href="#4、配置zookeeper" class="headerlink" title="4、配置zookeeper"></a>4、配置zookeeper</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;conf</span><br><span class="line">[root@172 conf]# ll</span><br><span class="line">total 12</span><br><span class="line">-rw-r--r--. 1 root root  535 May  4 21:26 configuration.xsl</span><br><span class="line">-rw-r--r--. 1 root root 2712 May  4 21:26 log4j.properties</span><br><span class="line">-rw-r--r--. 1 root root  922 May  4 21:26 zoo_sample.cfg</span><br></pre></td></tr></table></figure><p>1) 复制 zoo_sample.cfg 并重命名为 zoo.cfg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure><p>2) 创建 ZooKeeper 保存数据目录和保存日志目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;data &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;logs</span><br></pre></td></tr></table></figure><p>3) 修改配置文件 zoo.cfg，修改内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;data </span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;logs</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802185319790.png" alt="image-20200802185319790"></p><p>保存并退出文件修改。</p><p>4) 启动zookeeper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;bin&#x2F;</span><br><span class="line"></span><br><span class="line">[root@172 bin]# .&#x2F;zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: &#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;apache-zookeeper-3.5.8-bin&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802185712170.png" alt="image-20200802185712170"></p><p>ZooKeeper启动成功</p><h2 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h2><h4 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h4><p>从 Kafka 官网下载页 <a href="https://kafka.apache.org/downloads" target="_blank" rel="noopener">https://kafka.apache.org/downloads</a> 获取安装文件，当前最新的稳定版本是 2.4.1，于 2020 年 3 月 12 日发行。这里选择下载二进制文件 kafka_2.12-2.4.1.tgz。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget https:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;kafka&#x2F;2.4.1&#x2F;kafka_2.12-2.4.1.tgz</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802193122030.png" alt="image-20200802193122030"></p><h4 id="2、创建安装目录"><a href="#2、创建安装目录" class="headerlink" title="2、创建安装目录"></a>2、创建安装目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;kafka</span><br></pre></td></tr></table></figure><h4 id="3、解压缩"><a href="#3、解压缩" class="headerlink" title="3、解压缩"></a>3、解压缩</h4><p>解压缩文件 kafka_2.12-2.4.1.tgz 至目录 /usr/local/kafka：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvzf kafka_2.12-2.4.1.tgz -C &#x2F;usr&#x2F;local&#x2F;kafka --strip 1</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200802193436385.png" alt="image-20200802193436385"></p><p>进入目录 /usr/local/kafka，可以看到以下子目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@172 src]# cd &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;</span><br><span class="line">[root@172 kafka]# ll</span><br><span class="line">total 56</span><br><span class="line">drwxr-xr-x. 3 root root  4096 Mar  3 08:34 bin</span><br><span class="line">drwxr-xr-x. 2 root root  4096 Mar  3 08:34 config</span><br><span class="line">drwxr-xr-x. 2 root root  8192 Aug  2 19:34 libs</span><br><span class="line">-rw-r--r--. 1 root root 32216 Mar  3 08:32 LICENSE</span><br><span class="line">-rw-r--r--. 1 root root   337 Mar  3 08:32 NOTICE</span><br><span class="line">drwxr-xr-x. 2 root root    44 Mar  3 08:34 site-docs</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin目录下是操作 Kafka 的可执行脚本（.sh 文件），还包含在 windows 系统下的可执行脚本（.bat 文件），包括 Kafka 启动&#x2F;停止脚本、消费者性能测试脚本、生产者性能测试脚本、分区重分配脚本等；</span><br><span class="line"></span><br><span class="line">&#x2F;config目录是存放配置文件；</span><br><span class="line"></span><br><span class="line">&#x2F;libs目录是存放依赖库文件；</span><br><span class="line"></span><br><span class="line">&#x2F;logs目录存放的是 Kafka 的运行日志文件。</span><br></pre></td></tr></table></figure><h4 id="4、配置"><a href="#4、配置" class="headerlink" title="4、配置"></a>4、配置</h4><p>打开配置文件config/server.properties，修改 listeners 配置和 zookeeper 地址，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd  &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;config</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;监听地址</span><br><span class="line">listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;172.16.12.144:9092</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;zookeeper地址</span><br><span class="line">zookeeper.connect&#x3D;172.16.12.144:2181</span><br></pre></td></tr></table></figure><p>保存退出</p><h4 id="5、添加kafka账号"><a href="#5、添加kafka账号" class="headerlink" title="5、添加kafka账号"></a>5、添加kafka账号</h4><p>在启动 Kafka 服务之前，为保障系统安全，添加运行 Kafka 服务的账号，并以较低权限账号运行 Kafka 服务，且禁用该账号的 ssh 登录权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加kafka账号</span><br><span class="line">useradd kafka</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置kafka账号密码</span><br><span class="line">passwd kafka</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将目录所有者和组设置为kafka</span><br><span class="line">chown -R kafka:kafka &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;</span><br></pre></td></tr></table></figure><p>切换至 kafka 账号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su kafka</span><br></pre></td></tr></table></figure><p>kafka日志保存位置设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;config</span><br><span class="line">vim server.properties</span><br></pre></td></tr></table></figure><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804233616568.png" alt="image-20200804233616568"></p><p>将log存放目录设置为非/tmp目录即可，然后对目录进行赋权即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R kafka:kafka &#x2F;data</span><br></pre></td></tr></table></figure><h4 id="6、启动kafka服务"><a href="#6、启动kafka服务" class="headerlink" title="6、启动kafka服务"></a>6、启动kafka服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;</span><br><span class="line">&#x2F;bin&#x2F;kafka-server-start.sh .&#x2F;config&#x2F;server.properties</span><br></pre></td></tr></table></figure><p>以守护进程（后台进程）的方式启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;kafka-server-start.sh .&#x2F;config&#x2F;server.properties &amp;</span><br></pre></td></tr></table></figure><h4 id="7、停止kafka服务"><a href="#7、停止kafka服务" class="headerlink" title="7、停止kafka服务"></a>7、停止kafka服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;kafka</span><br><span class="line">.&#x2F;bin&#x2F;kafka-server-stop.sh</span><br></pre></td></tr></table></figure><h2 id="kafka可视化"><a href="#kafka可视化" class="headerlink" title="kafka可视化"></a>kafka可视化</h2><h4 id="1、可视化工具"><a href="#1、可视化工具" class="headerlink" title="1、可视化工具"></a>1、可视化工具</h4><p>kafka的可视化工具为kafkatool，可用于查看kafka消息队列中的内容及上报和消费。</p><p>下载地址：https[]]://www[.]kafkatool.com/download.html</p><p>可选择相应的版本和操作系统进行下载</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804231604138.png" alt="image-20200804231604138"></p><h4 id="2、工具简单使用"><a href="#2、工具简单使用" class="headerlink" title="2、工具简单使用"></a>2、工具简单使用</h4><p>安装完成后，搜索kafkatool打开</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804231807412.png" alt="image-20200804231807412"></p><p>点击file，新增连接</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804231949654.png" alt="image-20200804231949654"></p><p>连接设置界面如下</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804232053262.png" alt="image-20200804232053262"></p><p>需要设置的地方，其他默认即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster name:集群名称</span><br><span class="line">kafka version:版本根据安装的kafka版本选择对应的版本</span><br><span class="line">Zookeeper host：zookeeper服务器IP</span><br></pre></td></tr></table></figure><p>点击ping测试是否联通</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804232551742.png" alt="image-20200804232551742"></p><h4 id="3、设置队列内容显示格式"><a href="#3、设置队列内容显示格式" class="headerlink" title="3、设置队列内容显示格式"></a>3、设置队列内容显示格式</h4><p>设置消息队列中的内容显示格式，点击tools，选择settings</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804232754502.png" alt="image-20200804232754502"></p><p>点击topics，可以将key和message都设置为string显示，key不要设置为NO key</p><p><img src="/2020/08/02/CentOS7%E5%AE%89%E8%A3%85kafka/image-20200804232905027.png" alt="image-20200804232905027"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>http[]s://w[]ww.linjiangxiong.com/2020/03/19/how-to-install-apache-kafka-on-centos7/</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="运维" scheme="http://yoursite.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>暴力破解</title>
    <link href="http://yoursite.com/2020/08/01/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/08/01/暴力破解/</id>
    <published>2020-08-01T14:41:26.000Z</published>
    <updated>2020-08-01T14:42:17.290Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h1><h2 id="暴力破解-1"><a href="#暴力破解-1" class="headerlink" title="暴力破解"></a>暴力破解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.原理</span><br><span class="line">使用自定义字典文件中的内容与验证程序交互，从而在枚举过程中得到正确数据。</span><br><span class="line">如破解用户名、密码</span><br><span class="line">破解验证码</span><br><span class="line"></span><br><span class="line">暴力破解的前提：</span><br><span class="line">应用程序或服务器未进行限制</span><br><span class="line">具有内容涵盖全面的字典</span><br><span class="line"></span><br><span class="line">2.暴力破解方式</span><br><span class="line">在线方式</span><br><span class="line">离线方式</span><br><span class="line">破解成功取决于字典是否强大，以及本地机器与服务器性能、带宽限制等因素。</span><br><span class="line"></span><br><span class="line">3.使用Burpsuite进行暴力破解</span><br><span class="line">判断依据：登录成功与失败返回的HTML内容不同，大小不同，根据大小不同选出唯一的内容。</span><br></pre></td></tr></table></figure><h2 id="暴力破解表单内容"><a href="#暴力破解表单内容" class="headerlink" title="暴力破解表单内容"></a>暴力破解表单内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.HTML表单</span><br><span class="line">表单是一个包含表单元素的区域。</span><br><span class="line">表单元素是允许用户在表单中输入内容，如文本域、下拉列表、单选框、复选框等。</span><br><span class="line"></span><br><span class="line">2.暴力破解POST提交数据</span><br><span class="line">在登录页面经常使用POST方式提交数据。通过Burpsuite对POST提交的数据进行暴力破解。</span><br><span class="line"></span><br><span class="line">3.暴力破解验证码</span><br></pre></td></tr></table></figure><h2 id="HTTP-basic认证"><a href="#HTTP-basic认证" class="headerlink" title="HTTP basic认证"></a>HTTP basic认证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.HTTP basic认证</span><br><span class="line">基本认证 basic authorizcation,是http1.0提出的认证方法。</span><br><span class="line"></span><br><span class="line">基本认证步骤：</span><br><span class="line">(1)服务端访问一个受http基本认证保护的资源</span><br><span class="line">(2)服务器返回401状态，要求客户端提供用户名和密码进行认证</span><br><span class="line">(3)客户端将输入的用户名密码用base64进行编码后，采用非加密明文方式发送给服务器</span><br><span class="line">(4)如果认证成功，则返回相应的资源。如果认证失败，则返回401状态，要求进行重新认证</span><br><span class="line"></span><br><span class="line">2.burpsuite分析认证过程</span><br><span class="line">使用Burpsuite对HTTP Basic认证进行抓包分析</span><br><span class="line">Authorizcation：Basic xxxxxx（base64加密后的用户名和密码）</span><br><span class="line"></span><br><span class="line">3.暴力破解burpsuite认证</span><br><span class="line">使用Burpsuite对目标进行暴力破解。</span><br><span class="line">在intruder里，选中base64加密后的用户名密码，add添加，选中payload；</span><br><span class="line">在payload processing里选中添加encode规则，选中base64，开始暴力破解。</span><br></pre></td></tr></table></figure><h2 id="HTTP-basic认证字典生成"><a href="#HTTP-basic认证字典生成" class="headerlink" title="HTTP basic认证字典生成"></a>HTTP basic认证字典生成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.字典生成思路</span><br><span class="line">字典生成是针对具体目标生成，确定目标：username，passwd</span><br><span class="line">思路：</span><br><span class="line">读取字典文件内容；</span><br><span class="line">对读取来的文件内容进行拼接；</span><br><span class="line">将新生成的内容写入到最终字典文件中，要符合HTTP Basic认证。</span><br></pre></td></tr></table></figure><h2 id="Burpsuite设置HTTP认证"><a href="#Burpsuite设置HTTP认证" class="headerlink" title="Burpsuite设置HTTP认证"></a>Burpsuite设置HTTP认证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.设置原因</span><br><span class="line">在web应用测试过程中，如果web设置了HTTP认证，就需要使用用户名、密码进行登录才能进行保护区域的资源访问。</span><br><span class="line"></span><br><span class="line">Burpsuite中提供了用于认证设置的功能模块可以设置HTTP认证需要的用户名、密码，方便测试。</span><br><span class="line">在useroptions在的Platform Authentication，点击add，填写destination host为目标ip，Authentication type选为Basic。</span><br></pre></td></tr></table></figure><h2 id="离线暴力破解"><a href="#离线暴力破解" class="headerlink" title="离线暴力破解"></a>离线暴力破解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.离线破解</span><br><span class="line">离线破解：在破解过程中，已经获得加密密文，在不与目标服务器交互的情况下，利用在线网站或本地程序对密文进行破解。</span><br><span class="line"></span><br><span class="line">离线破解不会触发密码锁定机制；</span><br><span class="line">不会产生大量的登录失败日志引起注意。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://yoursite.com/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="暴力破解" scheme="http://yoursite.com/tags/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
</feed>
